<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-07-07T15:02:17+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">IT 데이터베이스</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>GitHub User</name></author><entry><title type="html">[TypeScript] 변수와 함수 타입 정의(미완)</title><link href="http://localhost:4000/typescirpt/2022/07/05/typescript-03.html" rel="alternate" type="text/html" title="[TypeScript] 변수와 함수 타입 정의(미완)" /><published>2022-07-05T00:00:00+09:00</published><updated>2022-07-05T00:00:00+09:00</updated><id>http://localhost:4000/typescirpt/2022/07/05/typescript-03</id><content type="html" xml:base="http://localhost:4000/typescirpt/2022/07/05/typescript-03.html"><![CDATA[<h2 id="자바스크립트에-타입-추가하는-방법">자바스크립트에 타입 추가하는 방법</h2>

<p>밑의 자바스크립트에서 sum이라는 함수에 들어가는 파라미터 a,b에 타입을 지정해줄 수 있는 방법이 있다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="dl">'</span><span class="s1">10</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">/** */</code> 주석처리 안에다 <code class="language-plaintext highlighter-rouge">@param {type} 파라미터명</code>을 적어주고 리턴되는 값도 <code class="language-plaintext highlighter-rouge">@returns {type}</code>으로 지정해 줄 수 있다.</li>
  <li>타입스크립트처럼 에러를 에디터에서 확인하려면 <code class="language-plaintext highlighter-rouge">@ts-check</code>를 주석에 넣어주면 에러를 발생시켜준다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @ts-check</span>

<span class="cm">/**
 * 
 * @param {number} a 
 * @param {number} b 
 * @returns {number}
 */</span>
<span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="o">+</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">;</span> 
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="dl">'</span><span class="s1">10</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>리턴값은 number 타입을 줬기 때문에 string 형식을 지정할 수 없다는 에러가 발생되고, sum() 함수에도 number 타입의 파라미터만 입력받을 수 있으므로 에러를 발생시키게 된다.</p>

<p><img src="https://user-images.githubusercontent.com/52439201/177474279-b39c40ba-6b84-4827-9840-708091d06101.png" alt="스크린샷 2022-07-06 오후 2 18 26" /></p>

<p><br /></p>

<h2 id="기본-타입-정의">기본 타입 정의</h2>

<h3 id="string">String</h3>

<p>자바스크립트에서 변수 타입이 문자열이면 아래와 같이 <code class="language-plaintext highlighter-rouge">string</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">str</span><span class="p">:</span> <span class="nx">string</span><span class="p">;</span>
<span class="nx">str</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">str</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// error</span>
</code></pre></div></div>

<h3 id="number">number</h3>
<p>자바스크립트에서 변수 타입이 숫자면 아래와 같이 <code class="language-plaintext highlighter-rouge">number</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">number</span><span class="p">:</span> <span class="nx">number</span><span class="p">;</span>
<span class="nx">number</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// error</span>
<span class="nx">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="boolean">boolean</h3>
<p>자바스크립트에서 변수 타입이 불린이면 아래와 같이 <code class="language-plaintext highlighter-rouge">boolean</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">boolean</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>

<span class="nx">boolean</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="nx">boolean</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// error</span>
</code></pre></div></div>
<h3 id="object">Object</h3>
<p>자바스크립트에서 변수 타입이 객체이면 아래와 같이 <code class="language-plaintext highlighter-rouge">{var1: type1, var2: type2}</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">person</span><span class="p">:</span> <span class="p">{</span><span class="nl">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="nx">number</span><span class="p">}</span>

<span class="nx">person</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span>
<span class="nx">person</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span> <span class="c1">// name은 string 타입이므로 number 타입은 사용 x =&gt; error </span>
</code></pre></div></div>

<h3 id="array">Array</h3>
<p>자바스크립트에서 변수 타입이 배열이면 아래와 같이 <code class="language-plaintext highlighter-rouge">Array&lt;type&gt; or type[]</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">number_arr</span><span class="p">:</span> <span class="nx">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">string_arr</span><span class="p">:</span> <span class="nx">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">boolean_arr</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>
</code></pre></div></div>
<p>또는 아래와 같이 제네릭으로 사용할 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">number_arr</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">string_arr</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">boolean_arr</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">boolean</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="tuple">Tuple</h3>
<ul>
  <li>튜플은 배열의 길이가 고정되고 각 요소의 타입이 지정되어 있는 배열 형식을 의미한다.</li>
  <li>자바스크립트에서 변수 타입이 튜플이면 아래와 같이 <code class="language-plaintext highlighter-rouge">[type1, type2]</code> 타입을 선언해서 사용한다.</li>
  <li>길이가 고정되어 있고 각 자리마다 타입을 선언하기 때문에, 정의되지 않는 인덱스에 접근하거나 정의하지 않는 타입이면 에러가 발생한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">tuple_arr</span><span class="p">:</span> <span class="p">[</span><span class="nx">string</span><span class="p">,</span> <span class="nx">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">hi</span><span class="dl">'</span><span class="p">,</span> <span class="mi">10</span><span class="p">];</span>

<span class="nx">tuple_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1">// 길이가 '2'인 튜플 형식 '[string, number]'의 인덱스 '2'에 요소가 없습니다.</span>
<span class="nx">tuple_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="dl">'</span><span class="s1">!</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 'number' 형식에 'concat' 속성이 없습니다.</span>
</code></pre></div></div>

<h3 id="any">Any</h3>
<p>기존에 자바스크립트로 구현되어 있는 웹 서비스 코드에 타입스크립트를 점진적으로 적용할 때 활용하면 좋은 타입이다. 단어 의미 그대로 모든 타입에 대해서 허용한다는 의미를 갖고 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">string</span><span class="p">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">number</span><span class="p">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">boolean</span><span class="p">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">arr</span><span class="p">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">hi</span><span class="dl">'</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="void">Void</h3>
<ul>
  <li>변수에는 undefined와 null만 할당하고, 함수에는 반환 값을 설정할 수 없는 타입이다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">void_type</span><span class="p">:</span> <span class="k">void</span><span class="p">;</span>
<span class="nx">void_type</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// 'number' 형식은 'void' 형식에 할당할 수 없습니다.</span>
<span class="nx">void_type</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 'string' 형식은 'void' 형식에 할당할 수 없습니다.</span>

<span class="kd">function</span> <span class="nx">void_fn</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">void</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">void_fn</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">void</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">//'number' 형식은 'void' 형식에 할당할 수 없습니다.</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="함수-타입">함수 타입</h2>]]></content><author><name>GitHub User</name></author><category term="Typescirpt" /><category term="Typescirpt" /><category term="Javascript" /><category term="ES6" /><summary type="html"><![CDATA[자바스크립트에 타입 추가하는 방법]]></summary></entry><entry><title type="html">[Electron] 01. 일렉트론이란?</title><link href="http://localhost:4000/electron/2022/06/28/electron.html" rel="alternate" type="text/html" title="[Electron] 01. 일렉트론이란?" /><published>2022-06-28T00:00:00+09:00</published><updated>2022-06-28T00:00:00+09:00</updated><id>http://localhost:4000/electron/2022/06/28/electron</id><content type="html" xml:base="http://localhost:4000/electron/2022/06/28/electron.html"><![CDATA[<h2 id="일렉트론electron이란">일렉트론(Electron)이란?</h2>

<p>일렉트론은 Javascript, HTML, CSS 만으로도 데스크탑 앱을 만들 수 있는 프레임워크이다. 2013년 아톰 쉘(Atom Shell)이라 불리는 크로스 플랫폼 애플리케이션 쉘로 시작했으며 오픈소스화, 명칭 변경등을 거쳐 현재는 깃허브에서 개발하고 있다.</p>

<p>자바스크립트는 현재 전세계에서 가장 많은 개발자가 사용하는 프래그래밍 언어로 그 인기만큼 활용 범위가 커지고 있다. 그 중 하나가 일렉트론이다.
매년 발표되는 <a href="https://roadmap.sh/frontend">WEB Developer frontend roadmap</a>을 살펴보면 데스크탑 앱에 일렉트론이 있는 것을 확인할 수 있다.</p>

<p><br /></p>

<h2 id="일렉트론-특징">일렉트론 특징</h2>

<h3 id="웹기술">웹기술</h3>
<ul>
  <li>백엔드 : node.js 런타임</li>
  <li>프론트엔드 : Chromium(크로미엄, 오픈소스 웹브라우저 프로젝트) + (Javascript, HTML, CSS)를 이용 React, Vue, Angular도 사용가능하다.</li>
</ul>

<h3 id="오픈소스-기반">오픈소스 기반</h3>
<p>일렉트론은 Github가 관리하는 오픈소스 프로젝트이며 적극적인 참여자들과 함께하는 커뮤니티이다.</p>

<h3 id="장점">장점</h3>
<ul>
  <li>
    <p><strong>낮은 진입 장벽</strong>:<br />
일렉트론은 개발자의 진입 장벽이 낮다는 장점이 있다. Javascript, HTML, CSS 및 웹 기술을 다룰줄 아는 개발자라면 누구나 일렉트론 앱을 개발할 수 있다. 그 말은 따로 새로운 기술이나 언어를 배울 필요가 없기 때문에 기존의 웹 기술을 사용하던 개발자들은 어렵지 않게 시작할 수 있다.</p>
  </li>
  <li>
    <p><strong>개발 속도 향상</strong>: <br />
자바스크립트의 인터프리터 방식으로 개발자는 손쉽게 디버깅하고 최적화할 수 있어 일렉트론 앱을 빠르게 구현할 수 있다. 또한, 일렉트론으로 개발된 애플리케이션은 일반적으로 웹 애플리케이션의 비즈니스 로직, 디자인 및 구조를 재사용하기 때문에 개발에 소요되는 시간과 비용을 줄일 수 있다.</p>
  </li>
  <li>
    <p><strong>크로스 플랫폼</strong>:<br />
각기 다른 os 플랫폼을 지원한다는 장점이 있다. 데스크탑 앱을 개발할 때 각 os마다 최적화 작업을 진행해야하고 API선언 및 제공이 달라질 수 있으며 os별로 코드가 상이하기 때문에 유지보수에 어려움을 겪을 수 있다. 하지만 일렉트론은 이러한 이슈들을 해결할 수 있다. 맥, 윈도우, 리눅스별로 적합한 룩앤필을 맞추고 개발자들에게 친숙한 자바스크립트, HTML, CSS를 활용하여 개발하기 때문에 쉽게 애플리케이션을 구성할 수 있다.</p>
  </li>
</ul>

<p>또한, 한번에 세 가지 os에 대한 빌드를 지원하고 설치할 수 있도록 도와준다. 기존의 웹 기술을 그대로 사용하면서도 브라우저 버전별로 기능을 제약하거나 타겟 플랫폼에 따라 별도의 버전을 유지할 필요가 없게 된다. os 관련 어려운 부분은 일렉트론이 처리하기 때문에 개발자는 응용 프로그램에만 집중할 수 있다.</p>

<p>정리해서,</p>

<ul>
  <li>일렉트론은 웹 프론트엔드 기술을 사용할 수 있는 개발자라면 쉽게 사용할 수 있을 정도로 러닝커브가 낮다.</li>
  <li>일렉트론은 오픈소스 기반 프로젝트이므로 지속적인 업데이트와 큰 규모의 커뮤니티 생태계를 가지고 있다.</li>
  <li>크로스 플랫폼이라서 맥, 윈도우, 리눅스 환경 어디서든 구동할 수 있는 장점이 잇다.</li>
</ul>

<p><br /></p>

<h2 id="일렉트론-활용사례">일렉트론 활용사례</h2>

<p>그렇다면 일렉트론으로 개발한 애플리케이션은 무엇이 있을까?</p>

<p>대표적으로 <code class="language-plaintext highlighter-rouge">아톰 에디터</code>, <code class="language-plaintext highlighter-rouge">VSCode</code>, <code class="language-plaintext highlighter-rouge">슬랙</code>, <code class="language-plaintext highlighter-rouge">워드프레스</code> 등이 있으며 한국에서는 협업 툴로 유명한 <code class="language-plaintext highlighter-rouge">잔디</code>가 그 예시이다.
<a href="www.electronjs.org/apps">일렉트론 웹사이트</a>를 방문하면 카테고리별로 일렉트론으로 개발한 앱들을 확인할 수 있다.</p>]]></content><author><name>GitHub User</name></author><category term="Electron" /><category term="Node.js" /><category term="Javascript" /><summary type="html"><![CDATA[일렉트론(Electron)이란?]]></summary></entry><entry><title type="html">[Git] git flow 전략 파악하기</title><link href="http://localhost:4000/git/2022/06/26/git-10.html" rel="alternate" type="text/html" title="[Git] git flow 전략 파악하기" /><published>2022-06-26T00:00:00+09:00</published><updated>2022-06-26T00:00:00+09:00</updated><id>http://localhost:4000/git/2022/06/26/git-10</id><content type="html" xml:base="http://localhost:4000/git/2022/06/26/git-10.html"><![CDATA[<h2 id="git-flow-전략">git-flow 전략</h2>

<p>Git-flow는 총 5가지 브랜치를 사용하고 운영한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">master</code> 브랜치 : 기준이 되는 브랜치로 제품을 배포하는 브랜치이다.</li>
  <li><code class="language-plaintext highlighter-rouge">develop</code> 브랜치 : 개발 브랜치로 개발자들이 이 브랜치를 기준으로 각자 작업한 기능들을 합(Merge)한다.</li>
  <li><code class="language-plaintext highlighter-rouge">feature</code> 브랜치 : 단위 기능을 개발하는 브랜치로 기능 개발이 완료되면 develop 브랜치에 합(Merge)한다.</li>
  <li><code class="language-plaintext highlighter-rouge">release</code> 브랜치 : 배포를 위해 master 브랜치로 보내기 전에 먼저 QA(품질검사)를 하기위한 브랜치이다.</li>
  <li><code class="language-plaintext highlighter-rouge">hotfix</code> 브랜치 : master 브랜치로 배포를 했는데 버그가 생겼을 떄 긴급 수정하는 브랜치이다.</li>
</ul>

<blockquote>
  <p>! 여기서 핵심이 되는 브랜치는 master 브랜치와 develop 브랜치이다. 나머지 브랜치는 필요에 의해 운영되는 브랜치라고 생각하면 된다.</p>
</blockquote>

<p><br /></p>

<h2 id="메인-브랜치master-develop">메인 브랜치(master, develop)</h2>

<p>git-flow 전략에서 핵심이 되는 브랜치는 master, develop 브랜치이다.</p>

<h3 id="master-브랜치">master 브랜치</h3>
<p>배포 가능한 상태만을 관리하는 브랜치로 안정적인 버전의 소스들만 관리되는 브랜치이다. master 브랜치의 HEAD는 최신 배포판의 소스코드 버전이 들어있다. master 브랜치는 지난 배포판의 소스코드를 따라가기 위해 태그(tag)들이 추가되어 있다. 이 태그를 확인해서 각 릴리즈 버전의 소스코드를 빠르게 확인한다.</p>

<p>정리해서, master 브랜치는 운영서버에 배포해야 되는 소스코드가 관리되어야 한다(안정성이 충분히 검증된 소스코드).</p>

<h3 id="develop-브랜치">develop 브랜치</h3>
<p>develop 브랜치는 다음에 배포할 것을 개발하는 브랜치이다. develop 브랜치는 통합 브랜치의 역할을 한다. 평소 개발자들은 이 브랜치를 기반으로 개발을 진행해야한다.
개발자들은 develop 브랜치에서 feature 브랜치를 생성하고, 소스코드 수정 및 기능 개발이 완료되면 develop 브랜치로 <code class="language-plaintext highlighter-rouge">풀 리퀘스트</code> 요청을 하게 된다.</p>

<p><br /></p>

<h2 id="feature-브랜치">feature 브랜치</h2>
<ul>
  <li>생성되어지는 브랜치 : develop</li>
  <li>merge 해야되는 브랜치 : develop</li>
</ul>

<p>feature 브랜치 또는 topic 브랜치라 부른다.</p>

<p>단위 기능을 개발하는 브랜치로 develop 브랜치의 HEAD에서 생성된다. 새로운 기능 개발을 하거나 버그 수정을 위한 코드 수정이 이뤄지는 브랜치로 이해하면 된다. 이 브랜치에서는 개발자 혼자 작업을 할 수 있도 있고, 특정 기능 개발을 위한 여러명의 개발자들이 공동으로 작업할 수도 있다.</p>

<p>feature 브랜치에서 작업이 완료되면 <code class="language-plaintext highlighter-rouge">풀 리퀘스트</code>를 요청하여 develop 브랜치에 <code class="language-plaintext highlighter-rouge">병합(merge)</code>하게 된다.</p>

<blockquote>
  <p>여기서 주의해야할 점은 feature 브랜치를 생성한 목적이 완료될 때까지 유지해야하고 다 완성되면 develop 브랜치에 병합해야 한다. 그리고 feature 브랜치는 보통 개발자 저장소에만 있는 브랜치이고 리모트 저장소에는 push하지 않는다.</p>
</blockquote>

<p><br /></p>

<h2 id="release-브랜치">release 브랜치</h2>
<ul>
  <li>생성되어지는 브랜치 : develop</li>
  <li>merge 해야되는 브랜치 : develop, master</li>
</ul>

<p>git으로 관리되는 소프트웨어는 정기적으로 성능개선, 기능추가, 버그를 수정 및 반영하면서 릴리즈된다. release 브랜치는 릴리즈를 하기 위한 목적으로 생성되는 브랜치이다.
release 브랜치는 develop 브랜치에서 생성된다.</p>

<p>간단한 순서는 아래와 같다.</p>

<ul>
  <li>develop 브랜치에 이전 버전에 포함되는 기능이 merge 되어있다면 QA를 위해 develop 브랜치에서부터 release 브랜치를 생성한다.</li>
  <li>배포를 위한 최종적인 버그 수정 등의 개발을 수행한다.</li>
  <li>배포 가능한 상태가 되면 master 브랜치로 병합한다. 출시된 master 브랜치에는 버전 태크를 추가한다.</li>
  <li>release 브랜치에서 기능을 점검하며 발견한 버그 수정 사항은 develop 브랜치에도 적용해야 한다. 따라서 배포 완료 후 develop 브랜치에도 merge를 해야한다.</li>
</ul>

<p><br /></p>

<h2 id="hotfix-브랜치">hotfix 브랜치</h2>
<ul>
  <li>생성되어지는 브랜치 : master</li>
  <li>merge 해야되는 브랜치 : develop, master</li>
</ul>

<p>hotfix 브랜치는 배포한 버전에서 긴급하게 수정이 필요한 경우 master 브랜치에서 분기하는 브랜치이다.
다음 릴리즈를 기다릴 수 없을 정도로 긴급한 패치가 바로 반영되어야 하는 경우 이 hotfix 브랜치를 사용한다.</p>

<p>정리해서,</p>

<ul>
  <li>hotfix 브랜치는 master 브랜치에서 생성된다.</li>
  <li>hotfix 브랜치에는 긴급한 패치들이 반영된다.</li>
  <li>이후 hotfix 브랜치는 master 브랜치에 병합되고 태그를 추가한다.</li>
  <li>마찬가지로 develop 브랜치로도 병합되어 긴급 수정 사항이 이후 릴리즈에도 반영되도록 해야한다.</li>
</ul>

<p><br /></p>

<h2 id="git-flow-설명">git-flow 설명</h2>

<p><img src="/assets/images/banners/git-flow.png" alt="" /></p>

<ol>
  <li>가장 먼저 master 브랜치에서 시작한다.</li>
  <li>master 브랜치와 동일하게 develop 브랜치를 생성해준다. 그리고 개발자들은 develop 브랜치에서 개발을 진행한다.</li>
  <li>개발을 진행하다가 <code class="language-plaintext highlighter-rouge">1.회원가입</code>, <code class="language-plaintext highlighter-rouge">2.장바구니</code>, <code class="language-plaintext highlighter-rouge">3.오류수정</code> 등의 기능 구현 및 버그 수정이 필요한 경우
    <ul>
      <li>A 개발자는 develop 브랜치에서 feature 브랜치를 하나 생성해서 <code class="language-plaintext highlighter-rouge">1.회원가입 기능</code>을 구현한다.</li>
      <li>B 개발자는 develop 브랜치에서 feature 브랜치를 하나 생성해서 <code class="language-plaintext highlighter-rouge">2.장바구니 기능</code>을 구현한다.</li>
      <li>C 개발자는 develop 브랜치에서 feature 브랜치를 하나 생성해서 <code class="language-plaintext highlighter-rouge">3.오류수정</code>을 구현한다.</li>
    </ul>
  </li>
  <li>완료성된 feature 브랜치들은 develop 브랜치에 <code class="language-plaintext highlighter-rouge">풀 리퀘스트</code> 요청을 하고 검토가 완료되어 이상이 없으면 <code class="language-plaintext highlighter-rouge">merge</code>한다.</li>
  <li>모든 기능이 완료되면 develop 브랜치에서 release 브랜치를 생성한다.. 그리고 QA(품질검사)를 진행하다가 보완점을 보완하고 버그를 수정한다.</li>
  <li>모든 것이 완료되면 release 브랜치를 master 브랜치와 develop 브랜치로 <code class="language-plaintext highlighter-rouge">merge</code>한다. master 브랜치에서 버전추가를 위해 태그를 생성하고 배포한다.</li>
  <li>배포를 완료했는데 미처 발견하지 못한 버그가 있는 경우 hotfix 브랜치를 master 브랜치로부터 생성하여 긴급 수정 후 태그를 생성하고 바로 수정 배포를 진행한다.</li>
</ol>]]></content><author><name>GitHub User</name></author><category term="Git" /><category term="Node.js" /><category term="Javascript" /><summary type="html"><![CDATA[git-flow 전략]]></summary></entry><entry><title type="html">[블록체인] dApp - Xumm 시작하기</title><link href="http://localhost:4000/blockchain/2022/06/19/blockchain-04.html" rel="alternate" type="text/html" title="[블록체인] dApp - Xumm 시작하기" /><published>2022-06-19T00:00:00+09:00</published><updated>2022-06-19T00:00:00+09:00</updated><id>http://localhost:4000/blockchain/2022/06/19/blockchain-04</id><content type="html" xml:base="http://localhost:4000/blockchain/2022/06/19/blockchain-04.html"><![CDATA[<h2 id="xumm-컨셉">Xumm 컨셉</h2>

<p>리플이 제공하는 <code class="language-plaintext highlighter-rouge">XRPL Labs</code>는 사용자가 2019 년 7 월 지갑 계정에 암호 화폐 및 화폐 통화 [예 : 유로 및 미국 달러]로 저장할 수있는 <code class="language-plaintext highlighter-rouge">Xumm</code>을 출시했다. XRPL Labs의 수석 개발자 Wietse Wind에 따르면이 배포의 주요 목표는 기존 금융 기관의 개입없이 은행 애플리케이션과 유사한 애플리케이션을 구축하는 것이다.</p>

<p>간단하게 말하면, 리플의 <code class="language-plaintext highlighter-rouge">XRP 원장</code> 계정을 생성하고 기존 계정을 가져올 수 있도록 도와주는 지갑이다.</p>

<blockquote>
  <p>Xumm 용어</p>
  <ul>
    <li>xumm:
xumm은 iOS 또는 Android 기기 전용 xumm 앱 을 의미한다.</li>
    <li>xumm platform: 
xumm 플랫폼을 언급할 때 개발자가 xumm 앱을 통해 최종 사용자에게 서명 요청을 전달하기 위한 API를 의미한다다.</li>
    <li>xumm API: 
xumm API는 xumm 플랫폼 과 관련된 xumm API를 의미합니다 .</li>
    <li>application: 
애플리케이션을 언급할 때 xumm앱 이 아니라 개발자 소유의 애플리케이션을 의미합니다.</li>
  </ul>
</blockquote>

<p><br /></p>

<p>XRP 거래는 일반적으로 사용자가 시작한다. 지갑을 열고 대상이나 금액 등을 입력한 다음 거래를 제출한다. 소매/전자 상거래(및 기타 많은) 시나리오에서 이 프로세스를 “reversing”하면 결제 흐름이 실수를 덜 범하고 훨씬 더 사용자 친화적이 된다.
여기서 Xumm 플랫폼이 등장한다. XRPL 트랜잭션 템플릿은 <code class="language-plaintext highlighter-rouge">Xumm API</code>에 게시될 수 있다. 서명 오청(=<code class="language-plaintext highlighter-rouge">payload</code>)은 저장되므로 xumm 앱 사용자는 서명 요청을 열고(QR, 딥링크 또는 푸시알람을 스캔하여) 자신의 장치에서 해결할 수 있다(거부/서명).</p>

<p>사용자가 서명 요청에 서명하면 애플리케이션을 신뢰할 수 있다. 이 경우 애플리케이션에 대한 애플리케이션별 사용자 토큰이 생성되고 향후 <code class="language-plaintext highlighter-rouge">payload</code>는 푸시알람과 함께 최종 사용자에게 직접 전달된다.</p>

<p>xumm 플랫폼은 XRP 원장에서 서명된 트랜잭션을 확인하는 데 필요한 모든 정보와 함께 다양한 상태 업데이트 옵션을 제공하므로 xumm 앱의 트랜잭션 콜백 정보 또는 트랜잭션 제출에 의존할 필요가 없다.</p>

<p><br /></p>

<h2 id="앱-등록">앱 등록</h2>

<p>개발자가 Xumm Api를 호출하기 위해서는 Api key를 얻어 등록해야만 한다. <a href="https://apps.xumm.dev/">xumm 개발자 대시보드</a>에 방문하여 등록하여 로그인한다.</p>

<p><img src="/assets/images/banners/xumm_app_register.png" alt="" /></p>

<p>xumm API 에 대한 모든 호출 에는 최소한 다음 세 개의 HTTP 헤더가 포함되어야 한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Header(key)</th>
      <th style="text-align: left">value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Content-Type</td>
      <td style="text-align: left">application/json</td>
    </tr>
    <tr>
      <td style="text-align: left">X-API-Key</td>
      <td style="text-align: left">[xumm 개발자 대시보드](https://xumm.readme.io/docs/register-your-app)에서 가져옴</td>
    </tr>
    <tr>
      <td style="text-align: left">X-API-Secret</td>
      <td style="text-align: left">[xumm 개발자 대시보드](https://xumm.readme.io/docs/register-your-app)에서 가져옴</td>
    </tr>
  </tbody>
</table>

<p>자, 앱등록이 완료되면 모든 준비는 완료되었다. xumm api를 직접 호출하여 사용할 수 있다.</p>

<p><br /></p>

<h2 id="서명요청payload">서명요청(Payload)</h2>

<p>일반적으로 페이로드 워크플로는 애플리케이션에서 시작된다<code class="language-plaintext highlighter-rouge">(사용자가 무언가를 서명하기를 원한다)</code>. 사용자가 애플리케이션에 지불하는 행위, 에스크로 설정, 다중 서명 설정, 신뢰 라인 생성 등과 같은 다른 유형의 XRPL 트랜잭션일 수도 있다.</p>

<h3 id="페이로드payload-vs-서명요청sign-request-vs-트랙잭션-템플릿transaction-template">페이로드(payload) vs. 서명요청(sign request) vs. 트랙잭션 템플릿(transaction template)</h3>
<p>최종 사용자가 트랜잭션(서명 요청)에 서명하도록 하려면 트랙잭션 템플릿(XRPL 트랜잭션 사양에 따라 형식이 지정된 JSON 형식)을 작성하고 트랜잭션 템플릿을 xumm 플랫폼(api)에 게시하여 페이로드를 생성해야한다. 그리고 xumm 앱 사용자가 거부 또는 서명하게 된다.</p>

<p>개발자의 애플리케이션은 XRPL 트랜잭션 템플릿을 만든다. 일반적인 <code class="language-plaintext highlighter-rouge">XRPL JSON 트랜잭션</code>과 <code class="language-plaintext highlighter-rouge">xumm 트랜잭션 템플릿</code>의 차이점은 최종 사용자 기기의 xumm 앱이 자동으로 채우기 때문에 일부 필드를 생략하거나 공백으로 둘 수 있다는 점이다.
그리고, 개발자의 애플리케이션 백엔드는 트랜잭션 템플릿을 Xumm API로 보낸다. 그럼 개발자의 애플리케이션은 유니크한 페이로드 아이디<code class="language-plaintext highlighter-rouge">(payload ID)</code>를 전달받는다.</p>

<p><br /></p>

<h3 id="testnetdevnetmainnet에-대한-참고-사항">Testnet/Devnet/Mainnet에 대한 참고 사항</h3>

<p><code class="language-plaintext highlighter-rouge">Testnet/Devnet</code>과 상호 작용하려면 <code class="language-plaintext highlighter-rouge">Testnet/Devnet</code>에 연결된 <code class="language-plaintext highlighter-rouge">xumm</code> 앱으로 요청에 서명하기만 하면 된다. <code class="language-plaintext highlighter-rouge">XUMM 플랫폼</code>은 단순히 최종 사용자와 외부 응용 프로그램 간의 <code class="language-plaintext highlighter-rouge">"상호작용 채널"</code>이기 때문에 사용된 네트워크는 API와 관련이 없다. 서명이 선행될 때 사용자가 연결되는 네트워크이다.</p>

<h3 id="데스크탑-클라이언트">데스크탑 클라이언트</h3>
<p>애플리케이션에서 QR 코드를 생성하거나 사전 생성된 QR 코드 중 하나를 사용할 수 있다. xumm 앱 최종 사용자는 QR 코드를 스캔하고 거래 템플릿을 검토하고 거래에 서명할 수 있다. 또한 최종 사용자를 페이로드 URL로 리디렉션할 수 있다.</p>

<h3 id="디바이스-클라이언트">디바이스 클라이언트</h3>
<p>디바이스에서 이 프로세스가 발생 하면 사용자를 페이로드 URL로 리디렉션할 때 xumm 앱이 자동으로 열린다.</p>

<p>페이로드를 생성할 떄 애플리케이션이 게시한 페이로드 옵션에 따라서 xumm 앱은 서명된 트랜잭션을 XRPL에 직접 제출하거나 서명된 트랜잭션 HEX를 애플리케이션에 다시 게시한다.(그래서 애플리케이션은 서명된 트랜잭션을 제출하거나 유지할 수 있다.)</p>

<p>최종 사용자가 페이로드를 거부 및 서명하여 해겷하면 애플리케이션 백엔드는 HTTP POST 웹훅을 수신한다. 또한, 페이로드별 웹 소켓을 구독하여 실시간 상태 업데이트를 받거나 xumm API를 호출하여 페이로드 상태를 얻을 수 있다.</p>

<h3 id="xumm-서명요청-flowinitially-non-push">xumm 서명요청 flow(initially, non-push)</h3>

<p><img src="/assets/images/banners/xumm-non-push.png" alt="" /></p>

<h3 id="xumm-서명요청-flowwith-user-token-push">xumm 서명요청 flow(with User Token, push)</h3>

<p><img src="/assets/images/banners/xumm-push.png" alt="" /></p>

<h2 id="참조">참조</h2>

<ul>
  <li>https://xumm.readme.io/docs/payload-workflow</li>
</ul>]]></content><author><name>GitHub User</name></author><category term="BlockChain" /><category term="BlockChain" /><summary type="html"><![CDATA[Xumm 컨셉]]></summary></entry><entry><title type="html">[블록체인] 기본 개념 - 유동성 풀이란?</title><link href="http://localhost:4000/blockchain/2022/06/13/blockchain-03.html" rel="alternate" type="text/html" title="[블록체인] 기본 개념 - 유동성 풀이란?" /><published>2022-06-13T00:00:00+09:00</published><updated>2022-06-13T00:00:00+09:00</updated><id>http://localhost:4000/blockchain/2022/06/13/blockchain-03</id><content type="html" xml:base="http://localhost:4000/blockchain/2022/06/13/blockchain-03.html"><![CDATA[<h2 id="유동성-풀이란">유동성 풀이란?</h2>

<p>유동성 풀이란 스마트 콘트랙트 내에 통결되어 있는 자금(디지털 자산)들을 말한다. 유동성 풀은 탈중앙화된 트레이딩, 대출 등 앞으로 다양한 기능을 지원하기 위해 사용된다.</p>

<p>유동성 풀 <code class="language-plaintext highlighter-rouge">유니스왑</code>과 같은 많은 탈중화 거래소(DEX)의 핵심이다. 유동성 제공자(LP)라 하는 이들은 풀에 동일한 가치를 갖는 두 가지 토큰을 추가하고 시장을 생성한다. 자신의 자금을 제공하는 대가로, 사용자는 자신의 풀에서 발생하는 거래 수수료를 전체 유동성 내 자신의 지분에 따라 분배받는다.</p>

<p>LP는 유동성 공급에 필요한 토큰을 보유한 자라면 누구나 될 수 있으며 AMM(자동화된 마켓 메이킹)을 통해 유동성 풀의 변화에 따라 토큰의 교환비율이 결정된다. 이더리움 상에서 유동성 풀을 사용하는 대표적인 거래소는 스시스왑, 커브 등이 있으며 이 거래소 내 유동성 풀은 ERC-20 토큰을 지원한다.</p>

<p><br /></p>

<h2 id="유동성-풀은-어디에-사용되는가">유동성 풀은 어디에 사용되는가?</h2>

<p>유동성 풀에 유동성을 공급하는 것은 간단하며 누구나 참여할 수 있기 때문에 다양한 방법으로 활용할 수 있다. 우선 유동성 풀은 토큰이 알고리즘에 따라 유동성 풀에 제공하는 사용자에게 분배할 수 있다는 원리를 이용해 사용자가 풀에 자금을 추가하고 이자를 받을 수 있는 이자 창출 플랫폼으로 사용할 수 있다. 이를 <code class="language-plaintext highlighter-rouge">유동성 마이닝(liquidity Mining)</code> 또는 <code class="language-plaintext highlighter-rouge">이자 농사(yield Farming)</code>라고 말하기도 한다.</p>

<p>그리고 유동성 공급자에게 제한된 <code class="language-plaintext highlighter-rouge">리스크</code>와 <code class="language-plaintext highlighter-rouge">수익</code>을 선택할 수 있게 함으로써 스마트 컨트랙트의 리스크를 보완할 수 있는 기반을 제공한다. 또한, 블록체인 상에서 합성 자산을 만드는 것도 가능하게 할 수 있는 기반으로 활용할 수 있다.</p>

<p>암호화폐 프로젝트에서 적합한 사람들에게 새 토큰을 배포하는 것은 무척 어려운 문제이다. <code class="language-plaintext highlighter-rouge">유동성 마이닝</code>은 보다 성공적인 접근 방법 중 하나 였다. 토큰은 기본적으로 알고리즘을 따라 자신의 토큰을 유동성 풀에 제공하는 사용자에게 분배된다. 이후 새롭게 생성된 토큰이 각 사용자의 풀 지분에 따라 분배된다.</p>

<p>이는 <code class="language-plaintext highlighter-rouge">풀 토큰</code>이라 하는 다른 유동성 풀의 토큰일 수도 있다는 점을 유의해야 한다. 예를 들어, 유니스왑에 유동성을 제공하거나, 컴파운드에 자검을 대출해주는 경우, 풀 내 지분을 나타내는 토큰을 받게 된다. 이를 다른 풀에 예치하고, 수익을 얻을 수도 있다. 여러 프로토콜이 다른 프로토콜의 풀 토큰을 자신의 상품 등에 통합하기 때문에 이러한 연결은 꽤나 복잡해질 수 있다.</p>

<p><br /></p>

<h2 id="유동성-풀은-어떻게-작동하는가">유동성 풀은 어떻게 작동하는가?</h2>
<p>먼저, 가장 유명한 <code class="language-plaintext highlighter-rouge">유니스왑</code>을 예로 들어보자.</p>

<h3 id="유니스왑이란">유니스왑이란?</h3>
<p>유니스왑은 이더리움과 <code class="language-plaintext highlighter-rouge">ERC-20</code> 토큰 간의 자동 교환 거래를 용이하게 하도록 설계된 탈중앙화 거래소(DEX)이다. 온-체인에서 탈중심화 지갑만 설치하면 유니스왑을 이용할 수 있다. 유니스왑에 대해 알아보기 전 먼저 탈중앙화 거래소에 대해 알아야 할 필요가 있다.</p>

<p>우리가 흔히 알고 있는 <code class="language-plaintext highlighter-rouge">업비트</code>, <code class="language-plaintext highlighter-rouge">빗썸</code>, <code class="language-plaintext highlighter-rouge">코인원</code>, <code class="language-plaintext highlighter-rouge">코인빗</code> 등은 중앙화된 주체가 거래를 중개하는 거래소이다. 이런 중앙집권 거래소는 사용자의 디지털자산을 거래소가 수탁하고 사용자는 거래소가 제공하는 장부 위에서 거래를 하는 구조로 이루어져 있다. 하지만 중앙화된 주체가 거래의 신뢰를 보장하는 구조는 <code class="language-plaintext highlighter-rouge">거래과정에서 제3자가 개입할 필요 없다</code>는 무허가성(permissionless)이라는 블록체인의 특성에 반하는 것이기에 블록체인 커뮤니티에서는 중앙화되어 있지 않는 형태, 일명 탈중앙화 거래소를 만들기 위해 노력했다. 그 결과 2017년경 이더델타 등 탈중앙화 거래소(DEX, Decentralized Exchanage) 프로젝트가 탄생했다. 탈중앙화 거래소는 <code class="language-plaintext highlighter-rouge">비영리 목적</code>이기 때문에 수수료가 거의 없고 별도의 인증 절차 없이 토큰 간 거래를 할 수 있다.</p>

<p>초기 탈중앙화 거래소는 과도한 가스비를 초래하고, 확장의 한계성, 부족한 유동성 등의 문제가 있어 큰 관심을 받지 못했다. <code class="language-plaintext highlighter-rouge">유니스왑</code>은 이러한 한계성을 보완하여 출시하였는데 특히 AMM(유동화된 마켓 메이커) 알고리즘 기반으로 <code class="language-plaintext highlighter-rouge">유동성 풀</code>(pool, 스마트 컨트랙트 내에 동결되어 있는 자금)을 제공하여 낮은 유동성이라는 한계점을 보완하였다.</p>

<p>유니스왑은 유동성을 공급하는 자들에게 별도의 보상을 지급하는 방식으로 유동성 공급 문제를 해결했다. 유니스왑은 유동성 마이닝이라는 시스템으로 성립되어 있어 토큰을 특정 풀에 맡기면 전용 거버넌스 토큰인 UNI를 보상으로 받을 수 있다. UNI는 일종의 거버넌스 토큰(Governance Token)으로서 가격이 결정되어 있으며 디지털자산 거래소에서 간편하게 교환할 수 있다. 또한, 유니스왑은 중앙관리자가 없어 디지털자산의 상장 이라는 개념이 존재하지 않는다. 이에 누구나 유니스왑에 ERC-20 토큰의 유동성을 공급하여 해당 토큰의 교환을 용이하게 만들 수 있다.</p>

<h3 id="유니스왑에-투자하는-방법">유니스왑에 투자하는 방법</h3>
<p>1) 디지털자산 지갑을 먼저 생성합니다. 이후 메타마스크 등의 지갑에 유니스왑을 연결한다.
2) 유니스왑은 이더리움 기반 디지털자산에만 적용되기 때문에 이더(ETH)를 구매한다.
3) 지갑이 설정되면 https://uniswap.org 으로 이동하여 ‘Launch App’을 클릭한다. 인터페이스를 통해 유니스왑을 지갑에 연결할 수 있습니다.
4) 지갑에 있는 이더(ETH)를 원하는 ERC-20 토큰과 교환합니다. ERC-20을 교환하면 유동성 풀로 이더를 보내는 것과 동시에 교환한 ERC-20 토큰을 풀에서 인출하게 됩니다.
5) 토큰 교환 전에 슬리피지 수치를 주의해야 합니다. 슬리피지는 유동성 풀에서 사용 가능한 양 대비 토큰의 비율입니다. 풀 크기에 비해 대량 주문이 있는 거래는 높은 %의 슬리피지로 거래를 중단됩니다. 
6) 모든 세부 정보를 확인한 후 스왑을 확인하면 지갑에 팝업이 표시되며 트랜잭션은 https://etherscan.io/ 에서 확인할 수 있습니다. 트랜잭션이 검증되어 블록체인에 기록되는 과정에서 일부 시간이 소요될 수 있습니다.</p>

<h3 id="유니스왑-투자-리스크">유니스왑 투자 리스크</h3>
<p>유니스왑은 제3자의 개입 없이 지갑에서 직접 거래할 수 있고 새 토큰을 쉽고 빠르게 접근할 수 있다. 또한, 거래수수료가 0.3%으로 중앙집권 거래소(업비트, 빗썸, 코인원 등) 대비 저렴하다. 하지만 유니스왑에도 다양한 리스크가 존재한다.</p>

<p>첫 번째는, 유니스왑에서 해킹이 발생할 확률이 <code class="language-plaintext highlighter-rouge">제로(0)</code>가 아니라는 것이다. 해킹 리스크가 빈번하게 일어나는 것은 아니지만, 스마트 컨트랙트가 문제를 일으키면 해킹당할 위험이 높아진다. 실제로 2022년 4월 유니스왑 대출 플랫폼 Lendf.ME에서 해킹으로 2500만 달러 이상의 디지털자산이 도난당한 사건이 발생했다. 스마트 컨트랙트는 완전하지 않으므로 설계의 취약점이 발견될 경우 의도치 않는 공격을 받을 수 있다. 이로 인해 디지털자산이 탈취당하는 경우에는 별도의 보호를 받을 수 없게 된다.</p>

<p>또한, 거버넌스 토큰 UNI의의 가격 변동성 리스크도 존재한다. 유동성이 큰 UNI는 일반 통화보다 토큰 페어 가격 변동 위험이 높다. 따라서 토큰 페어(pair)의 가격 변동이 높을 경우 소위 비영구적인 손실이 발생할 수도 있따. 또한 표시된 APY(연간 이자율)는 매번 변경되므로 일정 이자율을 유지한다는 보장 또한 없다.</p>

<h3 id="유니스왑-작동원리">유니스왑 작동원리</h3>
<p><code class="language-plaintext highlighter-rouge">이더리움</code>과 <code class="language-plaintext highlighter-rouge">ERC-20</code> 토큰 간의 자동 교환 거래를 용이하게 하도록 설계된 탈중화 <code class="language-plaintext highlighter-rouge">거래소(DEX)</code>인 유니스왑에서는 디지털자산 간의 <code class="language-plaintext highlighter-rouge">교환(swap)</code> 기능을 구현하기 위하여 중앙화권 거래소가 사용하는 오더북 방식이 아닌 <code class="language-plaintext highlighter-rouge">AMM</code> 방식을 선택했다.</p>

<p><code class="language-plaintext highlighter-rouge">AMM(Automated Market Making)</code>이란 자동화된 마켓 메이킹으로, 개인들이 토큰을 교환할 때 수학공식에 의해 자산의 가격이 자동으로 결정되도록 하는 알고리즘입니다. 중앙화된 거래소에서는 매수희망자와 매도희망자가 존재하여 각자 제출한 호가가 일치하였을 때 거래가 성립되고, 거래소는 해당 거래를 중개하는 역할을 수행합니다. 반면, AMM 방식의 DEX에서는 이용자들이 <code class="language-plaintext highlighter-rouge">유동성 풀(Liquidity Pool)</code>이라는 것을 공급하고, 디지털자산의 교환을 원하는 자는 해당 풀에서 가상자산을 교환하는 방식으로 교환이 이루어집니다. 거래의 상대방이 명확히 존재하지 않으며 이때 교환비율이나 디지털자산의 가치는 수학적인 알고리즘에 의하여 형성됩니다.</p>

<p>유니스왑은 AMM의 한 종류인 CPMM(Constant Product Market Maker)을 사용한다.</p>

<blockquote>
  <p>K = X*Y</p>
  <blockquote>
    <p>K= 상수</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>X= 거래계약 안에 있는 토큰 X의 수량</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>Y= 거래계약 안에 있는 토큰 Y의 수량</p>
  </blockquote>
</blockquote>

<p>이 함수는 변수 X와 Y의 곱에 있어서 상수 K 값이 <code class="language-plaintext highlighter-rouge">유지</code>되어야 한다. 이는 전체 유동성이 일정하다는 의미로 해석할 수 있따. X와 Y 값은 각각 유동성 풀에 존재하는 토큰 가치의 비중을 나타내며 두 비중의 곱에 의해 풀의 유동성이 결정되고 이를 K 값으로 나타낸다.</p>

<p>예시로 유니스왑의 거래를 설명해보자면,</p>

<p>유동성 풀에 다음과 같이 토큰이 존재한다고 가정하자.</p>
<ol>
  <li>이더리움(X) 10개</li>
  <li>ERC-20(Y) 토큰 200개</li>
  <li>이 둘의 곱은 2000(K)</li>
  <li>1 ETH = 18.18 ERC-20</li>
</ol>

<p>이에 모든 교환에 있어 두 디지털자산의 곱은 2000을 유지해야 한다. 이러한 상황에서 ERC-20 토큰을 구매하기 위해 1 ETH를 보내면 컨트랙트의 이더리움 수량이 10개에서 1개가 더 추가되어 11개로 변한다. K는 2000으로 일정해야 하므로 <code class="language-plaintext highlighter-rouge">181.82(2000/11)</code>로 변한다. 다시 말해 1 ETH를 주고받는 ERC-20 토큰의 양은 <code class="language-plaintext highlighter-rouge">18.18(200-181.82)</code>인 것이다.</p>

<ol>
  <li>이더리움(X) 10개 + 1개 = 11개</li>
  <li>ERC-20(Y) 토큰 2000/11 = 181.82개</li>
  <li>이 둘의 곱은 2000(K)</li>
  <li>1 ETH = 33.33 ERC-20</li>
</ol>

<p>이다음 상황에서 누군가 1 ETH를 넣는다면 컨트랙트 상의 이더리움은 12개가 된다. ERC-20 토큰의 양은 <code class="language-plaintext highlighter-rouge">166.67(2000/12)</code>개가 된다. 즉 하나의 ETH를 더 넣으면 1 ETH를 주고받는 ERC-20 토큰의 양은 <code class="language-plaintext highlighter-rouge">33.33(200-166.67)</code>이다. 이는 ERC-20 토큰의 구매 가격(가치)이 높아진 것으로 볼 수 있다.</p>

<p>이때 ERC-20을 비싸게 팔고 이더리움을 저렴하게 매수하려는 차익거래자가 발생됩니다. 이러한 차익거래자 때문에 이더리움/ERC-20 비율이 효율적인 선까지 맞춰집니다. 즉, 유니스왑은 <code class="language-plaintext highlighter-rouge">CPMM(X*Y=K)</code>을 통해 ETH와 ERC-20 토큰의 비율을 중앙집권 거래소 가격과 수렴할 수 있게 한 것입니다.</p>

<p><br /></p>

<p>유동성 풀을 작동원리를 정리하자면</p>

<p><img src="/assets/images/banners/pool.jpg" alt="" /></p>

<p>풀 안에 A, B 두 코인이 있고 공급자는 반드시 A코인 50%와 B코인 50%를 예치해야 한다. 이 예치금은 거래소가 사용한다.
본질적으로 유동성 공급자는 거래 수수료를 얻고자 암호화폐 토큰을 탈중화 거래소(DEX)에 예치하는 트레이더다. 이것은 유동성 채굴 혹은 시장 조성이라고 불리기도 한다.</p>

<p>거래 수수료는 보통 이자율로 표시된다. 이자율은 얼마나 유동성이 공급되는지 그리고 얼마나 많은 거래가 유동성 풀 안에서 발생하는지에 따라 천차만별이다.</p>

<p><br /></p>

<h2 id="참조">참조</h2>
<ul>
  <li><a href="https://m.upbitcare.com/academy/education/blockchain/49">업비트</a></li>
  <li><a href="https://academy.binance.com/ko/articles/what-are-liquidity-pools-in-defi">바이낸스</a></li>
</ul>]]></content><author><name>GitHub User</name></author><category term="BlockChain" /><category term="BlockChain" /><summary type="html"><![CDATA[유동성 풀이란?]]></summary></entry><entry><title type="html">[블록체인] 기본 개념 - 스마트 컨트랙트</title><link href="http://localhost:4000/blockchain/2022/06/07/blockchain-02.html" rel="alternate" type="text/html" title="[블록체인] 기본 개념 - 스마트 컨트랙트" /><published>2022-06-07T00:00:00+09:00</published><updated>2022-06-07T00:00:00+09:00</updated><id>http://localhost:4000/blockchain/2022/06/07/blockchain-02</id><content type="html" xml:base="http://localhost:4000/blockchain/2022/06/07/blockchain-02.html"><![CDATA[<h2 id="스마트-컨트랙트란">스마트 컨트랙트란?</h2>

<p><code class="language-plaintext highlighter-rouge">스마트 컨트랙트(smart contract)</code>란 블록체인 기술을 활용해 제3의 인증기관 없이 개인 간 계약이 이루어질 수 있도록 하는 기술을 말한다. 서면으로 이루어지던 계약을 코드로 구현하고 해당 계약을 이행하는 과정에서 조건 충족 여부에 대한 판단을 인간이 아닌 컴퓨터 등의 기계가 대신 실행함으로써 제3의 인증기관이 필요 없도록 하는 개념을 의미한다.</p>

<p>스마트 컨트랙트를 활용하면 두 당사자가 서로를 모르거나 신뢰하지 않더라도 계약을 체결할 수 있다. 그 이유는 특정 조건이 충족되지 않으면 해당 계약은 실행되지 않기 때문이다.
그렇기 때문에, 제3의 인증기관 없이도 계약을 이행할 수 있는 것이 스마트 컨트랙트의 특징이다.</p>

<p><img src="https://user-images.githubusercontent.com/52439201/172295968-14dfcaac-ebf8-45a2-812b-b962fb5d413a.png" alt="image" /></p>

<p><br /></p>

<h2 id="스마트-컨트랙트-특징">스마트 컨트랙트 특징</h2>

<p><code class="language-plaintext highlighter-rouge">스마트 컨트랙트(smart contract)</code>의 개념을 최초로 제시한 닉 재보는 스마트 컨트랙트를 계약 코드를 통해 스스로 실행되는 전산화 계약이라고 정의했다.<br />
스마트 컨트랙트의 기본적인 특징은 아래와 같다.</p>

<h3 id="관측가능성">관측가능성</h3>
<p>스마트 계약은 서로의 계약 이행 가능성을 관찰하거나 성과를 입증할 수 있어야 한다.</p>

<h3 id="검증-가능성">검증 가능성</h3>
<p>계약을 이행 또는 위반할 경우 계약 당사자들이 이를 알 수 있어야 한다.</p>

<h3 id="프라이버시">프라이버시</h3>
<p>계약 내용은 계약에 필요한 당사자들만이 알 수 있어야 한다.</p>

<h3 id="강제-가능성">강제 가능성</h3>
<p>계약이 이뤄질 수 있도록 구속력이 있어야 한다.</p>

<p><br /></p>

<p>정리하면, 스마트 컨트랙트는 투명한 거래 내역이 공개되어야 한다. 실제로 Etherscan이나 Decentralized Metadata and Source Code Repository를 통해 이더리움 메인넷과 테스트넷에 배포된 모든 컨트랙트를 누구든지 조회할 수 있다.
또한, 스마트 컨트랙트는 블록체인 상에 trustless한 네트워크를 구축하는데 효과적이다. 영철이가 미영이에게 매달 일정한 금액을 전송한다고 했을 때 은행이나 신뢰할 수 있는 기관에 의존하지 않고서 해당 계약을 이행할 수 있게 된다.</p>

<p><br /></p>

<h2 id="스마트-컨트랙트-작동-원리">스마트 컨트랙트 작동 원리</h2>

<p><code class="language-plaintext highlighter-rouge">스마트 컨트랙트</code>는 블록체인 상에서 전자 계약서로 이루어지며, 계약 당사자들끼리 합의한 내용 및 조건이 충족되면 자동으로 실행되도록 설계되어 있다.<br />
계약 내용을 스마트 컨트랙트 소스 코드로 작성하여 블록체인 네트워크에 전송하면 네트워크 참여자(노드)들이 유효성 검증이 이뤄지며 검증이 완료되면 해당 스마트 컨트랙트가 포함된 블록이 생성되며 배포된다.</p>

<p>이후 블록체인은 스마트 컨트랙트가 담긴 블록의 변경 상태를 지속적으로 확인한다. 조건에 따른 변경시 명령 실행 비용을 계산하고 상태변경 트랜잭션을 생성한다.</p>

<h3 id="예시">예시</h3>

<ol>
  <li>부동산을 매도하고자 하는 사람이 부동산 매매 계약의 내용이 담긴 스마트 컨트랙트를 만들어 블록체인에 전송하면 블록이 생성되어 배포된다.</li>
  <li>블록체인 내 노드들은 이 스마트 컨트랙트를 검토하여 블록을 만드는데 합의하고 스마트 컨트랙트가 담긴 블록을 자신의 블록체인 맨 끝에 추가한다.</li>
  <li>이후 변경 사항들을 끊임없이 다른 블록들과 교류하면서 오류가 없는지 혹은 조건에 충족되어 추가 계약 사항이 진행되는지 체크한다.</li>
  <li>부동산 매수인은 블록체인 상에서 공개되어 있는 스마트 컨트랙트의 내용을 직접 확인한 후, 스마트 컨트랙트를 실행하기 위해 서명을 하게 된다.</li>
  <li>이후 부동산 매수자가 스마트 컨트랙트에 담긴 내용에 따라 부동산 매매 대가에 해당하는 디지털자산을 매도인에게 이전하게 되면 등록된 부동산의 소유권이 매수자에게 자동으로 이전된다.</li>
  <li>이때 블록체인 상에서의 스마트 컨트랙트는 대부분 오픈 소스(open source), 즉 누구나 확인할 수 있기 때문에 그 내용을 임의로 변경하거나 조작할 수 없습니다. 또한 스마트 컨트랙트의 체결사실도 모두에게 공유됩니다.</li>
</ol>

<p><img src="/assets/images/banners/smartcontract.png" alt="" /></p>

<p><br /></p>

<h2 id="스마트-컨트랙트의-장점">스마트 컨트랙트의 장점</h2>

<p>스마트 컨트랙트의 장점은 크게 자율성, 신뢰, 비용절감, 안정성, 효율성 등으로 분류된다.</p>

<h3 id="자율성">자율성</h3>
<p>블록체인 내에서 진행되기 때문에 공신력을 가진 제 3자, 혹은 기관이 필요하지 않습니다. 이에 따라 거래 당사자들이 계약에 대한 온전한 권한, 통제성을 갖게 된다.</p>

<h3 id="비용-절감">비용 절감</h3>
<p>블록체인에서 관련 계약, 거래 내역 등을 보증할 수 있는 제3자나 공신력 있는 기관이 필요하지 않기 때문에 비용 절감의 효과를 가질 수 있다.</p>

<h3 id="신뢰성">신뢰성</h3>
<p>블록체인 내 스마트 컨트랙트에 의해 계약이 공정하게 진행되며 문서의 위변조가 극히 어려워 뛰어난 신뢰성을 가진다.</p>

<h3 id="보안성">보안성</h3>
<p>신뢰성과 연결된 것으로 문서가 암호화되어 블록체인 내 분산 원장 기술에 의해 안전하게 보관된다.</p>

<p><br /></p>

<h2 id="참조">참조</h2>
<ul>
  <li><a href="https://m.upbitcare.com/academy/education/blockchain/71">업비트</a></li>
</ul>]]></content><author><name>GitHub User</name></author><category term="BlockChain" /><category term="BlockChain" /><summary type="html"><![CDATA[스마트 컨트랙트란?]]></summary></entry><entry><title type="html">[블록체인] 기본 개념 - DApp이란?</title><link href="http://localhost:4000/blockchain/2022/06/06/blockchain-01.html" rel="alternate" type="text/html" title="[블록체인] 기본 개념 - DApp이란?" /><published>2022-06-06T00:00:00+09:00</published><updated>2022-06-06T00:00:00+09:00</updated><id>http://localhost:4000/blockchain/2022/06/06/blockchain-01</id><content type="html" xml:base="http://localhost:4000/blockchain/2022/06/06/blockchain-01.html"><![CDATA[<h2 id="dapp-정의">DApp 정의</h2>

<p><code class="language-plaintext highlighter-rouge">디앱(DApp)</code> 또는 <code class="language-plaintext highlighter-rouge">댑</code>이란 Decentralized Application의 약자로서, 이더리움, 큐텀, 이오스 같은 플랫폼 코인 위에서 작동하는 탈중앙화 분산 애플리케이션을 말한다. 간략히 분산앱이라고도 한다. 플랫폼 위에서 작동하는 디앱의 암호화폐는 코인(coin)이라고 하지 않고 토큰(token)이라고 구별하여 부르기도 한다. ‘Daap’가 아니라 ‘DApp’가 올바른 표기법이다. ‘Dapp’ 또는 ‘dApp’이라고도 쓴다. 단수형이 아니라 복수형으로 표현하여, 디앱스(DApps) 또는 댑스(dApps)라고도 한다.</p>

<h2 id="개요">개요</h2>

<p>디앱이란 블록체인을 기반으로 돌아가는 애플리케이션을 말한다. 쉽게 말해 이더리움 기반 디엡이라면 디앱에서 상호작용하는 데이터들이 이더리움 블록체인에 기록되고 불러내어지는 애플리케이션이라고 이해하면 된다.
현재, 이더리움, 이오스, 스팀 등에서 돌아가는 모든 디앱들을 합치면 약 3,000여 개가 존재한다.</p>

<p>애플 앱스토어에만 220만여 개가 넘는 앱이 존재하는데, 이와 비교하면 아주 초라한 숫자이기도 하다. 전체 디앱 중에서 게임, 거래소, 도박 등을 뺀 실생활과 밀접한 영역의 디앱들의 유저 수 비중은 40%도 안 된다.</p>

<p>디앱은 스마트폰 <code class="language-plaintext highlighter-rouge">블록체인</code>을 기반으로 한 운영체제에서 구동된다는 것이 차이점이다. 아이폰은 ISO 운영체제를 갤럭시에는 안드로이드 OS를 사용한다. <code class="language-plaintext highlighter-rouge">블록체인</code>은 이러한 OS라고 생각하면 된다. 어떤 블록체인을 기반으로 구동되는지에 따라 이더리움 디앱, 이오스 디앱 등으로 구분할 수 있는 것이다.</p>

<h2 id="등장배경">등장배경</h2>

<p>블록체인에서 디앱은 <code class="language-plaintext highlighter-rouge">스마트 계약</code>이 도입되면서 생겨났다. 스마트 계약이 없는 비트코인에는 디앱이 존재하지 않는다. 
이더리움 창시자인 비탈릭 부테린은 이더리움에 스마트 계약을 처음 도입했다. 이 후 이더리움은 최초의 메인넷으로 무수한 디앱들을 탄생시켰다.</p>

<h2 id="특징">특징</h2>

<p>디앱 개념은 아직 초기 단계에 있다. 디앱으로는 응용 프로그램이 다음 네 가지 특징을 나타내야 한다.</p>

<ul>
  <li>탈중앙화 구조 : 디앱은 OS 개발에 필요한 소스 코드가 누구에게나 공개돼 있다.</li>
  <li>뛰어난 개인정보 보호 : 데이터를 블록체인에 기록하기 때문에 저장에 있어 안전하다.</li>
  <li>오픈 소스 : 가장 중요한 속성은 이러한 앱이 모든 사람에게 핵심 소스 코드를 제공해야 한다는 것이다. 디앱의 핵심 특징은 자율성과 만장일치로 이루어져 있음으로 기본적으로 변경 사항은 모든 사용자 또는 대부분 사용자가 결정해야 한다. 또한, 코드는 모든 사용자가 체크 아웃 할 수 있어야 한다.</li>
  <li>분산형 자연 : 이름에서 알 수 있듯이 분산형 응용 프로그램은 분산된 블록체인 또는 모든 암호화 기술에 모든 것을 저장하여 중앙 권한의 위험으로부터 응용 프로그램을 저장하고 자치 특성을 강조한다.</li>
  <li>인센티브(Incentivization) : 앱이 분산형 블록체인을 기반으로 하므로 네트워크의 레코드 유효성 검사기에 암호화 토큰이나 가치가 있는 디지털 자산 형태로 보상/ 인센티브를 부여해야 한다.</li>
  <li>알고리즘 : 분산 앱은 암호화 시스템에서 가치 증명을 나타내는 컨센서스 메커니즘이 필요하다. 본질적으로 이는 암호 토큰의 가치를 부여하고 사용자가 중요한 암호 토큰을 생성하기 위해 합의한 합의 프로토콜을 만든다.</li>
</ul>

<h2 id="앱과-디앱의-차이">앱과 디앱의 차이</h2>

<ul>
  <li>디앱은 사용자가 계정을 생성하는 절차부터 앱과 다르다. 일반 앱은 회원가입을 할 때는 개인정보를 입력해 계정을 만들고 로그인 후 즉시 서비스를 이용한다. 하지만, 디앱의 경우 계정을 만들 때, <code class="language-plaintext highlighter-rouge">이더리움</code>, <code class="language-plaintext highlighter-rouge">이오스</code> 등 해당 블록체인 지갑을 보유하고 있어야 한다. 해당 블록체인 서비스에 참여함으로써, 보상으로 받는 암호화폐를 저장하고 거래하기 위한 지갑을 준비하는 것이다.</li>
  <li>이더리움 기반 디앱은 이더리움 지갑을, 이오스 기반 디앱은 이오스 지갑을 갖춰야 한다. 예를 들어 이더리움 게임으로 잘 알려진 크립토키티를 이용하려면 메타마스크라는 이더리움 지갑을 만들고, 서비스를 이용할 때마다 메타마스크 인증을 해야 한다.</li>
  <li>디앱과 기존 앱 개발의 가장 큰 차이점이라면 얼마나 엄격하게, 정밀하게 점검하느냐이다. 쉽게 말해, 디앱은 소프트웨어 개발보다는 하드웨어 개발과 더 비슷하다. 어떤 회사가 하드웨어를 완성했다면 제품을 공개하기전에 반드시 엄격하게 정밀하게 테스트를 한 후 공개해야 한다. 하드웨어 개발이 끝난 뒤 공개되었을 때, 미처 발견하지 못한 문제점들이 생긴다면 기존 소프트웨어 수정보다 훨씬 더 많은 돈과 시간을 요구한다. 왜냐하면 <code class="language-plaintext highlighter-rouge">디앱 개발에서 스마트 계약이 메인넷에서 한번 실행되면 절대 변경이 안 되기 때문이다.</code></li>
  <li>만약 오류가 생긴다면 스마트 계약에서 발견된 버그 때문에 사용자들의 암호화폐를 잃어버릴 가능성도 배제할 수 없다. 그래서 쉽게, 그리고 빠르게 개발하여 공개할 수 없는 이유도 된다.</li>
  <li>이와 반대로 기존 앱 개발은 빠르게 변하는 트렌드에 맞춰 새로운 서비스를 계속해서 만들어내는 것에 집중하는 편이다. 개발자로서 최소한의 실행 가능한 제품 즉, MVPs를 만들고 사람들이 직접 테스트하게 한 후 가능한 한 빨리 업데이트된 버전을 출시하는 것이 요새 앱 개발의 추세이지만 현재 디앱 개발자들에게는 적합하지 않은 추세다.</li>
</ul>

<p><br /></p>

<p style="text-align: center;"><img src="https://user-images.githubusercontent.com/52439201/172168332-f81afcc3-7170-4033-998b-51db7175ce1a.png" alt="image" /><br />
출처자료: 현암 코딩</p>

<p>정리해서, 기존 앱은 구글 플레이 스토어나 앱 스토어에 등록하여 구글과 애플의 <code class="language-plaintext highlighter-rouge">중앙화</code>된 서버에서 관리를 받는 반면에,<br />
디앱은 분산된 P2P 간의 자율적인 연결에 의해 <code class="language-plaintext highlighter-rouge">탈중앙화</code>된 이더리움, 이오스, 트론 등과 같은 스마트계약 기능이 있는 블록체인 플랫폼 위에서 작동되는 방식이다.</p>

<h2 id="출처">출처</h2>
<ul>
  <li><a href="http://wiki.hash.kr/index.php/%EB%94%94%EC%95%B1">해시넷</a></li>
</ul>]]></content><author><name>GitHub User</name></author><category term="BlockChain" /><category term="BlockChain" /><summary type="html"><![CDATA[DApp 정의]]></summary></entry><entry><title type="html">[TypeScript] 인터페이스 이해하기</title><link href="http://localhost:4000/typescirpt/2022/05/17/typescript-02.html" rel="alternate" type="text/html" title="[TypeScript] 인터페이스 이해하기" /><published>2022-05-17T00:00:00+09:00</published><updated>2022-05-17T00:00:00+09:00</updated><id>http://localhost:4000/typescirpt/2022/05/17/typescript-02</id><content type="html" xml:base="http://localhost:4000/typescirpt/2022/05/17/typescript-02.html"><![CDATA[<h2 id="인터페이스란">인터페이스란?</h2>

<p>인터페이스는 상호 간에 정의한 약속 혹은 규칙을 의미한다. 인터페이스는 보통 다음과 같은 범주에 대해서 약속을 정의할 수 있다.</p>

<ul>
  <li>객체의 스펙(속성과 속성의 타입)</li>
  <li>함수의 파라미터</li>
  <li>함수의 스펙(파라미터, 반환 타입 등)</li>
  <li>배열과 객체를 접근하는 방식</li>
  <li>클래스</li>
</ul>

<h2 id="인터페이스-예제">인터페이스 예제</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">who</span><span class="p">(</span> <span class="nx">obj</span><span class="p">:</span> <span class="p">{</span> <span class="nl">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="nx">number</span> <span class="p">})</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// seongsik</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span> <span class="c1">// 20</span>
<span class="p">}</span>

<span class="nx">who</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
</code></pre></div></div>

<p>위의 <code class="language-plaintext highlighter-rouge">who</code> 함수는 name과 age 속성을 갖는 객체를 인자로 받는다. 이렇게 인자를 받을 때 단순히 타입 뿐만 아니라 객체의 속성 타입까지 정의할 수 있다.
아래와 같이 인터페이스를 적용해보자.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">whoType</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>


<span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">who</span><span class="p">(</span> <span class="nx">obj</span><span class="p">:</span> <span class="nx">whoType</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">who</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
</code></pre></div></div>

<p>인터페이스를 사용하면 코드를 명시적으로 바뀔 수 있다. 
이제 <code class="language-plaintext highlighter-rouge">who()</code> 함수는 <code class="language-plaintext highlighter-rouge">whoType</code>라는 타입만 가져야 한다.</p>

<p><br /></p>

<h2 id="인터페이스-옵션-속성">인터페이스 옵션 속성</h2>
<p>인터페이스에 명시되어 있는 속성타입을 모두 다 사용할 필요는 없다. 이를 가능하게 하는 것이 <code class="language-plaintext highlighter-rouge">옵션 속성</code>이다.</p>

<p>아래의 예제 코드를 보자.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">인터페이스이름</span> <span class="p">{</span>
  <span class="nl">속성1</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">속성2</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">속성3</span><span class="p">?:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이처럼 <code class="language-plaintext highlighter-rouge">?</code> 물음표를 속성 끝에 붙이면 해당 속성을 꼭 사용하지 않아도 된다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">whoType</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nl">address</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">who</span><span class="p">(</span> <span class="nx">obj</span><span class="p">:</span> <span class="nx">whoType</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">age</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">user</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span> <span class="p">};</span>

<span class="nx">who</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
</code></pre></div></div>

<p>인자로 넘긴 user객체에 <code class="language-plaintext highlighter-rouge">address</code> 속성이 없어도 에러가 발생하지 않는다.
<code class="language-plaintext highlighter-rouge">whoType</code>타입에 address 인자에 <code class="language-plaintext highlighter-rouge">?</code> 붙여 옵션 속성을 사용했기 때문이다.</p>

<p><br /></p>

<h2 id="인터페이스-읽기-전용-속성">인터페이스 읽기 전용 속성</h2>

<p>읽기 전용 속성은 인터페이스로 객체를 처음 생성할 때 값을 할당하고, 그 이후에는 변경할 수 없는 속성을 말한다.</p>

<p>아래의 코드와 같이 <code class="language-plaintext highlighter-rouge">readonly</code> 속성을 사용하면 오직 읽기만 가능하기 때문에 선언이후 수정하려고 하면 아래와 같이 오류가 발생한다.</p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">userType</span> <span class="p">{</span>
 <span class="k">readonly</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">user</span><span class="p">:</span> <span class="nx">userType</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span>
<span class="p">};</span>

<span class="nx">user</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 읽기 전용 속성이므로 'name'에 할당할 수 없습니다.</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="인터페이스-읽기-전용-배열">인터페이스 읽기 전용 배열</h2>
<p>배열의 읽기전용 속성은 <code class="language-plaintext highlighter-rouge">ReadonlyArray&lt;T&gt;</code> 타입속성을 사용하면 읽기 전용 배열을 생성할 수 있다.</p>

<p>만약 배열을 수정하려고 하면 아래와 같이 오류가 발생한다.</p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">arr</span><span class="p">:</span> <span class="nx">ReadonlyArray</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">];</span>

<span class="nx">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">100</span><span class="p">;</span> <span class="c1">// 'readonly number[]' 형식의 인덱스 시그니처는 읽기만 허용됩니다.</span>
<span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span> <span class="c1">// 'readonly number[]' 형식에 'push' 속성이 없습니다.</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="객체-선언과-관련된-타입-체킹">객체 선언과 관련된 타입 체킹</h2>
<p>타입스크립트는 인터페이스를 통해 객체를 선언할 때 좀더 엄밀한 속성 검사를 진행한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">userTpye</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>


<span class="kd">function</span> <span class="nx">user</span><span class="p">(</span><span class="nx">user</span><span class="p">:</span> <span class="nx">userTpye</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">user</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">user</span><span class="p">({</span><span class="na">nam</span><span class="p">:</span><span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">})</span> <span class="c1">// '{ nam: string; }' 형식의 인수는 'userTpye' 형식의 매개 변수에 할당될 수 없습니다. 개체 리터럴은 알려진 속성만 지정할 수 있지만 'userTpye' 형식에 'nam'이(가) 없습니다. 'name'을(를) 쓰려고 했습니까?</span>
</code></pre></div></div>

<p>인터페이스에서는 <code class="language-plaintext highlighter-rouge">name</code>으로 선언했지만 함수에 인자로 넘기는 객체는 <code class="language-plaintext highlighter-rouge">nam</code>로 선언되어 있기 때문에 오류가 발생한다.</p>

<p>만약 이런 타입 추론을 무시하고 싶으면 아래와 같이 선언한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">myName</span> <span class="o">=</span> <span class="p">{</span><span class="na">nam</span><span class="p">:</span><span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">}</span>
<span class="nx">user</span><span class="p">(</span><span class="nx">myName</span> <span class="k">as</span> <span class="nx">userTpye</span><span class="p">)</span>
</code></pre></div></div>

<p>또한, 인터페이스에 정의하지 않는 속성들을 추가로 사용하고 싶다면 아래와 같이 작성한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">userTpye</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">?:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="p">[</span><span class="nx">propName</span><span class="p">:</span> <span class="kr">string</span><span class="p">]:</span> <span class="kr">any</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="인터페이스-함수-타입">인터페이스 함수 타입</h2>
<p>인터페이스는 함수의 타입도 정의할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">fnType</span> <span class="p">{</span>
  <span class="p">(</span><span class="nx">name</span><span class="p">:</span><span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span><span class="kr">string</span><span class="p">):</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">fn</span><span class="p">:</span> <span class="nx">fnType</span>
<span class="nx">fn</span> <span class="o">=</span> <span class="p">(</span><span class="nx">name</span><span class="p">:</span><span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span><span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// seongsik</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">age</span><span class="p">);</span>  <span class="c1">// 20</span>
  <span class="k">return</span> <span class="s2">`이름은 </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">, 나이는 </span><span class="p">${</span><span class="nx">age</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">fn</span><span class="p">(</span><span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">,</span> <span class="dl">'</span><span class="s1">20</span><span class="dl">'</span><span class="p">));</span> <span class="c1">// 이름은 seongsik, 나이는 20</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="인터페이스-클래스-타입">인터페이스 클래스 타입</h2>
<p>자바와 같은 클래스도 타입 규칙을 적용할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">userTpye</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nx">fnUser</span><span class="p">(</span><span class="nx">user</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>


<span class="kd">class</span> <span class="nx">User</span> <span class="k">implements</span> <span class="nx">userTpye</span> <span class="p">{</span>
  <span class="nl">name</span> <span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">fnUser</span><span class="p">(</span><span class="nx">user</span><span class="p">:</span> <span class="kr">string</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">user</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kd">constructor</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>


<span class="kd">let</span> <span class="nx">test</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">User</span><span class="p">;</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="c1">// seongsik</span>
<span class="nx">test</span><span class="p">.</span><span class="nx">fnUser</span><span class="p">(</span><span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">)</span> 
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">test</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="c1">// siksik</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="인터페이스-확장">인터페이스 확장</h2>

<p>인터페이스도 클래스처럼 확장할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">User</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Job</span> <span class="kd">extends</span> <span class="nx">User</span> <span class="p">{</span>
  <span class="nl">position</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">Who</span> <span class="p">:</span> <span class="nx">Job</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">position</span><span class="p">:</span> <span class="dl">'</span><span class="s1">developer</span><span class="dl">'</span>
<span class="p">}</span>

<span class="c1">// 혹은</span>

<span class="kd">let</span> <span class="nx">who2</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">as</span> <span class="nx">Job</span><span class="p">;</span>
<span class="nx">who2</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">who2</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">developer</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="인터페이스-하이브리드-타입">인터페이스 하이브리드 타입</h2>
<p>자바스크립트의 유연하고 동적인 타입 특성을 고려해 인터페이스도 여러 가지 타입을 조합해 사용할 수 있도록 되어있다.
예를 들어, 함수 타입이면서 객체 타입을 정의할 수 있는 인터페이가 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">UserType</span> <span class="p">{</span>
  <span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">position</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nx">brew</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">User</span><span class="p">():</span> <span class="nx">UserType</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">who</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{})</span> <span class="k">as</span> <span class="nx">UserType</span><span class="p">;</span>
  <span class="nx">who</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">developer</span><span class="dl">'</span><span class="p">;</span>
  <span class="nx">who</span><span class="p">.</span><span class="nx">brew</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{};</span>
  <span class="k">return</span> <span class="nx">who</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">Who</span> <span class="o">=</span> <span class="nx">User</span><span class="p">();</span>
<span class="nx">Who</span><span class="p">(</span><span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">);</span>
<span class="nx">Who</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">HR</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">Who</span><span class="p">.</span><span class="nx">brew</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Who</span><span class="p">);</span>
</code></pre></div></div>]]></content><author><name>GitHub User</name></author><category term="Typescirpt" /><category term="Typescirpt" /><category term="Javascript" /><category term="ES6" /><summary type="html"><![CDATA[인터페이스란?]]></summary></entry><entry><title type="html">[Javascript] 함수형 프로그래밍 - go, pipe, curry</title><link href="http://localhost:4000/javascript/2022/05/12/javascript-14.html" rel="alternate" type="text/html" title="[Javascript] 함수형 프로그래밍 - go, pipe, curry" /><published>2022-05-12T00:00:00+09:00</published><updated>2022-05-12T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/05/12/javascript-14</id><content type="html" xml:base="http://localhost:4000/javascript/2022/05/12/javascript-14.html"><![CDATA[<h2 id="시작으로">시작으로</h2>

<blockquote>
  <p>해당 글은 유인동님의 함수형 프로그래밍 강의내용을 정리하였습니다.</p>
</blockquote>

<p>아래와 같이 함수가 중첩되어 표현되면 가독성이 떨어지기 때문에 함수형 프로그래밍에서는 코드를 값으로 다뤄 표현력을 높일 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">log</span><span class="p">(</span>
    <span class="nx">reduce</span><span class="p">(</span>
        <span class="nx">add</span><span class="p">,</span>
        <span class="nx">map</span><span class="p">(</span><span class="nx">p</span><span class="o">=&gt;</span><span class="nx">p</span><span class="p">.</span><span class="nx">price</span><span class="p">,</span> 
        <span class="nx">filter</span><span class="p">(</span><span class="nx">p</span><span class="o">=&gt;</span><span class="nx">p</span><span class="p">.</span><span class="nx">price</span><span class="o">&gt;</span><span class="mi">2000</span><span class="p">,</span> <span class="nx">prod</span><span class="p">))</span>
    <span class="p">)</span>
<span class="p">)</span>
</code></pre></div></div>

<h2 id="go">go</h2>

<p>go함수에는 첫 번째는 값의 시작값을 넣고 그 외는 나머지 연산자로 함수들을 받아 값을 다음 함수로 계속해서 넘기면서 함수를 실행시켜주는 함수이다.</p>

<p>밑의 예제를 통해 쉽게 이해해보자.</p>

<h3 id="reduce-활용">reduce 활용</h3>

<p>go 함수는 함수들을 차례대로 실행하면서 첫 번째 인자값을 축약하는 함수이기 때문에 reduce 함수를 활용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">reduce</span> <span class="o">=</span> <span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">acc</span><span class="p">,</span> <span class="nx">iter</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">iter</span><span class="p">){</span>
        <span class="nx">iter</span> <span class="o">=</span> <span class="nx">acc</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>
        <span class="nx">acc</span> <span class="o">=</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kd">const</span> <span class="nx">a</span> <span class="k">of</span> <span class="nx">iter</span><span class="p">){</span>
        <span class="nx">acc</span> <span class="o">=</span> <span class="nx">func</span><span class="p">(</span><span class="nx">acc</span><span class="p">,</span><span class="nx">a</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">acc</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="구현">구현</h3>
<p>아래의 go함수는 0값을 차례대로 5개의 함수에 넘겨 처리하는 함수이다. 실행순서는 다음과 같다.</p>

<blockquote>
  <p>0, a =&gt; a+1</p>
  <ul>
    <li>0을 인자로 받아 0+1을 처리하여 <code class="language-plaintext highlighter-rouge">1</code>을 리턴한다.</li>
  </ul>
</blockquote>

<blockquote>
  <p>1, a =&gt; a+10</p>
  <ul>
    <li>1을 인자로 받아 1+10을 처리하여 <code class="language-plaintext highlighter-rouge">11</code>을 리턴한다.</li>
  </ul>
</blockquote>

<blockquote>
  <p>11, a =&gt; a+100</p>
  <ul>
    <li>11을 인자로 받아 11+100을 처리하여 <code class="language-plaintext highlighter-rouge">111</code>을 리턴한다.</li>
  </ul>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">log</span> <span class="o">=</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">go</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">arg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span><span class="nx">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">),</span> <span class="nx">arg</span><span class="p">)</span>

<span class="nx">go</span><span class="p">(</span>
    <span class="mi">0</span><span class="p">,</span>
    <span class="nx">a</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
    <span class="nx">a</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span>
    <span class="nx">a</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="o">+</span><span class="mi">100</span><span class="p">,</span>
    <span class="nx">log</span> <span class="c1">// 출력 : 111</span>
<span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="pipe">pipe</h2>
<p>pipe함수는 go함수와 다르게 함수를 리턴하는 함수이다. pipe함수는 여러 함수들을 인자로 받아 하나의 함수로 리턴한다.
그리고 go함수를 사용한다.</p>

<h3 id="구현-1">구현</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">pipe</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">fs</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">a</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">go</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">fs</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">pipe</span><span class="p">(</span>
    <span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
    <span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span>
    <span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">100</span><span class="p">,</span>
    <span class="nx">log</span>
<span class="p">)</span>

<span class="nx">f</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1">/// 111 출력</span>
<span class="nx">f</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">/// 121 출력</span>
</code></pre></div></div>

<h3 id="여러개의-인자를-받도록-수정">여러개의 인자를 받도록 수정</h3>
<p>그런데 여기서 go함수는 첫 번째 인자에 <code class="language-plaintext highlighter-rouge">add(0,10)</code>와 같이 인자를 두개 전달하여 처리된 값을 함수로 전달할 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">go</span><span class="p">(</span>
    <span class="nx">add</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">),</span>
    <span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
    <span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span>
    <span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">100</span><span class="p">,</span>
    <span class="nx">log</span>
<span class="p">)</span>
</code></pre></div></div>

<p>pipe도 그렇게 할수 있도록 코드를 수정해보자.</p>

<blockquote>
  <p>첫 번째로 받은 <code class="language-plaintext highlighter-rouge">f</code> 함수와 <code class="language-plaintext highlighter-rouge">...fs</code>를 따로 받는다. 그리고 리턴된 합성함수의 인자를 rest 파라미터로 처리하여 f함수에 넣고 그 결과를 나머지 함수들이 받으면서 처리하는 구조이다.</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">pipe</span> <span class="o">=</span> <span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="p">...</span><span class="nx">fs</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(...</span><span class="nx">arg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">go</span><span class="p">(</span><span class="nx">f</span><span class="p">(...</span><span class="nx">arg</span><span class="p">),</span> <span class="p">...</span><span class="nx">fs</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">pipe</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">,</span>
    <span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
    <span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">10</span><span class="p">,</span>
    <span class="nx">a</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">+</span><span class="mi">100</span><span class="p">,</span>
    <span class="nx">log</span>
<span class="p">)</span>

<span class="nx">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1">// 114</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="go함수를-활용하여-더-좋은-코드로-개선">go함수를 활용하여 더 좋은 코드로 개선</h2>

<ul>
  <li>개선전 코드</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">log</span> <span class="o">=</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">prod</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">과자</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span><span class="mi">2500</span><span class="p">},</span>
    <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">소시지</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span><span class="mi">2000</span><span class="p">},</span>
    <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">맥주</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span><span class="mi">5000</span><span class="p">},</span>
    <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">음료수</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span><span class="mi">1500</span><span class="p">},</span>
    <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">껌</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span><span class="mi">1000</span><span class="p">},</span>
<span class="p">]</span>

<span class="kd">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">iter</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kd">const</span> <span class="nx">a</span> <span class="k">of</span> <span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">a</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">filter</span> <span class="o">=</span> <span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">iter</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span><span class="p">(</span><span class="kd">const</span> <span class="nx">a</span> <span class="k">of</span> <span class="nx">iter</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">a</span><span class="p">)){</span>
            <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">reduce</span> <span class="o">=</span> <span class="p">(</span><span class="nx">func</span><span class="p">,</span> <span class="nx">acc</span><span class="p">,</span> <span class="nx">iter</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">iter</span><span class="p">){</span>
        <span class="nx">iter</span> <span class="o">=</span> <span class="nx">acc</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>
        <span class="nx">acc</span> <span class="o">=</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kd">const</span> <span class="nx">a</span> <span class="k">of</span> <span class="nx">iter</span><span class="p">){</span>
        <span class="nx">acc</span> <span class="o">=</span> <span class="nx">func</span><span class="p">(</span><span class="nx">acc</span><span class="p">,</span><span class="nx">a</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">acc</span>
<span class="p">}</span>

<span class="nx">log</span><span class="p">(</span>
  <span class="nx">reduce</span><span class="p">(</span>
      <span class="nx">add</span><span class="p">,</span>
      <span class="nx">map</span><span class="p">(</span><span class="nx">p</span><span class="o">=&gt;</span><span class="nx">p</span><span class="p">.</span><span class="nx">price</span><span class="p">,</span> 
      <span class="nx">filter</span><span class="p">(</span><span class="nx">p</span><span class="o">=&gt;</span><span class="nx">p</span><span class="p">.</span><span class="nx">price</span><span class="o">&gt;</span><span class="mi">2000</span><span class="p">,</span> <span class="nx">prod</span><span class="p">))</span>
  <span class="p">)</span>
<span class="p">)</span> <span class="c1">// 출력 : 7500</span>
  
</code></pre></div></div>

<ul>
  <li>개선후 코드</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">go</span><span class="p">(</span>
    <span class="nx">prod</span><span class="p">,</span>
    <span class="nx">prod</span> <span class="o">=&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">p</span> <span class="o">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">price</span><span class="o">&gt;</span><span class="mi">2000</span><span class="p">,</span> <span class="nx">prod</span><span class="p">),</span>
    <span class="nx">prod</span> <span class="o">=&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">p</span> <span class="o">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">price</span><span class="p">,</span> <span class="nx">prod</span><span class="p">),</span>
    <span class="nx">prices</span> <span class="o">=&gt;</span> <span class="nx">reduce</span><span class="p">(</span><span class="nx">add</span><span class="p">,</span> <span class="nx">prices</span><span class="p">),</span>
    <span class="nx">log</span>
<span class="p">)</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="curry">curry</h2>
<p>curry를 사용하면 함수를 부분적으로 사용할 수 있게 된다.
기존의 map, filter, reduce 함수들은 인자값을 2개를 받아야 실행되었다.
curry를 감싸게 되면 부족한 인자가 들어올 때까지 대기하다가 들어오면 함수를 실행하게 된다.</p>

<ul>
  <li>curry는 함수를 인자로 받아 함수를 리턴해준다.</li>
  <li>리턴받은 합성함수는 1개 이상의 인자를 받는데 인자의 갯수가 2개 이상이면 처음 받았던 함수를 즉시 실행하고, 2보다 적으면 기다렸다가 인자를 받으면 함수를 실행한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">curry</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">_</span><span class="p">.</span><span class="nx">length</span> <span class="p">?</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">_</span><span class="p">)</span> <span class="p">:</span> <span class="p">(...</span><span class="nx">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">_</span><span class="p">);</span>

<span class="c1">// 1. a와 b의 곱셈을 리턴하는 함수를 인자로 받는다. </span>
<span class="c1">// 2. 그리고 함수를 리턴한다.</span>
<span class="kd">const</span> <span class="nx">mult</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span><span class="o">=&gt;</span><span class="nx">a</span><span class="o">*</span><span class="nx">b</span><span class="p">);</span> 
<span class="nx">log</span><span class="p">(</span><span class="nx">mult</span><span class="p">)</span> <span class="c1">// (a, ..._) =&gt; _.length ? f(a, ..._) : (..._) =&gt; f(a, ..._)</span>

<span class="nx">log</span><span class="p">(</span><span class="nx">mult</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="c1">// 인자가 1개이므로 (..._) =&gt; f(a, ..._)를 리턴한다.</span>
<span class="nx">log</span><span class="p">(</span><span class="nx">mult</span><span class="p">(</span><span class="mi">3</span><span class="p">)(</span><span class="mi">6</span><span class="p">))</span> <span class="c1">// 리턴받은 함수에 6을 인자로 넘겨줬기 때문에 (6) =&gt; f(3, 6)이 실행된다.</span>
</code></pre></div></div>

<h3 id="go--curry를-사용하여-더-좋은-코드로-만들기">go + curry를 사용하여 더 좋은 코드로 만들기</h3>

<ul>
  <li>map, filter, reduce를 cuury로 감싼다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">log</span> <span class="o">=</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">prod</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">과자</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span><span class="mi">2500</span><span class="p">},</span>
    <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">소시지</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span><span class="mi">2000</span><span class="p">},</span>
    <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">맥주</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span><span class="mi">5000</span><span class="p">},</span>
    <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">음료수</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span><span class="mi">1500</span><span class="p">},</span>
    <span class="p">{</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">껌</span><span class="dl">'</span><span class="p">,</span> <span class="na">price</span><span class="p">:</span><span class="mi">1000</span><span class="p">},</span>
<span class="p">]</span>

<span class="kd">const</span> <span class="nx">add</span> <span class="o">=</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">curry</span> <span class="o">=</span> <span class="nx">f</span> <span class="o">=&gt;</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">_</span><span class="p">.</span><span class="nx">length</span> <span class="p">?</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">_</span><span class="p">)</span> <span class="p">:</span> <span class="p">(...</span><span class="nx">_</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="p">...</span><span class="nx">_</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">map</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">((</span><span class="nx">func</span><span class="p">,</span> <span class="nx">iter</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>
    
    <span class="k">for</span><span class="p">(</span><span class="kd">const</span> <span class="nx">a</span> <span class="k">of</span> <span class="nx">iter</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">a</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">});</span>

<span class="kd">const</span> <span class="nx">filter</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">((</span><span class="nx">func</span><span class="p">,</span> <span class="nx">iter</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="p">[];</span>

    <span class="k">for</span><span class="p">(</span><span class="kd">const</span> <span class="nx">a</span> <span class="k">of</span> <span class="nx">iter</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">func</span><span class="p">(</span><span class="nx">a</span><span class="p">)){</span>
            <span class="nx">result</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="nx">result</span><span class="p">;</span>
<span class="p">})</span>

<span class="kd">const</span> <span class="nx">reduce</span> <span class="o">=</span> <span class="nx">curry</span><span class="p">((</span><span class="nx">func</span><span class="p">,</span> <span class="nx">acc</span><span class="p">,</span> <span class="nx">iter</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="nx">iter</span><span class="p">){</span>
        <span class="nx">iter</span> <span class="o">=</span> <span class="nx">acc</span><span class="p">[</span><span class="nb">Symbol</span><span class="p">.</span><span class="nx">iterator</span><span class="p">]();</span>
        <span class="nx">acc</span> <span class="o">=</span> <span class="nx">iter</span><span class="p">.</span><span class="nx">next</span><span class="p">().</span><span class="nx">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kd">const</span> <span class="nx">a</span> <span class="k">of</span> <span class="nx">iter</span><span class="p">){</span>
        <span class="nx">acc</span> <span class="o">=</span> <span class="nx">func</span><span class="p">(</span><span class="nx">acc</span><span class="p">,</span><span class="nx">a</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">acc</span>
<span class="p">})</span>
</code></pre></div></div>

<ul>
  <li>기존의 go 함수를 아래와 같이 사용할 수 있다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">go</span> <span class="o">=</span> <span class="p">(...</span><span class="nx">arg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">reduce</span><span class="p">((</span><span class="nx">a</span><span class="p">,</span><span class="nx">f</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">f</span><span class="p">(</span><span class="nx">a</span><span class="p">),</span> <span class="nx">arg</span><span class="p">)</span>

<span class="c1">// curry 적용 전</span>
<span class="nx">go</span><span class="p">(</span>
    <span class="nx">prod</span><span class="p">,</span>
    <span class="nx">prod</span> <span class="o">=&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">p</span> <span class="o">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">price</span><span class="o">&gt;</span><span class="mi">2000</span><span class="p">,</span> <span class="nx">prod</span><span class="p">),</span>
    <span class="nx">prod</span> <span class="o">=&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">p</span> <span class="o">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">price</span><span class="p">,</span> <span class="nx">prod</span><span class="p">),</span>
    <span class="nx">prices</span> <span class="o">=&gt;</span> <span class="nx">reduce</span><span class="p">(</span><span class="nx">add</span><span class="p">,</span> <span class="nx">prices</span><span class="p">),</span>
    <span class="nx">log</span>
<span class="p">)</span>

<span class="c1">// cuury 적용 후</span>
<span class="nx">go</span><span class="p">(</span>
    <span class="nx">prod</span><span class="p">,</span>
    <span class="nx">prod</span> <span class="o">=&gt;</span> <span class="nx">filter</span><span class="p">(</span><span class="nx">p</span> <span class="o">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">price</span><span class="o">&gt;</span><span class="mi">2000</span><span class="p">)(</span><span class="nx">prod</span><span class="p">),</span>
    <span class="nx">prod</span> <span class="o">=&gt;</span> <span class="nx">map</span><span class="p">(</span><span class="nx">p</span> <span class="o">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">price</span><span class="p">)(</span><span class="nx">prod</span><span class="p">),</span>
    <span class="nx">prices</span> <span class="o">=&gt;</span> <span class="nx">reduce</span><span class="p">(</span><span class="nx">add</span><span class="p">)(</span><span class="nx">prices</span><span class="p">),</span>
    <span class="nx">log</span>
<span class="p">)</span>

<span class="c1">// cuury를 사용하고 있으므로 중복되는 prod를 제거해도 똑같이 실행된다.</span>
<span class="nx">go</span><span class="p">(</span>
    <span class="nx">prod</span><span class="p">,</span>
    <span class="nx">filter</span><span class="p">(</span><span class="nx">p</span> <span class="o">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">price</span><span class="o">&gt;</span><span class="mi">2000</span><span class="p">),</span>
    <span class="nx">map</span><span class="p">(</span><span class="nx">p</span> <span class="o">=&gt;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">price</span><span class="p">),</span>
    <span class="nx">reduce</span><span class="p">(</span><span class="nx">add</span><span class="p">),</span>
    <span class="nx">log</span>
<span class="p">)</span>
</code></pre></div></div>]]></content><author><name>GitHub User</name></author><category term="Javascript" /><category term="Javascript" /><category term="ES6" /><summary type="html"><![CDATA[시작으로]]></summary></entry><entry><title type="html">[React] 엘리먼트, 컴포넌트, 인스턴스 개념</title><link href="http://localhost:4000/react/2022/05/09/react-03.html" rel="alternate" type="text/html" title="[React] 엘리먼트, 컴포넌트, 인스턴스 개념" /><published>2022-05-09T00:00:00+09:00</published><updated>2022-05-09T00:00:00+09:00</updated><id>http://localhost:4000/react/2022/05/09/react-03</id><content type="html" xml:base="http://localhost:4000/react/2022/05/09/react-03.html"><![CDATA[<h2 id="시작으로">시작으로</h2>

<p>해당 포스터는</p>

<ul>
  <li><a href="https://velog.io/@yejineee/%EB%A6%AC%EC%95%A1%ED%8A%B8-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4#%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8%EA%B0%80-%ED%8A%B8%EB%A6%AC%EB%A5%BC-%ED%91%9C%ED%98%84%ED%95%98%EB%8B%A4">리액트 컴포넌트, 엘리먼트, 인스턴스</a></li>
  <li><a href="https://it-eldorado.tistory.com/82?category=832493">IT 엘도라도</a></li>
</ul>

<p>블로그를 참조하여 정리하였습니다.</p>

<p><br /></p>

<h2 id="엘리먼트element">엘리먼트(Element)</h2>
<ul>
  <li>화면에 렌더링 할 DOM 노드들의 정보를 React에 알려주기 위한 수단으로 React에서 가장 작은 단위이다.</li>
  <li>브라우저 DOM 엘리먼트와 달리 React 엘리먼트는 일반 객체이며(plain object) 쉽게 생성할 수 있다. React DOM은 React 엘리먼트와 일치하도록 DOM을 업데이트한다.</li>
  <li>type(문자열 혹은 컴포넌트 함수/클래스)과 props(객체)로 표현된다.</li>
  <li>하나 이상의 자식 엘레먼트는 props의 children 필드로 표현된다. 이를 통해 엘리먼트들이 중첩될 수 있다.</li>
  <li>children에는 텍스트에 해당하는 문자열, 엘리먼트, 엘리먼트들의 배열 등이 저장될 수 있다.</li>
  <li>일반적으로 JavaScript의 React.createElement() 함수 또는 JSX의 태그 문법으로 작성한다.</li>
  <li>엘리먼트들로 이루어진 트리를 엘리먼트 트리라 부르며, 이것은 메모리 상에만 존재하는 가상 DOM이다.</li>
</ul>

<p><br /></p>

<h2 id="dom-엘리먼트">DOM 엘리먼트</h2>

<ul>
  <li>엘리먼트의 <code class="language-plaintext highlighter-rouge">type</code>이 태그 이름에 해당하는 문자열인 경우를 말한다(ex. ‘div’, ‘p’, ‘button’)</li>
  <li>해당 태그를 가진 DOM 노드를 표현하며, props 정보를 통해 해당 노드의 속성을 표현한다.</li>
  <li>React가 실제로 화면에 렌더링 하는 대상에 해당한다.</li>
  <li>type이 string이면 태그 이름으로 DOM node를 나타낸 것이다. props는 그 속성에 해당하는 것이다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  type: 'button',
  props: {
    className: 'button-class',
    children: {
      type: 'div',
      props: {
        children: 'text'
      }
    }
  }
}
</code></pre></div></div>

<pre><code class="language-JS">&lt;button class='button-class'&gt;
  &lt;div&gt;
    text
  &lt;/div&gt;
&lt;/button&gt;
</code></pre>

<p>여기서 각 엘리먼트들이 어떻게 중첩되어있는지 집중해야한다.
하나 이상의 자식 엘리먼트를 만들 때 부모 엘리먼트의 children prop으로 명시하게 된다.</p>

<p>중요한 건 자식과 부모 엘리먼트 모두, 그저 description일 뿐이지 실제 인스턴스가 아니라는 것이다.
스크린에서는 엘리먼트를 만들 때 어떠한 것도 참조하지 않는다.</p>

<p>리액트 엘리먼트는 순회하기 쉬우며, 파싱할 필요도 없다. 리액트 엘리먼트는 객체이기 때문에 실제 DOM 엘리먼트보다 훨씬 가볍다.
(객체이기 때문에 바로 접근이 가능하고, 순회가 쉬우며 파싱할 필요가 없으므로)</p>

<p><br /></p>

<h2 id="컴포넌트-엘리먼트">컴포넌트 엘리먼트</h2>
<ul>
  <li>엘레먼트의 type이 문자열이 아니라, 리액트 컴포넌트에 해당하는 클래스나 함수인 경우를 말한다.</li>
  <li>사용자가 직접 정의한 컴포넌트를 표현하며, <code class="language-plaintext highlighter-rouge">입력으로 props를 받으면 렌더링 할 엘리먼트 트리를 반환한다.</code></li>
  <li>클래스형 컴포넌트는 지역 상태를 가질수 있으며, DOM노드의 생명 주기(생성, 수정, 삭제)를 제어할 수 있다.</li>
  <li>함수형 컴포넌트는 render() 함수만 가지는 클래스형 컴포넌트와 동일하며, 지역 상태를 가질 수 없지만 구현이 단순하다.</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  type: Button,
  props: {
    className: 'button-class',
    children: {
      type: 'div',
      props: {
        children: 'text'
      }
    }
  }
}
</code></pre></div></div>

<p>컴포넌트를 표현하는 엘리먼트도 엘리먼트이다.</p>

<p>아래의 컴포넌트는 Button 타입의 DangerButton을 정의할 수 있게 한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">DangerButton</span> <span class="o">=</span> <span class="p">({</span> <span class="nx">children</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="p">({</span>
  <span class="na">type</span><span class="p">:</span> <span class="nx">Button</span><span class="p">,</span>
  <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">color</span><span class="p">:</span> <span class="dl">'</span><span class="s1">red</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">children</span><span class="p">:</span> <span class="nx">children</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>이제 위의 만들었던 DangerButton 컴포넌트를 하나의 엘리먼트 트리 안에 사용할 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">DeleteAccount</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span>
  <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">div</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">children</span><span class="p">:</span> <span class="p">[{</span>
      <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">p</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">children</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Are you sure?</span><span class="dl">'</span>
      <span class="p">}</span>
    <span class="p">},</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="nx">DangerButton</span><span class="p">,</span>
      <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">children</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Yep</span><span class="dl">'</span>
      <span class="p">}</span>
    <span class="p">},</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="nx">Button</span><span class="p">,</span>
      <span class="na">props</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">color</span><span class="p">:</span> <span class="dl">'</span><span class="s1">blue</span><span class="dl">'</span><span class="p">,</span>
        <span class="na">children</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Cancel</span><span class="dl">'</span>
      <span class="p">}</span>
   <span class="p">}]</span>
  <span class="p">}</span>
<span class="p">});</span>
</code></pre></div></div>

<p>위의 객체를 JSX로 표현하면 아래와 같다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">DeleteAccount</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">(</span>
  <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="nx">Are</span> <span class="nx">you</span> <span class="nx">sure</span><span class="p">?</span><span class="o">&lt;</span><span class="sr">/p</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">DangerButton</span><span class="o">&gt;</span><span class="nx">Yep</span><span class="o">&lt;</span><span class="sr">/DangerButton</span><span class="err">&gt;
</span>    <span class="o">&lt;</span><span class="nx">Button</span> <span class="nx">color</span><span class="o">=</span><span class="dl">'</span><span class="s1">blue</span><span class="dl">'</span><span class="o">&gt;</span><span class="nx">Cancel</span><span class="o">&lt;</span><span class="sr">/Button</span><span class="err">&gt;
</span>  <span class="o">&lt;</span><span class="sr">/div</span><span class="err">&gt;
</span><span class="p">);</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="component-encapsulate-element-trees">Component Encapsulate Element Trees</h2>

<p>리액트는 함수나 클래스 타입의 엘리먼트를 만나면, 해당하는 props에 관하여 그 컴포넌트가 어떤 엘리먼트를 렌더링할 것인지 물어본다.</p>

<p>만약 리액트가 아래와 같은 엘리먼트를 만난다면</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">type</span><span class="p">:</span> <span class="nx">Button</span><span class="p">,</span>
  <span class="nx">props</span><span class="p">:</span> <span class="p">{</span>
    <span class="nl">color</span><span class="p">:</span> <span class="dl">'</span><span class="s1">blue</span><span class="dl">'</span><span class="p">,</span>
    <span class="nx">children</span><span class="p">:</span> <span class="dl">'</span><span class="s1">OK!</span><span class="dl">'</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Button 컴포넌트에게 무엇을 렌더링할 것인지를 물어본다. 그 Button 컴포넌트는 다음의 엘리먼트를 반환한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">button</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">props</span><span class="p">:</span> <span class="p">{</span>
    <span class="nl">className</span><span class="p">:</span> <span class="dl">'</span><span class="s1">button button-blue</span><span class="dl">'</span><span class="p">,</span>
    <span class="nx">children</span><span class="p">:</span> <span class="p">{</span>
      <span class="nl">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span>
      <span class="nx">props</span><span class="p">:</span> <span class="p">{</span>
        <span class="nl">children</span><span class="p">:</span> <span class="dl">'</span><span class="s1">OK!</span><span class="dl">'</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>리액트는 이 과정을 페이지의 모든 컴포넌트에게 그 아래에 있는 DOM 태그 엘리먼트를 알 때까지 반복한다.</p>

<p>리액트 컴포넌트에서 props는 Input이며, element tree가 output이 된다.</p>

<p>반환된 element tree는 DOM node를 설명하는 엘리먼트와 다른 컴포넌트를 설명하는 엘리먼트가 포함될 수 있다. 이는 그 내부의 DOM 구조에 기대지 않고, 독립적인 UI를 구성할 수 있게 해준다.</p>

<p>리액트가 instance를 생성하고, 업데이트하고, 없앤다. 우리는 그 인스턴스를 컴포넌트로부터 반환한 엘리먼트들로 표현하며, 리액트는 그 인스턴스를 관리한다.</p>]]></content><author><name>GitHub User</name></author><category term="React" /><category term="React" /><category term="Gatsby" /><category term="Next.js" /><category term="Node.js" /><category term="Typescirpt" /><category term="Javascript" /><category term="ES6" /><summary type="html"><![CDATA[시작으로]]></summary></entry></feed>