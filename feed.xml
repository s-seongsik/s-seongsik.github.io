<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-10-10T23:29:50+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">IT 데이터베이스</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>GitHub User</name></author><entry><title type="html">[Vue3.js] 새로운 기능 파악하기(미완)</title><link href="http://localhost:4000/vue.js/vue3.js/2022/10/09/vue3-01.html" rel="alternate" type="text/html" title="[Vue3.js] 새로운 기능 파악하기(미완)" /><published>2022-10-09T00:00:00+09:00</published><updated>2022-10-09T00:00:00+09:00</updated><id>http://localhost:4000/vue.js/vue3.js/2022/10/09/vue3-01</id><content type="html" xml:base="http://localhost:4000/vue.js/vue3.js/2022/10/09/vue3-01.html"><![CDATA[<h2 id="시작으로">시작으로</h2>

<p>이직한 회사에서 사용하는 웹 기술 스택이 Vue3이다. 전 회사에서 Vue2를 사용해봤지만 스터디할 시간이 부족하여 실무하면서 그때그때 찾아보면서 스터디를 했다. 
그래도 Vue3가 나온 이유의 대해서 정확하게 알지 못하기 때문에 컨셉, 새로운 기능, 주의해야할 점들을 정리해보려고 한다. 공식문서에 가이드를 보고 리스트업을 시작했다.</p>

<h2 id="vue3의-새로운-기능">Vue3의 새로운 기능</h2>

<h3 id="composition-api">Composition API</h3>

<h3 id="teleport">Teleport</h3>

<h3 id="fragments">Fragments</h3>

<h3 id="emits-컴포넌트-옵션">Emits 컴포넌트 옵션</h3>

<h3 id="커스텀-렌더들을-생성하기-위한-vueruntime-core의-createrenderer-api">커스텀 렌더들을 생성하기 위한 @vue/runtime-core의 createRenderer API</h3>

<h3 id="vue3의-sfcsingle-file-components-기능">Vue3의 SFC(Single-File Components) 기능</h3>

<h2 id="참고">참고</h2>

<ul>
  <li>https://v3.ko.vuejs.org/guide/migration/introduction.html#notable-new-features</li>
  <li>https://www.samsungsds.com/kr/insights/vue_js_3.html</li>
  <li>https://joshua1988.github.io/web-development/vuejs/vue3-as-default/</li>
</ul>]]></content><author><name>GitHub User</name></author><category term="Vue.js" /><category term="Vue3.js" /><category term="Webpack" /><category term="Babel" /><category term="Node.js" /><category term="Javascript" /><summary type="html"><![CDATA[시작으로]]></summary></entry><entry><title type="html">[git] OS별 CRLF 새줄 문자 차이 발생 및 해결</title><link href="http://localhost:4000/git/2022/08/16/git-12.html" rel="alternate" type="text/html" title="[git] OS별 CRLF 새줄 문자 차이 발생 및 해결" /><published>2022-08-16T00:00:00+09:00</published><updated>2022-08-16T00:00:00+09:00</updated><id>http://localhost:4000/git/2022/08/16/git-12</id><content type="html" xml:base="http://localhost:4000/git/2022/08/16/git-12.html"><![CDATA[<h2 id="문제-발생">문제 발생</h2>
<p>회사 PC는 윈도우를 사용하고 있으며 도커 환경(linux)에서 작업을 진행하고 있다. 개인노트북은 M1 맥북으로 재택이나 주말(심심할때)에 작업을 진행하고 있다.
근데, winodws &gt; docker 컨테이너 환경으로 들어가면 변경된게 없는데 모든 소스코드가 변경된것 처럼 발생한다.</p>

<p>그 이유는 OS별로 CR/LF 새줄 문자 처리하는게 다르기 때문이다.<br />
새줄 문자(new line)이란, 텍스트의 한 줄이 끝남을 표시하는 문자 또는 문자열을 말한다. 개행 문자, 줄바꿈 문자(line break), EOL(end-of-line) 모두 같은 말이다.
기종이나 운영체제별로 새줄 문자를 나타내는 코드가 다를 수 있다. 그래서 git 사용시 새줄 문자를 통일시켜야 한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Windows</th>
      <th style="text-align: left">Linux / Mac OS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">LF(Line Feed, \n)</td>
      <td style="text-align: left">LF(Line Feed, \n)</td>
    </tr>
    <tr>
      <td style="text-align: left">CR(Carriage-Return, \r)</td>
      <td style="text-align: left"> </td>
    </tr>
  </tbody>
</table>

<p>위의 표처럼, 로컬 개발 환경에서 사용하는 운영체제별로 새줄 문자를 인식하는게 다를 수 있다. 이 문제로 리모트 저장소에 있는 동일한 소스 코드를 각 로컬 환경(Windows, Mac OS, Linux 등)에서 각각 받아와도 새줄 문자 차이로 오류가 발생할 수 있다.</p>

<h2 id="해결방법">해결방법</h2>
<p>git 설정을 해주면 된다.</p>

<p><code class="language-plaintext highlighter-rouge">core.eof</code>는 git이 line ending을 어떻게 처리할건지 설정할 수 있다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">core.eol = native</code>, 기본 설정으로 시스템의 line ending을 따른다. 윈도우는 CRLF를 Linux는 LF를 사용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">core.eol = crlf</code>, CRLF를 line ending으로 사용한다.</li>
  <li><code class="language-plaintext highlighter-rouge">core.eol = lf</code>, LF를 line ending으로 사용한다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">## 설정</span>
<span class="nv">$ </span>git config <span class="nt">--global</span> core.eol native

<span class="c">## 확인</span>
<span class="nv">$ </span>git config <span class="nt">--global</span> <span class="nt">--list</span>|grep core.eol
core.eol<span class="o">=</span>native
</code></pre></div></div>

<p><br /></p>

<p>git은 저장소 메타 데이타 디렉터리인 .git 폴더에 모든 이력 데이타를 갖고 있다. 이력 데이타는 key/value 형식의 데이타베이스이며 core.autocrlf 는 text file를 git object database에 checkin, checkout 할 때 어떻게 처리할지를 설정하는 변수이다.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">core.autocrlf = false</code>, 기본 설정으로 CRLF를 쓰던 LF를 쓰던 git은 상관하지 않고 파일 그대로 checkin, checkout한다. 이 설정은 line ending 이 다른 OS 에서는 text file이 변경되었다고 나오므로 위에서 언급한 여러 가지 문제가 발생할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">core.autocrlf = true</code>, text file을 object database에 넣기전에 CRLF를 LF로 변경한다.</li>
  <li><code class="language-plaintext highlighter-rouge">core.autocrlf = input</code> LF를 line ending으로 사용한다.</li>
</ul>

<h3 id="windows-설정">Windows 설정</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git config <span class="nt">--global</span> core.autocrlf <span class="nb">true</span>
</code></pre></div></div>

<h3 id="linuxmac-os-설정">Linux/Mac OS 설정</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git config <span class="nt">--global</span> core.autocrlf input
</code></pre></div></div>

<p>이렇게 설정하게 되되면</p>

<p><img src="https://user-images.githubusercontent.com/52439201/184898322-c155187a-cb88-465b-96c0-ee9ad45544f4.png" alt="image" /></p>

<ul>
  <li>windows =&gt; git, push할때 CRLF -&gt; carriage-return을 지워서 LF로 저장한다.</li>
  <li>
    <p>windows &lt;= git, pull할때 LF -&gt; carriage-return를 붙여 CRLF로 가져온다.</p>
  </li>
  <li>Mac OS =&gt; git, push할때 carriage-return을 지워서 LF로 저장한다.</li>
  <li>Mac OS &lt;= git, pull할때 LF로 가져온다.</li>
</ul>

<p>엇? 결론은 모든 line ending을 LF로 변경하는 건데 Mac OS는 따로 설정안해줘도 되는거 아니야? 응 아니야.<br />
그 이유는 만약에 맥에서 이메일같은 곳에서 텍스트를 복사 붙여넣기 하게되면 실수로 <code class="language-plaintext highlighter-rouge">CR(carriage-return)</code>이 들어갈 수 있으므로 설정해주는 것이 안전하다.</p>

<h2 id="ref">Ref</h2>
<ul>
  <li><a href="https://www.lesstif.com/gitbook/git-crlf-20776404.html">https://www.lesstif.com/gitbook/git-crlf-20776404.html</a></li>
  <li><a href="https://gist.github.com/taekwon-dev/527449c7e6ed41cc6078cb212fc72d09">https://gist.github.com/taekwon-dev/527449c7e6ed41cc6078cb212fc72d09</a></li>
  <li><a href="https://yoongrammer.tistory.com/32">https://yoongrammer.tistory.com/32</a></li>
</ul>]]></content><author><name>GitHub User</name></author><category term="Git" /><category term="Git" /><category term="Github" /><summary type="html"><![CDATA[문제 발생 회사 PC는 윈도우를 사용하고 있으며 도커 환경(linux)에서 작업을 진행하고 있다. 개인노트북은 M1 맥북으로 재택이나 주말(심심할때)에 작업을 진행하고 있다. 근데, winodws &gt; docker 컨테이너 환경으로 들어가면 변경된게 없는데 모든 소스코드가 변경된것 처럼 발생한다.]]></summary></entry><entry><title type="html">[git] SSH로 여러 개의 Gitgub 계정 사용하기</title><link href="http://localhost:4000/git/2022/08/10/git-11.html" rel="alternate" type="text/html" title="[git] SSH로 여러 개의 Gitgub 계정 사용하기" /><published>2022-08-10T00:00:00+09:00</published><updated>2022-08-10T00:00:00+09:00</updated><id>http://localhost:4000/git/2022/08/10/git-11</id><content type="html" xml:base="http://localhost:4000/git/2022/08/10/git-11.html"><![CDATA[<h2 id="문제-발생">문제 발생</h2>
<p>최근 맥북프로를 장만하고 git, github을 개인 계정으로만 사용하고 있었다.
8/8일… 최악의 폭우로 인해 2일간 재택근무를 하게 되었다. 회사 업무는 데스크탑으로 했기 때문에 노트북을 사용할 일이 없었지만 급작스러운 재택 때문에 회사 업무관련 개발환경을 전부 셋팅해야 했다.</p>

<p>여기서 발생한 문제</p>
<ul>
  <li>ssh-key를 회사 github 계정에 등록했는데 Permission Error가 발생했다.</li>
</ul>

<p>해결 방법은 간단했다.</p>
<ol>
  <li>ssh-key 생성</li>
  <li>ssh-key 등록</li>
  <li>ssh config 파일 작성</li>
  <li>github 계정에 ssh-key 등록</li>
  <li>로컬 저장소별로 .git config 파일 수정</li>
</ol>

<p><br /></p>

<h2 id="ssh-key-생성">ssh-key 생성</h2>
<ul>
  <li>~/.ssh로 이동한다.</li>
  <li>만약 존재하지않으면 생성 후 이동</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir</span> ~/.ssh
<span class="nv">$ </span><span class="nb">cd</span> ~/.ssh
</code></pre></div></div>

<p><br /></p>

<ul>
  <li>이동 후 ssh-key를 생성</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ssh-keygen <span class="nt">-t</span> <span class="o">[</span>암호화 방식] <span class="nt">-b</span> <span class="o">[</span>생성 Key 크기] <span class="nt">-C</span> <span class="s1">'GitHub 계정 메일'</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: left">구분</th>
      <th style="text-align: left">내용</th>
      <th style="text-align: left">비고</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">암호화 방식</td>
      <td style="text-align: left">ssh-key의 암호화 방식</td>
      <td style="text-align: left">rsa 방식 사용</td>
    </tr>
    <tr>
      <td style="text-align: left">생성 Key 크기</td>
      <td style="text-align: left">3072(default)~4096</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">GitHub 계정 메일</td>
      <td style="text-align: left">GitHub 생성 시 등록에 사용한 메일 주소</td>
      <td style="text-align: left">우측상단 &gt; Settings &gt; Emails</td>
    </tr>
  </tbody>
</table>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ssh-keygen <span class="nt">-t</span> rsa <span class="nt">-b</span> 4096 <span class="nt">-C</span> <span class="s2">"your_email@gmail.com"</span>
</code></pre></div></div>

<p>명령어를 실행하면 아래와 같이 나올 것이다.
생성할 파일의 이름을 적어달라는 것인데. 그냥 엔터를 누르면 <code class="language-plaintext highlighter-rouge">id_rsa</code>라는 이름으로 저장된다. 따로 저장할 이름이 있으면 작성하면 된다.
나는 개인 github 계정에 넣을거라 <code class="language-plaintext highlighter-rouge">sikbook</code>이라고 작명했다.</p>

<p><img width="747" alt="image" src="https://user-images.githubusercontent.com/52439201/183920858-da4caa92-749f-403f-95af-279df3a85f98.png" /></p>

<p>파일 명을 작성하고 엔터를 누르면 비밀번호를 입력하라고 하는데 엔터를 누르고 넘어간다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Enter passphrase <span class="o">(</span>empty <span class="k">for </span>no passphrase<span class="o">)</span>:
Enter same passphrase again:
Your identification has been saved <span class="k">in </span>sikbook
Your public key has been saved <span class="k">in </span>sikbook.pub
The key fingerprint is:
SHA256:aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa your_email@gmail.com
The key<span class="s1">'s randomart image is:
+---[RSA 4096]----+
|          ..+..=+|
|           * +=.+|
|      o   + +E=oo|
|       + . =+@ o=|
|      . S . B+=.+|
|     . .      .o.|
|    .   ..    +  |
|  .. . ....  o . |
| .... .....  .o  |
+----[SHA256]-----+
</span></code></pre></div></div>

<p>여기서 중요한건 <code class="language-plaintext highlighter-rouge">Enter file in which to save the key (/Users/sikbook/.ssh/id_rsa):</code> 이 부분이다. 구분할 수 있는 이름으로 작명해야 등록할 github 계정에 잘 등록할 수 있다.</p>

<p><br /></p>

<ul>
  <li>ls 통해 <code class="language-plaintext highlighter-rouge">.pub</code> 파일과 그냥 파일이 생성된 것을 확인할 수 있다.</li>
  <li><code class="language-plaintext highlighter-rouge">sikbook.pub</code> 파일은 공개키이고</li>
  <li><code class="language-plaintext highlighter-rouge">sikbook</code>은 비밀키이다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">ls</span>
<span class="o">&gt;</span> sikbook   sikbook.pub
</code></pre></div></div>

<p><br /></p>

<h2 id="ssh-key-등록">ssh-key 등록</h2>
<p>ssh-key를 생성했다면 키를 ssh-agent에 록해줘야 한다.
그 이유는, 등록하지 않으면 매번 비밀번호를 입력해야하는 수고스러움이 있기 때문이다.</p>

<p>만약 ssh-agent 가 실행중이라면 한번이라도 push를 할 경우 자동으로 key가 등록되며, key에 비밀번호가 있는 경우에는 최초 한번만 입력하면 된다.</p>

<p>아래와 같이 <code class="language-plaintext highlighter-rouge">ssh-add [생성한 ssh-key의 경로]</code>로 등록하면 된다.</p>

<ul>
  <li>비밀키는 나의 ssh-agent에 등록하는 것이다.</li>
  <li>공개키는 github계정에 등록하는 것이다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># SSH 에이전트 백그라운드로 실행 </span>
<span class="nb">eval</span> <span class="s2">"</span><span class="si">$(</span>ssh-agent <span class="nt">-s</span><span class="si">)</span><span class="s2">"</span>
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ssh-add ~/.ssh/sikbook
</code></pre></div></div>

<p><br /></p>

<p>아래와 같이 나오면 정상 등록 된것이다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Identity added: /Users/sikbook/.ssh/sikbook <span class="o">(</span>sungsik9831@gmail.com<span class="o">)</span>
</code></pre></div></div>

<p><br /></p>

<p>만약 아래와 같이 오류가 발생하면</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Could not open a connection to your authentication agent.
</code></pre></div></div>

<p>아래와 같이 ssh-agent를 다시 실행한다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">eval</span> <span class="si">$(</span>ssh-agent<span class="si">)</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="ssh-config-파일-작성">ssh config 파일 작성</h2>

<p>ssh config파일은 ~/.ssh 위치에서 생성한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>vi ~/.ssh/config
</code></pre></div></div>

<p>아래와 같이 작성하면 된다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Host github.com-[사용할 이름]
  HostName github.com
  IdentityFile <span class="o">[</span>ssh-key 위치]
  User <span class="o">[</span>Github 계정 이름]
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: left">구분</th>
      <th style="text-align: left">내용</th>
      <th style="text-align: left">비고</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Host github.com-[사용할 이름]</td>
      <td style="text-align: left">원하는 이름</td>
      <td style="text-align: left">자주 쓸 이름으로 작명</td>
    </tr>
    <tr>
      <td style="text-align: left">HostName</td>
      <td style="text-align: left">github.com</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">IdentityFile</td>
      <td style="text-align: left">ssh-key 파일 경로</td>
      <td style="text-align: left"> </td>
    </tr>
    <tr>
      <td style="text-align: left">User</td>
      <td style="text-align: left">Github 계정 이름</td>
      <td style="text-align: left"> </td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<h2 id="github-계정에-ssh-key-등록">github 계정에 ssh-key 등록</h2>

<ul>
  <li>등록할 Github 계정 &gt; 우측 상단에 Settings</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/52439201/183929034-2f446d27-a9a8-4a8b-af2e-b2f63b2fc581.png" alt="image" /></p>

<p><br /></p>

<ul>
  <li>SSH and GPG keys &gt; New SSH key</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/52439201/183929365-3d501c0b-7805-4ec9-be99-454abe1de6aa.png" alt="image" /></p>

<p><br /></p>

<ul>
  <li>생성한 공개키를 복사하여 넣어주면 된다.</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>pbcopy &lt; ~/.ssh/sikbook.pub 
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/52439201/183929483-25d307e4-51c7-4872-9261-6a90b0f66292.png" alt="image" /></p>

<p><br /></p>

<ul>
  <li>설정이 완료되면 아래와같이 설정된 키의 모습이 보인다.</li>
</ul>

<p><img src="https://user-images.githubusercontent.com/52439201/183930850-fb4d9a8d-dcfc-4dff-9381-201d5452cc1a.png" alt="image" /></p>

<p><br /></p>

<h2 id="설정이-제대로-연결되었는지-테스트">설정이 제대로 연결되었는지 테스트</h2>

<ul>
  <li>ssh -T [ssh config HOST 명]</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>ssh <span class="nt">-T</span> git@github.com-sikbook
Hi s-seongsik! You<span class="s1">'ve successfully authenticated, but GitHub does not provide shell access.
</span></code></pre></div></div>

<p>위와 같이 출력되면 정상적으로 연결되었다. 하지만, 서로 다른 계정의 github 저장소로 push를 할 경우 github에 등록된 public key와 쌍이되는 private key가 사용될 수 있도록 설정해 줘야한다.</p>

<p><br /></p>

<h2 id="로컬-저장소별로-git-config-파일-수정">로컬 저장소별로 .git config 파일 수정</h2>
<p>이전에 .ssh config에 Host명과 사용될 비밀키를 등록했다.<br />
이번에는 비밀키를 사용하기 위해 git config vkdlfdml remote url 도메인을 ssh에 등록된 <code class="language-plaintext highlighter-rouge">HOST</code>값으로 변경해줘야 한다.</p>

<blockquote>
  <p>git config &gt; remote url값을 ssh config에 등록했던 HOST명으로 작성하지 않으면 Host를 찾을 수 없다거나 Permission 에러가 발생할 수 있다.</p>
</blockquote>

<h3 id="방법-1-직접-git-명령어를-사용해서-값을-변경">방법 1. 직접 git 명령어를 사용해서 값을 변경</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git remote add origin git@[ssh config HOS명]:[Github 계정 이름]/[repository명].git
</code></pre></div></div>

<h3 id="방법-2-로컬-저장소--git--config-파일-수정">방법 2. 로컬 저장소 &gt; .git &gt; config 파일 수정</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>vi .git/config

<span class="o">[</span>core]
        repositoryformatversion <span class="o">=</span> 0
        filemode <span class="o">=</span> <span class="nb">true
        </span>bare <span class="o">=</span> <span class="nb">false
        </span>logallrefupdates <span class="o">=</span> <span class="nb">true
        </span>ignorecase <span class="o">=</span> <span class="nb">true
        </span>precomposeunicode <span class="o">=</span> <span class="nb">true</span>
<span class="o">[</span>remote <span class="s2">"origin"</span><span class="o">]</span>
        url <span class="o">=</span> git@[ssh config HOS명]:[Github 계정 이름]/[repository명].git
        fetch <span class="o">=</span> +refs/heads/<span class="k">*</span>:refs/remotes/origin/<span class="k">*</span>
</code></pre></div></div>

<h3 id="확인">확인</h3>

<p>로컬 저장소 .git &gt; config에서 remote url을 수정했다면 아래와 같이 리모트가 잘 수정되었는지 확인하면 끝이다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git remote <span class="nt">-v</span>
origin  git@github-sikbook:[Github 계정 이름]/[repository명].git <span class="o">(</span>fetch<span class="o">)</span>
origin  git@github-sikbook:[Github 계정 이름]/[repository명].git <span class="o">(</span>push<span class="o">)</span>
</code></pre></div></div>]]></content><author><name>GitHub User</name></author><category term="Git" /><category term="Git" /><category term="Github" /><summary type="html"><![CDATA[문제 발생 최근 맥북프로를 장만하고 git, github을 개인 계정으로만 사용하고 있었다. 8/8일… 최악의 폭우로 인해 2일간 재택근무를 하게 되었다. 회사 업무는 데스크탑으로 했기 때문에 노트북을 사용할 일이 없었지만 급작스러운 재택 때문에 회사 업무관련 개발환경을 전부 셋팅해야 했다.]]></summary></entry><entry><title type="html">[TypeScript] 타입 단언과 가드</title><link href="http://localhost:4000/typescirpt/2022/07/29/typescript-06.html" rel="alternate" type="text/html" title="[TypeScript] 타입 단언과 가드" /><published>2022-07-29T00:00:00+09:00</published><updated>2022-07-29T00:00:00+09:00</updated><id>http://localhost:4000/typescirpt/2022/07/29/typescript-06</id><content type="html" xml:base="http://localhost:4000/typescirpt/2022/07/29/typescript-06.html"><![CDATA[<h2 id="타입-단언">타입 단언</h2>
<p>타입 스크립트는 타입 표기, 가드, 추론 등의 기법으로 값의 타입을 판단한다. 하지만 떄론 컴파일러의 정보를 무시하고 개발자가 원하는 임의의 타입을 할당하고 싶을 수 있다. 이럴 때 사용하는 것이 타입 단언<code class="language-plaintext highlighter-rouge">(type assertion)</code>이다.</p>

<h3 id="타입-단언을-사용하는-이유">타입 단언을 사용하는 이유</h3>
<p>a에 10이라는 값을 할당하면 타입스크립트는 알아서 <code class="language-plaintext highlighter-rouge">number</code> 타입으로 추론하게 된다. 따라서, 변수 b에 a를 할당하면 b역시 <code class="language-plaintext highlighter-rouge">number</code>타입을 갖게 되는 것이다.</p>

<p><img src="https://user-images.githubusercontent.com/52439201/182020229-7b78b6b5-2d43-42d6-b330-131a5d8d9048.png" alt="image" /></p>

<p>하지만, a를 최초 선언 당시 아무 값도 할당하지 않았으므로, 타입스크립트는 a를 <code class="language-plaintext highlighter-rouge">any</code> 타입으로 추론하게 된다. 따라서, b역시 <code class="language-plaintext highlighter-rouge">any</code> 타입으로 추론하는 것이다.</p>

<p><img src="https://user-images.githubusercontent.com/52439201/182020287-c415291f-6d68-4805-bd38-7ccb03b68709.png" alt="image" /></p>

<p>하지만, 개발자들은 마지막 ‘abc’를 할당했으므로 <code class="language-plaintext highlighter-rouge">string</code> 타입을 기대했을 것이다. 이럴 때 사용하는 것이 바로 <code class="language-plaintext highlighter-rouge">타입 단언(type assertion)</code>이다 타입스크립트보다 개발자가 그 타입에 대해 정확하게 알고 있을 때 사용한다고 생각하면 된다. <code class="language-plaintext highlighter-rouge">value as Type</code> 문법을 사용해서 value를 type으로 단언할 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/52439201/182020463-9a58e7dd-42e2-4efd-bae7-46fcf0e7f590.png" alt="image" /></p>

<h3 id="주의할-점">주의할 점</h3>
<p>타입 단언은 타입 에러를 없애줄 분 런타임 에러를 막아주지 못한다. 오히려 그 반대인데, 컴파일타입에서 잡을 수 있는 에러를 없앰으로서 원래대로라면 발생하지 않을 런타임 에러를 발생시킬 수 있다. 아래의 코드를 보자.</p>

<p><img src="https://user-images.githubusercontent.com/52439201/182020799-e43aecf6-5547-48d2-9ac9-172201af1948.png" alt="image" /></p>

<p>유니온 타입은 공통타입이 아닌 타입에 대해서는 에러를 발생시킨다. <code class="language-plaintext highlighter-rouge">weight</code>속성은 dog 타입에만 존재하므로 dog 타입으로 단언하면 타입에러를 없앨 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/52439201/182020877-347ecd31-d4f9-42cb-8969-214ce2b50c12.png" alt="image" /></p>

<p>하지만, 아래와 같이 예상되지 않는 타입의 값이 들어가면 에러가 발생한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">dog</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nx">weight</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">cats</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">test</span> <span class="p">(</span><span class="nx">info</span><span class="p">:</span> <span class="nx">dog</span> <span class="o">|</span> <span class="nx">cats</span><span class="p">){</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">info</span> <span class="k">as</span> <span class="nx">dog</span><span class="p">).</span><span class="nx">weight</span><span class="p">();</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">info</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">10</span>
<span class="p">}</span>

<span class="nx">test</span><span class="p">(</span><span class="nx">info</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/52439201/182021207-d121941e-15ca-4532-a6d3-fb7ef54faf5e.png" alt="image" /></p>

<p><br /></p>

<h2 id="타입-가드">타입 가드</h2>
<p>특정 스코프 내에서 값의 타입을 좁혀나가는 것을 타입 가드라 한다.</p>

<p>타입 가드는 크게 두 종류로 나뉜다.</p>
<ul>
  <li>제어 흐름 분석(control flow analysis)</li>
  <li>사용자 정의 타입 가드(user defined type guard)</li>
</ul>

<h3 id="제어-흐름-분석control-flow-analysis">제어 흐름 분석(control flow analysis)</h3>
<p>기본적으로 자바스크립트는 비동기 실행 코드를 제외하고는 전부 위에서부터 아래로 순차적으로 코드가 실행된다. 대부분의 프로그래밍 언어는 특정 조건이 만족될 때에만 코드를 실행하거나 같은 코들르 여러번 실행하는 식으로 순차적 실행을 벗어난 실행을 가능하게 하는 <code class="language-plaintext highlighter-rouge">제어 구조(control structure)</code>를 제공한다.</p>

<p>자바스크립트와 타입스크립트 또한 제어 구조를 제공한다. 대표적인 제어 구조는 아래와 같다.</p>
<ul>
  <li>if, else if, else</li>
  <li>while, for</li>
  <li>switch, case</li>
  <li>break, continue</li>
  <li>return</li>
</ul>

<p>컴파일러는 위의 제어 구조로부터 특정 시점에서의 상태 정보를 얻는다. 그리고 컴파일러는 이러한 정보를 이용해 <code class="language-plaintext highlighter-rouge">제어 흐름 분석</code>을 진행하여 특정 값의 타입을 좁혀낼 수 있다.
그렇다면, 제어 흐름 분석으로 어떻게 타입을 좁히는지 알아보자.</p>

<h3 id="undefined--null-비교">undefined / null 비교</h3>
<p>undefined 또는 null 과의 비교로 각각 대응하는 타입에 대한 타입 가드로 동작한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">info</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">person</span><span class="p">(</span><span class="nx">info</span><span class="p">:</span> <span class="nx">info</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">info</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="kc">null</span><span class="p">){</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">null</span><span class="dl">'</span>
  <span class="p">}</span><span class="k">else</span> <span class="p">{</span>
    <span class="c1">// info.name 타입은 string</span>
    <span class="k">return</span> <span class="nx">info</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="리터럴-타입-비교">리터럴 타입 비교</h3>
<p>리터럴 타입과의 비교도 타입 가드로 동작한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Human</span> <span class="p">{</span>
  <span class="nl">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">human</span><span class="dl">'</span><span class="p">;</span>
  <span class="nl">sex</span><span class="p">:</span> <span class="dl">'</span><span class="s1">man</span><span class="dl">'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nl">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">animal</span><span class="dl">'</span><span class="p">;</span>
  <span class="nl">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">dog</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">something</span><span class="p">(</span><span class="nx">data</span><span class="p">:</span> <span class="nx">Human</span> <span class="o">|</span> <span class="nx">Animal</span><span class="p">){</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">human</span><span class="dl">'</span><span class="p">:</span> <span class="p">{</span>
      <span class="c1">// data는 Human 타입</span>
      <span class="k">return</span> <span class="nx">data</span><span class="p">.</span><span class="nx">sex</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="dl">'</span><span class="s1">animal</span><span class="dl">'</span><span class="p">:</span> <span class="p">{</span>
      <span class="c1">// data는 Animal 타입</span>
      <span class="k">return</span> <span class="nx">data</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nl">default</span><span class="p">:</span> <span class="p">{</span>
      <span class="c1">// data는 null 타입</span>
      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>공통 리터럴 타입인 <code class="language-plaintext highlighter-rouge">type</code>을 기반으로 switch-case를 통해 각 브랜치에서 타입을 좁힐 수 있다.</p>

<h3 id="typeof-연산자-비교">typeof 연산자 비교</h3>

<p>typeof 연산자는 하나의 인자를 받아 해당 인자의 타입을 문자열로 반환한다. 이를 통해 typeof 반환값과 문자열을 비교한 결과를 타입 가드로 사용할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">something</span><span class="p">(</span><span class="nx">data</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span> <span class="o">|</span> <span class="nx">boolean</span><span class="p">){</span>
  <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">data</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">){</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">string type</span><span class="dl">'</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">data</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">number</span><span class="dl">'</span><span class="p">){</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">string type</span><span class="dl">'</span>
  <span class="p">}</span>

  <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">data</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">boolean</span><span class="dl">'</span><span class="p">){</span>
    <span class="k">return</span> <span class="dl">'</span><span class="s1">string type</span><span class="dl">'</span>
  <span class="p">}</span>

  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="dl">'</span><span class="s1">string or number or boolean 이외의 타입이 들어왔습니다.</span><span class="dl">'</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">typeof</code> 연산자를 사용할 때는 프로그래머의 예상과 다르게 동작한다는 것을 주의해야한다. 흔히 사용되는 타입과 <code class="language-plaintext highlighter-rouge">typeof</code> 연산자의 반환값을 아래의 표로 확인해보자.</p>

<p>하위 호환성 이슈로 <code class="language-plaintext highlighter-rouge">typeof</code> <code class="language-plaintext highlighter-rouge">null</code>은 “null”이 아닌 “object”로 반환된다. 또한 <code class="language-plaintext highlighter-rouge">typeof</code> [] === “array”일 것이란 예상과 달리 배열을 나타내는 별도의 반환값이 존재하지 않는다.
이러한 혼란스러움으로 <code class="language-plaintext highlighter-rouge">typeof</code>로 타입 가드를 사용할 때는 <code class="language-plaintext highlighter-rouge">number</code>, <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">boolean</code>, <code class="language-plaintext highlighter-rouge">symbol</code>과 같이 단순한 타입에 대해서만 사용하는 것을 권장한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">타입</th>
      <th style="text-align: left">typeof 반환값</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Undefined</td>
      <td style="text-align: left">"undefined"</td>
    </tr>
    <tr>
      <td style="text-align: left">Null</td>
      <td style="text-align: left">"object"</td>
    </tr>
    <tr>
      <td style="text-align: left">Boolean</td>
      <td style="text-align: left">"boolean"</td>
    </tr>
    <tr>
      <td style="text-align: left">Number</td>
      <td style="text-align: left">"number"</td>
    </tr>
    <tr>
      <td style="text-align: left">String</td>
      <td style="text-align: left">"string"</td>
    </tr>
    <tr>
      <td style="text-align: left">Symbol</td>
      <td style="text-align: left">"symbol"</td>
    </tr>
    <tr>
      <td style="text-align: left">Function</td>
      <td style="text-align: left">"function"</td>
    </tr>
    <tr>
      <td style="text-align: left">그 외 모든 객체</td>
      <td style="text-align: left">"object"</td>
    </tr>
  </tbody>
</table>

<h3 id="instanceof-연산자-비교">instanceof 연산자 비교</h3>
<p><code class="language-plaintext highlighter-rouge">instanceof</code> 연산자는 값과 생성자를 받아 해당 값의 프로토타입 체인에 해당 생성자가 있는지 확인한다. ES6 클래스는 내부적으로 프로토타입 체인에 기반해 돌아가기 때문에, 클래스의 인스턴스 여부도 <code class="language-plaintext highlighter-rouge">instanceof</code>를 이용하여 타입 가드할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Padder</span> <span class="p">{</span>
  <span class="nx">getPaddingString</span><span class="p">():</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">SpaceRepeatingPadder</span> <span class="k">implements</span> <span class="nx">Padder</span> <span class="p">{</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="k">private</span> <span class="nx">numSpaces</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

  <span class="nx">getPaddingString</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">numSpaces</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">);</span>

  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">StringPadder</span> <span class="k">implements</span> <span class="nx">Padder</span> <span class="p">{</span>

  <span class="kd">constructor</span><span class="p">(</span><span class="k">private</span> <span class="nx">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

  <span class="nx">getPaddingString</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="kd">function</span> <span class="nx">getRandomPadder</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">random</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mf">0.5</span> <span class="p">?</span>
    <span class="k">new</span> <span class="nx">SpaceRepeatingPadder</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="p">:</span>
    <span class="k">new</span> <span class="nx">StringPadder</span><span class="p">(</span><span class="dl">"</span><span class="s2">  </span><span class="dl">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="err">​</span>
<span class="c1">// 이 시점에선 'SpaceRepeatingPadder | StringPadder'</span>
<span class="kd">let</span> <span class="nx">padder</span><span class="p">:</span> <span class="nx">Padder</span> <span class="o">=</span> <span class="nx">getRandomPadder</span><span class="p">();</span>


<span class="k">if</span> <span class="p">(</span><span class="nx">padder</span> <span class="k">instanceof</span> <span class="nx">SpaceRepeatingPadder</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">padder</span><span class="p">);</span> <span class="c1">// SpaceRepeatingPadder 로 좁혀짐</span>
<span class="p">}</span>

<span class="err">​</span>
<span class="k">if</span> <span class="p">(</span><span class="nx">padder</span> <span class="k">instanceof</span> <span class="nx">StringPadder</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">padder</span><span class="p">);</span> <span class="c1">// StringPadder 로 좁혀짐</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="in-연산자-비교">in 연산자 비교</h3>
<p>in 연산자는 객체에 특정 속성이 존재하는지 여부를 판단하는데 사용한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Human</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>


<span class="kd">type</span> <span class="nx">UnionType</span> <span class="o">=</span> <span class="nx">Human</span> <span class="o">|</span> <span class="nx">Animal</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">something</span><span class="p">(</span><span class="nx">data</span><span class="p">:</span> <span class="nx">UnionType</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="dl">'</span><span class="s1">name</span><span class="dl">'</span> <span class="k">in</span> <span class="nx">data</span><span class="p">){</span>
    <span class="c1">// Human Type</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="c1">// Animal Type</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">age</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="사용자-정의-타입-가드">사용자 정의 타입 가드</h3>
<p>지금까지 타입스크립트 언어에 내장된 제어 흐름에 기반하여 동작하는 타입 가드를 살펴봤다. 이 뿐만 아니라 직접 임의의 기준을 사용해 타입 가드를 정의할 수 있는데 이것을 <code class="language-plaintext highlighter-rouge">사용자 정의 타입 가드</code>라 한다.
사용자 정의 타입 가드는 <code class="language-plaintext highlighter-rouge">value is Typ</code>e 형태로 반환 타입을 갖는 <code class="language-plaintext highlighter-rouge">함수</code>로 정의한다.</p>

<p>예를 들어, 위의 in연산자를 통해 타입가드를 사용했다면 특정 <code class="language-plaintext highlighter-rouge">Human</code> 타입인지 확인하는 <code class="language-plaintext highlighter-rouge">isHuman()</code> 함수로 대체할 수 있다.</p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Human</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">Animal</span> <span class="p">{</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>


<span class="kd">type</span> <span class="nx">UnionType</span> <span class="o">=</span> <span class="nx">Human</span> <span class="o">|</span> <span class="nx">Animal</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">isHuman</span><span class="p">(</span><span class="nx">data</span><span class="p">:</span> <span class="nx">UnionType</span><span class="p">):</span> <span class="nx">data</span> <span class="k">is</span> <span class="nx">Human</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">data</span> <span class="k">as</span> <span class="nx">Human</span><span class="p">).</span><span class="nx">name</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">something</span><span class="p">(</span><span class="nx">data</span><span class="p">:</span> <span class="nx">UnionType</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="nx">isHuman</span><span class="p">(</span><span class="nx">data</span><span class="p">)){</span>
    <span class="c1">// Human Type</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">}</span><span class="k">else</span><span class="p">{</span>
    <span class="c1">// Animal Type</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">data</span><span class="p">.</span><span class="nx">age</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="nx">something</span><span class="p">({</span><span class="na">name</span><span class="p">:</span><span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">});</span>
<span class="nx">something</span><span class="p">({</span><span class="na">age</span><span class="p">:</span><span class="mi">10</span><span class="p">});</span>
</code></pre></div></div>]]></content><author><name>GitHub User</name></author><category term="Typescirpt" /><category term="Typescirpt" /><category term="Javascript" /><category term="ES6" /><summary type="html"><![CDATA[타입 단언 타입 스크립트는 타입 표기, 가드, 추론 등의 기법으로 값의 타입을 판단한다. 하지만 떄론 컴파일러의 정보를 무시하고 개발자가 원하는 임의의 타입을 할당하고 싶을 수 있다. 이럴 때 사용하는 것이 타입 단언(type assertion)이다.]]></summary></entry><entry><title type="html">[Javascript] 화살표 함수의 this 바인딩</title><link href="http://localhost:4000/javascript/2022/07/26/javascript-15.html" rel="alternate" type="text/html" title="[Javascript] 화살표 함수의 this 바인딩" /><published>2022-07-26T00:00:00+09:00</published><updated>2022-07-26T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/07/26/javascript-15</id><content type="html" xml:base="http://localhost:4000/javascript/2022/07/26/javascript-15.html"><![CDATA[<h2 id="화살표-함수arrow-function">화살표 함수(Arrow Function)</h2>
<p>ES6가 도입되면서 새롭게 나타난 <code class="language-plaintext highlighter-rouge">화살표 함수(Arrow Function)</code>는 <code class="language-plaintext highlighter-rouge">function</code> 키워드 대신 화살표<code class="language-plaintext highlighter-rouge">(=&gt;)</code>를 사용하여 기존의 전통적인 함수표현<code class="language-plaintext highlighter-rouge">(function)</code>의 간편한 대안으로 새롭게 등장했다.<br />
화살표 함수의 기본 문법은 아래와 같이 작성한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기존</span>
<span class="kd">function</span> <span class="nx">logText</span><span class="p">(</span><span class="nx">text</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 화살표 함수</span>
<span class="kd">const</span> <span class="nx">logText</span> <span class="o">=</span> <span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 매개변수 지정</span>
   <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// 매배변수가 없을 때</span>
   <span class="nx">x</span>  <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// 매개변수가 한 개</span>
<span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// 매개변수가 여러 개, 소괄호를 생략할 수 없다.</span>

<span class="c1">// 함수 몸체 지정</span>
<span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">10</span> <span class="p">}</span> <span class="c1">// single line block</span>
<span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">10</span> <span class="c1">// 함수 몸체가 한 줄의 구문이라면 중괄호를 생략할 수 있으며, 암묵적으로 return</span>

<span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="k">return</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">}};</span> 
<span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span><span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">});</span> <span class="c1">// 객체를 반환 시 소괄호를 사용해야 한다.</span>

<span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>                 <span class="c1">// multi line blok.</span>
    <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이와 같이 기존의 전통적인 함수표현과 화살표 함수는 기능적으로는 동일하다. 하지만 왜 화살표 함수가 등장했으며 사용하는 것일까?
단순하게 함수 표현이 간단하기 때문에 사용하는 것일까?</p>

<p>심지어 화살표 함수는 아래와 같은 조건이 있다.</p>
<ul>
  <li>무조건 익명함수로만 사용해야 한다.</li>
  <li>메소드나 생성자 함수로 사용할 수 없다.</li>
  <li>yield를 화살표 함수 내부에서 사용할 수 없다.</li>
  <li>일반적으로 스코프를 지정할 때 사용하는 call, apply, bind 메서드를 사용할 수 없다.</li>
</ul>

<p>결론부터 말하면, 화살표 함수를 사용하는 이유는 <code class="language-plaintext highlighter-rouge">this 바인딩</code> 때문이다. 
기존의 <code class="language-plaintext highlighter-rouge">this</code> 바인딩과 화살표 함수의 <code class="language-plaintext highlighter-rouge">this</code> 바인딩에는 무슨 차이가 있는지 알아보자.</p>

<p><br /></p>

<h2 id="기존의-함수의-this-바인딩">기존의 함수의 this 바인딩</h2>
<p>화살표 함수가 등장하기 전까지는, 모든 새로운 함수는, 그 함수가 호출되는 방법에 따라서 참조하는 this가 정의되었다.</p>

<ul>
  <li>일반 함수로 호출되는 경우 =&gt; 전역객체를 <code class="language-plaintext highlighter-rouge">this</code></li>
  <li>메소드로서 호출되는 경우 =&gt; 메소드를 호출한 객체를 <code class="language-plaintext highlighter-rouge">this</code></li>
  <li>call, apply, bind 메서드 호출 =&gt; 첫 번째 인자로 넘겨주는 것이 <code class="language-plaintext highlighter-rouge">this</code></li>
</ul>

<p>이렇게 함수 호출 방식에 따라 참조하는 this 객체가 다르기 때문에 킹받는 일이 많다…</p>

<p>가령 아래와 같은 예시를 들 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 일반 함수로서 호출은 전역객체를 this로 참조함</span>
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">address</span> <span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">addr</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">addr</span><span class="p">()</span> 
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">address</span><span class="p">();</span> <span class="c1">// undefined </span>

<span class="c1">// 메서드로서 호출은 그 객체를 this로 참조함</span>
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">address</span> <span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> 
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">address</span><span class="p">();</span> <span class="c1">// siksik</span>
</code></pre></div></div>
<p>첫 번째 함수는</p>

<ul>
  <li>person.address() 메서드가 실행됨.</li>
  <li>addr은 일반 함수로서의 호출이므로 전역객체를 <code class="language-plaintext highlighter-rouge">this</code>로 참조함</li>
  <li>전역객체에는 name이라는 멤버가 존재하지 않으므로 <code class="language-plaintext highlighter-rouge">undefined</code> 출력</li>
</ul>

<p>두 번째 함수는</p>
<ul>
  <li>person.address() 메서드가 실행됨.</li>
  <li>addr은 메서드로서 호출이므로 그 객체를 <code class="language-plaintext highlighter-rouge">this</code>로 참조함</li>
  <li>해당 객체에 name이라는 멤버가 존재하므로 <code class="language-plaintext highlighter-rouge">siksik</code> 출력</li>
</ul>

<p>이렇게 참조 객체를 하나하나 신경쓰는게 짜증나는 경우가 많다.
그래서 등장한 화살표 함수!!</p>

<p><br /></p>

<h2 id="화살표-함수의-this-바인딩">화살표 함수의 this 바인딩</h2>
<p>기존의 함수는 선얼할 때 this에 바인딩할 객체가 호출 방식에 따라 동적으로 결정되었다면, 화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정된다.<br />
쉽게 말해, <code class="language-plaintext highlighter-rouge">화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다.</code> 이를 Lexical this라 한다.  <br />
달리 말하면, <code class="language-plaintext highlighter-rouge">화살표 함수는 자신의 this가 존재하지 않는다!</code></p>

<blockquote>
  <p>자바스크립트는 어떤 식별자(변수)를 탐색할 때 현재 환경에서 그 변수가 없으면 바로 상위 환경을 검색한다. 또 없으면 그 상위, 이렇게 상위 환경으로 변수를 올라가면서 찾으며 가장 최상위 환경에 도달할 때 까지도 찾지 못하면 없다고 결론되는 것이다. 화살표 함수는 자신의 this가 존재하지 않으므로 그 상위 this를 동적으로 참조하게 되는 것이다.</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 일반 함수로서 호출은 전역객체를 this로 참조함</span>
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">address</span> <span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">addr</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">addr</span><span class="p">()</span> 
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">address</span><span class="p">();</span> <span class="c1">// siksik </span>
</code></pre></div></div>

<p><br /></p>

<h2 id="화살표-함수-이럴-땐-사용하지-말자">화살표 함수, 이럴 땐 사용하지 말자</h2>
<p>화살표 함수는 렉시컬 this를 지원하므로 콜백 함수로 사용하기에는 매우~편리하다. 하지만 화살표 함수를 사용하면 오히려 혼란이 오는 경우가 있다.</p>

<h3 id="메소드">메소드</h3>
<p>화살표 함수를 메소드로 정의하는 것은 피해야 한다. 아래의 코드를 보자</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">callName</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">),</span>
<span class="p">}</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">callName</span><span class="p">()</span> <span class="c1">// undefined </span>
</code></pre></div></div>
<p>위 코드를 보면, 메소드로 정의한 화살표 함수의 내부 this는 메소드를 소유한 객체를 참조하지 않고 상위 컨텍스트인 전역 객체를 참조한다. 따라서, 화살표 함수로 메소드를 정의하는 것은 바람직하지 않다.
이럴 땐, 메소드 단축 표기법인 <code class="language-plaintext highlighter-rouge">ES6의 축약 메소드 표현</code>을 사용하는 것이 좋다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">,</span>
  <span class="nx">callName</span><span class="p">(){</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
  <span class="p">},</span>
<span class="p">}</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">callName</span><span class="p">()</span> <span class="c1">// siksik</span>
</code></pre></div></div>

<h3 id="prototype">prototype</h3>
<p>화살표 함수로 정의된 메소드를 prototype에 할당하는 경우도 동일한 문제가 발생한다. 화살표 함수로 정의된 메소드를 prototype에 할당해보면 알 수 있다</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span>
<span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">callName</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">callName</span><span class="p">();</span> <span class="c1">// undefined</span>
</code></pre></div></div>

<p>prototype에 메소드를 할당하는 경우에는 일반 함수를 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span>
<span class="p">};</span>

<span class="nb">Object</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">callName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="p">}</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">callName</span><span class="p">();</span> <span class="c1">// siksik</span>
</code></pre></div></div>

<h3 id="생성자-함수">생성자 함수</h3>
<p>화살표 함수는 생성자 함수로 사용할 수 없다. 기본적으로 new 키워드를 붙이는 생성자 함수는 prototype 프로퍼티를 가지게 된다. 이때 prototype 프로퍼티가 참조하는 prototype 객체의 <code class="language-plaintext highlighter-rouge">constructor</code>를 사용한다.
하지만, 화살표 함수는 prototype 프로퍼티를 가지고 있지 않기 때문에 사용할 수 없는 것이다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">Arrow</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{};</span>
<span class="kd">const</span> <span class="nx">normal</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Arrow</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">prototype</span><span class="dl">'</span><span class="p">))</span> <span class="c1">// false</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">normal</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">(</span><span class="dl">'</span><span class="s1">prototype</span><span class="dl">'</span><span class="p">))</span> <span class="c1">// true</span>

<span class="kd">const</span> <span class="nx">Arrow2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Arrow</span><span class="p">();</span> <span class="c1">// TypeError: Arrow is not a constructor</span>
<span class="kd">const</span> <span class="nx">normal2</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">normal</span><span class="p">();</span> <span class="c1">// 생성 완료!</span>
</code></pre></div></div>

<h3 id="addeventlistener-함수의-콜백-함수">addEventListener 함수의 콜백 함수</h3>
<p><code class="language-plaintext highlighter-rouge">addEventListener</code> 함수의 콜백 함수를 화살표 함수로 정의하면 this가 상위 객체를 참조하기 때문에 전역 객체인 window를 참조한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">button</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myButton</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">button</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nb">window</span><span class="p">);</span> <span class="c1">// true</span>
<span class="p">});</span>
</code></pre></div></div>

<p>addEventListener 함수의 콜백 함수 내에서 this를 사용하는 경우에는 일반 함수를 사용해야 함수 내부의 <code class="language-plaintext highlighter-rouge">this</code>가 해당 이벤트 리스너에 바인딩된 <code class="language-plaintext highlighter-rouge">요소(currentTarget)</code>를 가르킨다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">button</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="dl">'</span><span class="s1">myButton</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">button</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="dl">'</span><span class="s1">click</span><span class="dl">'</span><span class="p">,</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">button</span><span class="p">);</span> <span class="c1">// true</span>
<span class="p">});</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="정리해서">정리해서</h2>

<p>화살표 함수를 사용하는 이유에 대해서 알아봤다. 정리해서, 화살표 함수를 사용하는 이유는 자바스크립트의 this 때문에 사용한다고 결론내리면 된다.<br />
하지만, 그렇다고 <code class="language-plaintext highlighter-rouge">무조건 화살표 함수만 사용해야지~</code>는 절대 금지!!! 상황에 따라서 사용하자.</p>]]></content><author><name>GitHub User</name></author><category term="Javascript" /><category term="Javascript" /><category term="ES6" /><summary type="html"><![CDATA[화살표 함수(Arrow Function) ES6가 도입되면서 새롭게 나타난 화살표 함수(Arrow Function)는 function 키워드 대신 화살표(=&gt;)를 사용하여 기존의 전통적인 함수표현(function)의 간편한 대안으로 새롭게 등장했다. 화살표 함수의 기본 문법은 아래와 같이 작성한다.]]></summary></entry><entry><title type="html">[TypeScript] Union and Intersection Types</title><link href="http://localhost:4000/typescirpt/2022/07/19/typescript-05.html" rel="alternate" type="text/html" title="[TypeScript] Union and Intersection Types" /><published>2022-07-19T00:00:00+09:00</published><updated>2022-07-19T00:00:00+09:00</updated><id>http://localhost:4000/typescirpt/2022/07/19/typescript-05</id><content type="html" xml:base="http://localhost:4000/typescirpt/2022/07/19/typescript-05.html"><![CDATA[<h2 id="유니온-타입union-type">유니온 타입(Union Type)</h2>
<p>유니온 타입이란, 자바스크립트의 OR 연산자(<code class="language-plaintext highlighter-rouge">||</code>)와 같은 의미를 갖는다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">union</span> <span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nb">Number</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">union</span><span class="p">(</span><span class="dl">'</span><span class="s1">10</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// string</span>
<span class="nx">union</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// number</span>
</code></pre></div></div>

<p>위 함수에 유니온 타입을 적용하면 파라미터 name에는 <code class="language-plaintext highlighter-rouge">문자열</code>과 <code class="language-plaintext highlighter-rouge">숫자 타입</code> 모두 올 수 있다. 이처럼 <code class="language-plaintext highlighter-rouge">|</code> 연산자를 이용하여 타입을 여러 개 연결하는 방식을 유니온 타입 정의 방식이라고 부른다.</p>

<h3 id="유니온-타입union-type을-사용하는-이유">유니온 타입(Union Type)을 사용하는 이유</h3>

<p>유니온 타입을 사용하는 이유를 코드를 보면 이해하기 쉽다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">padLeft</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">padding</span><span class="p">:</span> <span class="kr">any</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">padding</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">padding</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">`Expected string or number, got '</span><span class="p">${</span><span class="k">typeof</span> <span class="nx">padding</span><span class="p">}</span><span class="s2">'.`</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="nx">padLeft</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello world</span><span class="dl">"</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// returns "    Hello world"</span>
<span class="nx">padLeft</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello world</span><span class="dl">"</span><span class="p">,</span> <span class="dl">'</span><span class="s1">4</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// returns "    Hello world"</span>
<span class="nx">padLeft</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello world</span><span class="dl">"</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span> <span class="c1">// Expected string or number, got 'boolean'.</span>
</code></pre></div></div>

<p>위의 코드를 보면 파라미터 padding에는 <code class="language-plaintext highlighter-rouge">string</code>과 <code class="language-plaintext highlighter-rouge">number</code> 타입 둘다 들어올 수 있기 떄문에 <code class="language-plaintext highlighter-rouge">any</code> 타입으로 지정했다. 하지만, 문제는 <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">number</code> 타입 이외에 타입이 들어오면 에러를 발생시킨다.</p>

<p>이럴때! 아래와 같이 유니온 타입을 지정해서 사용하면 문제를 해결할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">padLeft</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">padding</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">padding</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">padding</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">`Expected string or number, got '</span><span class="p">${</span><span class="k">typeof</span> <span class="nx">padding</span><span class="p">}</span><span class="s2">'.`</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="nx">padLeft</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello world</span><span class="dl">"</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span> <span class="c1">// 'boolean' 형식의 인수는 'string | number' 형식의 매개 변수에 할당될 수 없습니다.</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="공통-타입이-있는-유니온union-type">공통 타입이 있는 유니온(Union Type)</h2>
<p>유니온 타입을 사용할 때 주의해야할 점은 만약 공통적인 타입 유형이 있는 경우에는 모든 유형에 대해 유효한 경우에만 엑세스할 수 있다는 것이다.</p>

<p>아래의 코드를 보면 더 쉽게 이해할 수 있다.</p>

<h3 id="예제1">예제1</h3>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">person</span> <span class="p">{</span>
  <span class="nx">name</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">age</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kr">interface</span> <span class="nx">person2</span> <span class="p">{</span>
  <span class="nx">name</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">address</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">getSmallPet</span><span class="p">():</span> <span class="nx">person</span> <span class="o">|</span> <span class="nx">person2</span><span class="p">;</span>
 
<span class="kd">let</span> <span class="nx">human</span> <span class="o">=</span> <span class="nx">getSmallPet</span><span class="p">();</span>
<span class="nx">human</span><span class="p">.</span><span class="nx">name</span><span class="p">();</span>
 
<span class="c1">// Only available in one of the two possible types</span>
<span class="nx">human</span><span class="p">.</span><span class="nx">address</span><span class="p">();</span> <span class="c1">// type error</span>
</code></pre></div></div>

<p>OR 조건이라며? 근데 왜 공통적인 멤버만 엑세스할 수 있는거지?! 라고 생각할 수 있다.
나도 처음엔 전부 사용할 수 있는 줄 알았지만, 타입스크립트는 불확실한 타입에 대해서는 모두 에러로 처리한다.</p>

<p>반대로 생각해보면, age만 들어올 수도 있고 addres만 들어올 수 있는 가능성이 있으므로 타입스크립트는 이러한 애매한 타입에 대해서는 과감하게 배재시키는 것 같다.
따라서, 타입스크립트에서는 좀더 직관적인 관점으로 바라볼 필요가 있다.</p>

<h3 id="예제2">예제2</h3>

<p>아래 예제 코드도 마찬가지로 Union의 모든 타입이 유효한 경우에만 작업을 허용한다.
예를 들어, <code class="language-plaintext highlighter-rouge">string</code> 타입에서만 사용할 수 있는 메서드를 <code class="language-plaintext highlighter-rouge">number | string</code>에서는 사용할 수 없다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">printId</span><span class="p">(</span><span class="nx">id</span><span class="p">:</span> <span class="kr">number</span> <span class="o">|</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">id</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// 'string | number' 형식에 'toUpperCase' 속성이 없습니다.</span>
<span class="c1">// 'number' 형식에 'toUpperCase' 속성이 없습니다.</span>
</code></pre></div></div>

<h3 id="해결책">해결책</h3>

<p>해결책은 코드와의 결합을 좁히는 것이다. 좁히는 방법은 타입스크립트의 코드 구조를 기반으로 값에 대해 보다 구체적인 유형을 추론할 수 있도록 해주는 것이다.</p>

<p>예를 들어 타입스크립트 값에는 오직 <code class="language-plaintext highlighter-rouge">string</code>이 있다는 것을 알고 싶다면 <code class="language-plaintext highlighter-rouge">typeof "string"</code> 조건을 사용하는 것이다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">printId</span><span class="p">(</span><span class="nx">id</span><span class="p">:</span> <span class="kr">number</span> <span class="o">|</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">id</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">id</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 여기는, id는 number 타입이다.</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">printId</span><span class="p">(</span><span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// STRING</span>
<span class="nx">printId</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="c1">// 100</span>
</code></pre></div></div>

<p>이처럼 해당 타입을 확실히 허용할 수 있는 조건을 걸어주면 해당 타입으로 작업을 진행할 수 있다.</p>

<p><br /></p>

<h2 id="discriminating-unions">Discriminating Unions</h2>
<p>공용체 작업을 위한 일반적인 기술은 타입스크립트가 현재 유형을 좁히는 데 사용할 수 있는 리터럴 타입을 사용하는 단일 필드를 갖는 것이다.</p>

<p>예를 들어, <code class="language-plaintext highlighter-rouge">state</code>라는 단일 공유 필드가 있는 세 가지 유형의 공용체를 만들 것이다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">LoadingState</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">state</span><span class="p">:</span> <span class="dl">'</span><span class="s1">loading</span><span class="dl">'</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">type</span> <span class="nx">FaildState</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">state</span><span class="p">:</span> <span class="dl">'</span><span class="s1">failed</span><span class="dl">'</span><span class="p">;</span>
  <span class="nl">code</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">type</span> <span class="nx">SuccessState</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">state</span><span class="p">:</span> <span class="dl">'</span><span class="s1">success</span><span class="dl">'</span><span class="p">;</span>
  <span class="nl">response</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">duration</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">summary</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">workState</span> <span class="o">=</span> 
  <span class="o">|</span> <span class="nx">LoadingState</span>
  <span class="o">|</span> <span class="nx">FaildState</span>
  <span class="o">|</span> <span class="nx">SuccessState</span><span class="p">;</span>
</code></pre></div></div>

<p>위의 모든 유형에는 <code class="language-plaintext highlighter-rouge">state</code>라는 공통의 필드가 있으며 고유한 필드도 존재한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">LoadingState</th>
      <th style="text-align: left">FaildState</th>
      <th style="text-align: left">SuccessState</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">state</td>
      <td style="text-align: left">state</td>
      <td style="text-align: left">state</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left">code</td>
      <td style="text-align: left">response</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">state</code> 필드가 모든 유형에서 공통적으로 들어있다는 것을 감안했을 때, <code class="language-plaintext highlighter-rouge">workState</code> 코드에서는 존재 유무 확인없이 엑세스하는 것이 안전하다.</p>

<p><code class="language-plaintext highlighter-rouge">state</code>를 리터럴 타입으로 사용하면, 해당 문자열과 <code class="language-plaintext highlighter-rouge">state</code>값을 비교할 수 있다.
또한, state는 현재 타입스크립트에서 사용 중인 유형인 것을 알 수 있다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">LoadingState</th>
      <th style="text-align: left">FaildState</th>
      <th style="text-align: left">SuccessState</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">"loading"</td>
      <td style="text-align: left">"failed"</td>
      <td style="text-align: left">"success"</td>
    </tr>
  </tbody>
</table>

<p>이 경우, <code class="language-plaintext highlighter-rouge">switch</code>문을 사용하여 런타임에 표시되는 유형을 좁힐 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">workState</span> <span class="o">=</span> 
  <span class="o">|</span> <span class="nx">LoadingState</span>
  <span class="o">|</span> <span class="nx">FaildState</span>
  <span class="o">|</span> <span class="nx">SuccessState</span><span class="p">;</span>


<span class="kd">function</span> <span class="nx">logger</span><span class="p">(</span><span class="nx">state</span><span class="p">:</span> <span class="nx">workState</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  
  <span class="k">switch</span> <span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">loading</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">"</span><span class="s2">Downloading...</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">failed</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="s2">`Error </span><span class="p">${</span><span class="nx">state</span><span class="p">.</span><span class="nx">code</span><span class="p">}</span><span class="s2"> downloading`</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">success</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="s2">`Downloaded </span><span class="p">${</span><span class="nx">state</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nx">state</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">duration</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nx">state</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">summary</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">loading</span><span class="p">:</span> <span class="nx">workState</span> <span class="o">=</span> <span class="p">{</span><span class="na">state</span><span class="p">:</span><span class="dl">'</span><span class="s1">loading</span><span class="dl">'</span><span class="p">};</span>
<span class="kd">const</span> <span class="nx">failed</span><span class="p">:</span> <span class="nx">workState</span> <span class="o">=</span> <span class="p">{</span><span class="na">state</span><span class="p">:</span><span class="dl">'</span><span class="s1">failed</span><span class="dl">'</span><span class="p">,</span> <span class="na">code</span><span class="p">:</span><span class="mi">200</span><span class="p">};</span>
<span class="kd">const</span> <span class="nx">success</span><span class="p">:</span> <span class="nx">workState</span> <span class="o">=</span> <span class="p">{</span><span class="na">state</span><span class="p">:</span><span class="dl">'</span><span class="s1">success</span><span class="dl">'</span><span class="p">,</span> <span class="na">response</span><span class="p">:{</span><span class="na">title</span><span class="p">:</span><span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">,</span> <span class="na">duration</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="na">summary</span><span class="p">:</span><span class="dl">'</span><span class="s1">success!!!</span><span class="dl">'</span><span class="p">}};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">logger</span><span class="p">(</span><span class="nx">loading</span><span class="p">))</span> <span class="c1">// Downloading...</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">logger</span><span class="p">(</span><span class="nx">failed</span><span class="p">))</span>  <span class="c1">// Error 200 downloading</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">logger</span><span class="p">(</span><span class="nx">success</span><span class="p">))</span> <span class="c1">// Downloaded test - 10 - success!!!</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="인터섹션-타입intersection-type">인터섹션 타입(Intersection Type)</h2>
<p>인터섹션 타입은 유니온 타입과 다르게 어려 타입을 모두 만족하는 하나의 타입을 의미한다.</p>

<p>아래의 코드를 보자.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">NetError</span> <span class="p">{</span>
  <span class="nl">success</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
  <span class="nl">error</span><span class="p">?:</span> <span class="p">{</span> <span class="na">message</span><span class="p">:</span> <span class="kr">string</span> <span class="p">};</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">networking</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">networkingResponse</span> <span class="o">=</span> <span class="nx">networking</span> <span class="o">&amp;</span> <span class="nx">NetError</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">handleNetworking</span> <span class="o">=</span> <span class="p">(</span><span class="nx">response</span><span class="p">:</span> <span class="nx">networkingResponse</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">error</span><span class="p">:</span> <span class="nx">networkingResponse</span> <span class="o">=</span>  <span class="p">{</span> <span class="na">success</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="na">error</span><span class="p">:</span> <span class="p">{</span><span class="na">message</span><span class="p">:</span> <span class="dl">'</span><span class="s1">500</span><span class="dl">'</span><span class="p">},</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">통신</span><span class="dl">'</span><span class="p">}</span>
<span class="kd">const</span> <span class="nx">success</span><span class="p">:</span> <span class="nx">networkingResponse</span> <span class="o">=</span>  <span class="p">{</span> <span class="na">success</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">통신</span><span class="dl">'</span><span class="p">}</span>

<span class="c1">// error</span>
<span class="nx">handleNetworking</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="c1">// 500</span>
<span class="c1">//success</span>
<span class="nx">handleNetworking</span><span class="p">(</span><span class="nx">success</span><span class="p">)</span> <span class="c1">// 통신</span>
</code></pre></div></div>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">success</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
  <span class="nl">error</span><span class="p">?:</span> <span class="p">{</span> <span class="na">message</span><span class="p">:</span> <span class="kr">string</span> <span class="p">};</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
<p>이처럼 <code class="language-plaintext highlighter-rouge">&amp;</code> 연산자를 이용해 여러 개의 타입 정의를 하나로 합치는 방식을 인터섹션 타입 정의 방식이라고 한다.</p>]]></content><author><name>GitHub User</name></author><category term="Typescirpt" /><category term="Typescirpt" /><category term="Javascript" /><category term="ES6" /><summary type="html"><![CDATA[유니온 타입(Union Type) 유니온 타입이란, 자바스크립트의 OR 연산자(||)와 같은 의미를 갖는다.]]></summary></entry><entry><title type="html">[TypeScript] 타입스크립트의 추론, 호환, 별칭</title><link href="http://localhost:4000/typescirpt/2022/07/13/typescript-04.html" rel="alternate" type="text/html" title="[TypeScript] 타입스크립트의 추론, 호환, 별칭" /><published>2022-07-13T00:00:00+09:00</published><updated>2022-07-13T00:00:00+09:00</updated><id>http://localhost:4000/typescirpt/2022/07/13/typescript-04</id><content type="html" xml:base="http://localhost:4000/typescirpt/2022/07/13/typescript-04.html"><![CDATA[<h2 id="타입-추론tpye-inference">타입 추론(Tpye Inference)</h2>
<p>타입 추론이란, 타입스크립트가 코드를 해석해 나가는 동작을 의미한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span><span class="p">);</span> <span class="c1">// number</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// string</span>
</code></pre></div></div>

<p>위와 같이 <code class="language-plaintext highlighter-rouge">x</code>와 <code class="language-plaintext highlighter-rouge">y</code>에 타입을 따로 지정하지 않더라도 x는 number로 y는 string 타입으로 간주한다. 변수를 선언하거나 초기화 단계에서 타입이 추론된다.
이외에도 변수, 속성, 인자의 기본 값, 함수의 반환 값 등을 설정할 때 타입 추론이 일어난다.</p>

<h3 id="best-common-type">Best Common Type</h3>
<p>타입은 보통 몇 개의 표현식을 바탕으로 타입을 추론한다. 해당 표현식을 이용하여 가장 근접한 타입을 추론하는데 이 때 가장 근전합 타입을 <code class="language-plaintext highlighter-rouge">Best Common Type</code>이라고 한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">le</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">null</span><span class="p">];</span>
</code></pre></div></div>

<p>위 변수 <code class="language-plaintext highlighter-rouge">arr</code>의 타입을 추론하기 위해서는 배열의 값들을 살펴봐야 한다. 배열안에 있는 값들은 <code class="language-plaintext highlighter-rouge">number</code>과 <code class="language-plaintext highlighter-rouge">null</code> 타입으로 구분된다.
이 때 <code class="language-plaintext highlighter-rouge">Best Common Type</code> 알고리즘으로 다른 타입들과 가장 잘 호환되는 타입을 선정한다.</p>

<p><br /></p>

<h3 id="문맥에-맞는-타이핑contextual-typing">문맥에 맞는 타이핑(Contextual Typing)</h3>
<p>타입스크립트는 경우에 따라 또 다른 방식으로 타입을 결정한다. 이것을 <code class="language-plaintext highlighter-rouge">컨텍스트 타이핑</code>이라고 한다. 이 컨텍스트 타이핑은 코드 위치를 기준으로 결정한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onmousedown</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">mouseEvent</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">mouseEvent</span><span class="p">.</span><span class="nx">button</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">mouseEvent</span><span class="p">.</span><span class="nx">kangaroo</span><span class="p">);</span>
<span class="c1">// Property 'kangaroo' does not exist on type 'MouseEvent'.</span>
<span class="p">};</span>
</code></pre></div></div>
<p>위 코드를 타입스크립트 검사기 관점으로 본다면 <code class="language-plaintext highlighter-rouge">window.onmousedown</code>에 할당되는 함수의 타입을 추론하기 위해서 <code class="language-plaintext highlighter-rouge">window.onmousedown</code> 타입을 검사한다.
타입 검사가 끝나면 함수의 타입이 마우스 이벤트와 연관 있다고 추론하기 때문에 <code class="language-plaintext highlighter-rouge">mouseEvent</code> 인자에 button 속성은 존재하지만 kangaroo 속성은 없다고 결론을 내린다.</p>

<p><br /></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onscroll</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">uiEvent</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uiEvent</span><span class="p">.</span><span class="nx">button</span><span class="p">);</span>
<span class="c1">// Property 'button' does not exist on type 'Event'.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 다른 예제를 살펴보면 타입스크립트는 오른쪽 함수는 <code class="language-plaintext highlighter-rouge">window.onscroll</code>에 할당되었기 때문에 <code class="language-plaintext highlighter-rouge">uiEvent</code>는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent">UIEvent</a>로 알고 있다. 따라서, 이전 예제와 같이 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent">MouseEvent</a>와 다르게 <code class="language-plaintext highlighter-rouge">button</code> 속성이 없다고 추론하기 때문에 속성이 없다고 결론내리는 것이다.</p>

<p><br /></p>

<p>실제로 uiEvent에는 어떤 속성들이 있는지 확인해보자.
크롬 콘솔창에 window를 입력하면 아래와같이 전역객체의 속성들이 쭈~욱 나온다. 거기서 onscroll을 보면 <code class="language-plaintext highlighter-rouge">null</code>로 되어있을 것이다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span> <span class="c1">// 크롬 콘솔에 입력</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/52439201/178660218-b88b4bcd-3909-47d8-a46a-762958e5666e.png" alt="image" /></p>

<p><br /></p>

<p>그리고 아래와 같이 입력 후 마우스 스크롤을 움직여 보면 아래와 같이 속성값들을 확인할 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onscroll</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">uiEvent</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uiEvent</span><span class="p">);</span>
<span class="c1">// Property 'button' does not exist on type 'Event'.</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/52439201/178660569-85c50ba8-6cfe-4171-892d-8483668f5f16.png" alt="image" /></p>

<p><br /></p>

<p><code class="language-plaintext highlighter-rouge">컨텍스트 타이핑</code>을 더 이해하기 위해서는 아래와 같이 코드를 바꿔서 확인해보자.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">uiEvent</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uiEvent</span><span class="p">.</span><span class="nx">button</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 예제코드와 동일하지만, 함수에 할당되는 변수만으로는 타입을 추론하기 어렵다. 그렇기 때문에 타입스크립트는 에러로 발생시키지 않는다.</p>

<blockquote>
  <p><strong>참고!</strong><br />
현재 uiEvent 인자에 타입을 지정하지 않아도 에러가 발생하지 않는다. 단, 타입스크립트 config에 –noImplicitAny 옵션을 true로 지정하면 에러가 발생한다.</p>
</blockquote>

<p><br /></p>

<h3 id="타입스크립트의-타입-체킹">타입스크립트의 타입 체킹</h3>

<p>타입 체킹에 있어 타입스크립트의 지향점은 타입 체크는 값의 형태에 기반하여 이루어져야 한다는 점이다.<br />
이것을 <code class="language-plaintext highlighter-rouge">Duck Typing</code> 또는 <code class="language-plaintext highlighter-rouge">Structural Subtyping</code>이라고 한다.</p>

<ul>
  <li>Duck Typing: 객체의 변수 및 메서드의 집합이 객체의 타입을 결정하는 것을 의미한다. 동적 타이핑의 한 종류</li>
  <li>Structural Subtyping: 객체의 실제 구조나 정의에 따라 타입을 결정하는 것을 의미한다.</li>
</ul>

<p><br /></p>

<h2 id="타입-호환type-compatibility">타입 호환(Type Compatibility)</h2>
<p>타입 호환이란 타입스크립트에서 특정 타입이 다른 타입에 잘 맞는지를 의미한다.</p>

<p>예를 들어 아래와 같은 코드를 의미한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Ironman</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Avengers</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">i</span><span class="p">:</span> <span class="nx">Ironman</span><span class="p">;</span>
<span class="nx">i</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Avengers</span><span class="p">();</span> <span class="c1">// OK, because of structural typing</span>


<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
</code></pre></div></div>

<p>C#, java와 같은 코드였다면 에러가 발생했을 것이다. 그 이유는 Avengers 클래스가 명시적으로 Ironman 인터페이스를 상속받은게 아니기 때문이다.</p>

<p>하지만, 자바스크립트는 정상적으로 동작한다.</p>

<p>그이유는, 자바스크립트의 작동 방식과 관련이 있다. 기본적으로 자바스크립트는 객체 리터럴이나 익명 함수 등을 사용하기 때문에 명시적으로 타입을 지정는 것보다는 코드의 구조 관점에서 타입울 지정하는 것이 잘 어울린다.</p>

<h3 id="구조적-타이핑">구조적 타이핑</h3>
<p>구조적 타이핑이란(structural typing)이란 코드 구조 관점에서 타입이 서로 호환되는지 여부를 판단하는 것이다.</p>

<p>아래 코드를 보자.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Avengers</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">hero</span><span class="p">:</span> <span class="nx">Avengers</span><span class="p">;</span>
<span class="c1">// 타입스크립트가 추론한 y의 타입은 { name: string; location: string; } 입니다.</span>
<span class="kd">let</span> <span class="nx">capt</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Captain</span><span class="dl">"</span><span class="p">,</span> <span class="na">location</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Pangyo</span><span class="dl">"</span> <span class="p">};</span>
<span class="nx">hero</span> <span class="o">=</span> <span class="nx">capt</span><span class="p">;</span>
</code></pre></div></div>

<p>위 코드에서 capt가 hero 타입에 호환될 수 있는 이유는 <code class="language-plaintext highlighter-rouge">capt</code> 속성 중에 <code class="language-plaintext highlighter-rouge">name</code>이 있기 때문이다. 만약에 name이 없다면 타입에러를 발생시킨다.
즉, <code class="language-plaintext highlighter-rouge">Avengers</code> 인터페이스에서 name 속성 값을 가지고 있기 때문에 capt는 Avengers에 호환될 수 있던 것이다.</p>

<p>함수를 호출할 때도 마찬가지로 작동한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Avengers</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// capt 변수 타입은 { name: string; location: string; }</span>
<span class="kd">let</span> <span class="nx">capt</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Captain</span><span class="dl">"</span><span class="p">,</span> <span class="na">location</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Pangyo</span><span class="dl">"</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">assemble</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">Avengers</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">어벤져스 모여라</span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">assemble</span><span class="p">(</span><span class="nx">capt</span><span class="p">);</span> <span class="c1">// 어벤져스 모여라 Captain</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="soundness">Soundness</h3>
<p>타입스크립트는 컴파일 시점에서 타입을 추론할 수 없는 특정 타입에 경우는 일단 안전하다고 보는 특성이 있다. 
이걸 <code class="language-plaintext highlighter-rouge">"들리지 않는다(it is said to not be sound)"</code>라고 표현한다.</p>

<p><br /></p>

<h3 id="enum-타입-호환시-주의">Enum 타입 호환시 주의</h3>
<p>이넘 타입은 <code class="language-plaintext highlighter-rouge">number</code> 타입과 호환되지만 이넘 타입끼리는 호환되지 않는다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Status</span> <span class="p">{</span> <span class="nx">Ready</span><span class="p">,</span> <span class="nx">Waiting</span> <span class="p">};</span>
<span class="kr">enum</span> <span class="nx">Color</span> <span class="p">{</span> <span class="nx">Red</span><span class="p">,</span> <span class="nx">Blue</span><span class="p">,</span> <span class="nx">Green</span> <span class="p">};</span>

<span class="kd">let</span> <span class="nx">ready</span> <span class="o">=</span> <span class="nx">Status</span><span class="p">.</span><span class="nx">Ready</span>
<span class="nx">ready</span> <span class="o">=</span> <span class="nx">Color</span><span class="p">.</span><span class="nx">Red</span> <span class="c1">// Error</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="class-타입-호환시-주의">Class 타입 호환시 주의</h3>
<p>클래스 타입은 클래스 타입끼리 비교할 때 스태틱 멤버(static member)와 생성자(constructor)를 제외하고 속성만 비교한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Hulk</span> <span class="p">{</span>
  <span class="nl">handSize</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">numHand</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Captain</span> <span class="p">{</span>
  <span class="nl">handSize</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">numHand</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Iron</span> <span class="p">{</span>
  <span class="nl">footSize</span> <span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">numHand</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">hulk</span><span class="p">:</span> <span class="nx">Hulk</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">capt</span><span class="p">:</span> <span class="nx">Captain</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">iron</span> <span class="p">:</span> <span class="nx">Iron</span><span class="p">;</span>

<span class="nx">hulk</span> <span class="o">=</span> <span class="nx">capt</span><span class="p">;</span> <span class="c1">// ok</span>
<span class="nx">capt</span> <span class="o">=</span> <span class="nx">hulk</span><span class="p">;</span> <span class="c1">// ok</span>
<span class="nx">iron</span> <span class="o">=</span> <span class="nx">hulk</span><span class="p">;</span> <span class="c1">// 'footSize' 속성이 'Hulk' 형식에 없지만 'Iron' 형식에서 필수입니다.</span>
</code></pre></div></div>

<p>Hulk와 Captain은 생성자는 다르지만 속성은 똑같기 때문에 호환에 문제가 없다. 하지만, Iron과 Captaindms 생성자는 동일하지만 속성은 다르기 때문에 오류가 발생한다.</p>

<p><br /></p>

<h3 id="generics">Generics</h3>

<p>제네릭은 제네릭 타입 간의 호환 여부를 판단할 때 타입 인자 <code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>가 속성에 할당 되었는지를 기준으로 판단한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Empty</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">x</span><span class="p">:</span> <span class="nx">Empty</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">y</span><span class="p">:</span> <span class="nx">Empty</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">;</span>

<span class="nx">x</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>  <span class="c1">// OK, because y matches structure of x</span>
</code></pre></div></div>

<p>위의 인터페이스는 속성(member 변수)가 없기 때문에 x와 y를 같은 타입으로 간주한다.<br />
하지만 아래와 같이 인터페이스에 속성이 있다면 제네릭의 타입 인자가 속성에 할당되기 때문에 x와 y는 서로 다른 타입으로 간주된다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Empty</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">data</span> <span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">x</span><span class="p">:</span> <span class="nx">Empty</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">y</span><span class="p">:</span> <span class="nx">Empty</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">;</span>

<span class="nx">x</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>  <span class="c1">// 'Empty&lt;string&gt;' 형식은 'Empty&lt;number&gt;' 형식에 할당할 수 없습니다.</span>
        <span class="c1">// 'string' 형식은 'number' 형식에 할당할 수 없습니다</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="타입-별칭type-aliases">타입 별칭(Type Aliases)</h2>
<p>타입 별칭은 특정 타입이나 인터페이스를 참조할 수 있는 타입 변수를 의미한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// string 타입을 사용할 때</span>
<span class="kd">const</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// 타입 별칭을 사용할 때</span>
<span class="kd">type</span> <span class="nx">MyName</span> <span class="o">=</span> <span class="kr">string</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">name</span><span class="p">:</span> <span class="nx">MyName</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<p>간단한 타입 뿐만 아니라 <code class="language-plaintext highlighter-rouge">interface</code> 레벨의 복잡한 타입에서도 별칭을 부여할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">intro</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">address</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">who</span><span class="p">:</span> <span class="nx">intro</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">address</span><span class="p">:</span> <span class="dl">'</span><span class="s1">seoul</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="타입-별칭의-특징">타입 별칭의 특징</h3>
<p>타입 별칭을 사용하는 이유는, 타입 값을 새로 생성하는 의미보다는 별칭을 부여하여 나중에 쉽게 참고할 수 있도록 이름을 사용하는 것이다.<br />
이러한 특징이 VSCode 상의 프리뷰 상태로 다른 타입과 어떤 차이점이 있는지 확인해볼 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/52439201/179450019-71bf6ec8-d1a8-4229-a541-cda1be7ad1b3.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/52439201/179450095-62e4898f-7cae-4040-8463-a6a50d0b9c7a.png" alt="image" /></p>

<h3 id="type-vs-interface">type vs interface</h3>
<p>타입 별칭과 인터페이스의 가장 큰 차이는 타입의 <code class="language-plaintext highlighter-rouge">확장 여부(가능/불가능)</code>이다.<br />
인터페이스는 확장이 가능한 반면 타입 별칭은 확장이 불가능하다. 따라서, 가능하면 <code class="language-plaintext highlighter-rouge">type</code> 보다는 <code class="language-plaintext highlighter-rouge">interface</code>를 사용하는 것을 추천한다.</p>]]></content><author><name>GitHub User</name></author><category term="Typescirpt" /><category term="Typescirpt" /><category term="Javascript" /><category term="ES6" /><summary type="html"><![CDATA[타입 추론(Tpye Inference) 타입 추론이란, 타입스크립트가 코드를 해석해 나가는 동작을 의미한다.]]></summary></entry><entry><title type="html">[TypeScript] 변수와 함수 타입 정의</title><link href="http://localhost:4000/typescirpt/2022/07/05/typescript-03.html" rel="alternate" type="text/html" title="[TypeScript] 변수와 함수 타입 정의" /><published>2022-07-05T00:00:00+09:00</published><updated>2022-07-05T00:00:00+09:00</updated><id>http://localhost:4000/typescirpt/2022/07/05/typescript-03</id><content type="html" xml:base="http://localhost:4000/typescirpt/2022/07/05/typescript-03.html"><![CDATA[<h2 id="자바스크립트에-타입-추가하는-방법">자바스크립트에 타입 추가하는 방법</h2>

<p>밑의 자바스크립트에서 sum이라는 함수에 들어가는 파라미터 a,b에 타입을 지정해줄 수 있는 방법이 있다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="dl">'</span><span class="s1">10</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">/** */</code> 주석처리 안에다 <code class="language-plaintext highlighter-rouge">@param {type} 파라미터명</code>을 적어주고 리턴되는 값도 <code class="language-plaintext highlighter-rouge">@returns {type}</code>으로 지정해 줄 수 있다.</li>
  <li>타입스크립트처럼 에러를 에디터에서 확인하려면 <code class="language-plaintext highlighter-rouge">@ts-check</code>를 주석에 넣어주면 에러를 발생시켜준다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @ts-check</span>

<span class="cm">/**
 * 
 * @param {number} a 
 * @param {number} b 
 * @returns {number}
 */</span>
<span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="o">+</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">;</span> 
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="dl">'</span><span class="s1">10</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>리턴값은 number 타입을 줬기 때문에 string 형식을 지정할 수 없다는 에러가 발생되고, sum() 함수에도 number 타입의 파라미터만 입력받을 수 있으므로 에러를 발생시키게 된다.</p>

<p><img src="https://user-images.githubusercontent.com/52439201/177474279-b39c40ba-6b84-4827-9840-708091d06101.png" alt="스크린샷 2022-07-06 오후 2 18 26" /></p>

<p><br /></p>

<h2 id="기본-타입-정의">기본 타입 정의</h2>

<h3 id="string">String</h3>

<p>자바스크립트에서 변수 타입이 문자열이면 아래와 같이 <code class="language-plaintext highlighter-rouge">string</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">str</span><span class="p">:</span> <span class="nx">string</span><span class="p">;</span>
<span class="nx">str</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">str</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// error</span>
</code></pre></div></div>

<h3 id="number">number</h3>
<p>자바스크립트에서 변수 타입이 숫자면 아래와 같이 <code class="language-plaintext highlighter-rouge">number</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">number</span><span class="p">:</span> <span class="nx">number</span><span class="p">;</span>
<span class="nx">number</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// error</span>
<span class="nx">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="boolean">boolean</h3>
<p>자바스크립트에서 변수 타입이 불린이면 아래와 같이 <code class="language-plaintext highlighter-rouge">boolean</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">boolean</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>

<span class="nx">boolean</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="nx">boolean</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// error</span>
</code></pre></div></div>
<h3 id="object">Object</h3>
<p>자바스크립트에서 변수 타입이 객체이면 아래와 같이 <code class="language-plaintext highlighter-rouge">{var1: type1, var2: type2}</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">person</span><span class="p">:</span> <span class="p">{</span><span class="nl">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="nx">number</span><span class="p">}</span>

<span class="nx">person</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span>
<span class="nx">person</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span> <span class="c1">// name은 string 타입이므로 number 타입은 사용 x =&gt; error </span>
</code></pre></div></div>

<h3 id="array">Array</h3>
<p>자바스크립트에서 변수 타입이 배열이면 아래와 같이 <code class="language-plaintext highlighter-rouge">Array&lt;type&gt; or type[]</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">number_arr</span><span class="p">:</span> <span class="nx">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">string_arr</span><span class="p">:</span> <span class="nx">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">boolean_arr</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>
</code></pre></div></div>
<p>또는 아래와 같이 제네릭으로 사용할 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">number_arr</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">string_arr</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">boolean_arr</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">boolean</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="tuple">Tuple</h3>
<ul>
  <li>튜플은 배열의 길이가 고정되고 각 요소의 타입이 지정되어 있는 배열 형식을 의미한다.</li>
  <li>자바스크립트에서 변수 타입이 튜플이면 아래와 같이 <code class="language-plaintext highlighter-rouge">[type1, type2]</code> 타입을 선언해서 사용한다.</li>
  <li>길이가 고정되어 있고 각 자리마다 타입을 선언하기 때문에, 정의되지 않는 인덱스에 접근하거나 정의하지 않는 타입이면 에러가 발생한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">tuple_arr</span><span class="p">:</span> <span class="p">[</span><span class="nx">string</span><span class="p">,</span> <span class="nx">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">hi</span><span class="dl">'</span><span class="p">,</span> <span class="mi">10</span><span class="p">];</span>

<span class="nx">tuple_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1">// 길이가 '2'인 튜플 형식 '[string, number]'의 인덱스 '2'에 요소가 없습니다.</span>
<span class="nx">tuple_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="dl">'</span><span class="s1">!</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 'number' 형식에 'concat' 속성이 없습니다.</span>
</code></pre></div></div>

<h3 id="any">Any</h3>
<p>기존에 자바스크립트로 구현되어 있는 웹 서비스 코드에 타입스크립트를 점진적으로 적용할 때 활용하면 좋은 타입이다. 단어 의미 그대로 모든 타입에 대해서 허용한다는 의미를 갖고 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">string</span><span class="p">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">number</span><span class="p">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">boolean</span><span class="p">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">arr</span><span class="p">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">hi</span><span class="dl">'</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="void">Void</h3>
<ul>
  <li>변수에는 undefined와 null만 할당하고, 함수에는 반환 값을 설정할 수 없는 타입이다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">void_type</span><span class="p">:</span> <span class="k">void</span><span class="p">;</span>
<span class="nx">void_type</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// 'number' 형식은 'void' 형식에 할당할 수 없습니다.</span>
<span class="nx">void_type</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 'string' 형식은 'void' 형식에 할당할 수 없습니다.</span>

<span class="kd">function</span> <span class="nx">void_fn</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">void</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">void_fn</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">void</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">//'number' 형식은 'void' 형식에 할당할 수 없습니다.</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="enum">Enum</h3>
<ul>
  <li>Enum 타입은 C, Java와 같은 다른 언어에서 흔하게 쓰이는 타입으로 특정 값(상수)들의 집합을 의미한다.</li>
  <li>Enum 타입은 객체의 키값으로도 접근가능하며, 배열의 인덱스로도 접근이 가능하다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Avengers</span> <span class="p">{</span><span class="nx">Capt</span><span class="p">,</span> <span class="nx">IronMan</span><span class="p">,</span> <span class="nx">Thor</span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">hero</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">.</span><span class="nx">Capt</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">hero2</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">.</span><span class="nx">IronMan</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">hero3</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">.</span><span class="nx">Thor</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Avengers</span><span class="p">)</span> <span class="c1">// {0: 'Capt', 1: 'IronMan', 2: 'Thor', Capt: 0, IronMan: 1, Thor: 2}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero</span><span class="p">);</span> <span class="c1">// 0</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero2</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero3</span><span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<p>Enum은 인덱스 번호로도 접근할 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Avengers</span> <span class="p">{</span><span class="nx">Capt</span><span class="p">,</span> <span class="nx">IronMan</span><span class="p">,</span> <span class="nx">Thor</span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">hero</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">hero2</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">hero3</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>


<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero</span><span class="p">);</span> <span class="c1">// Capt</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero2</span><span class="p">);</span> <span class="c1">// IronMan</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero3</span><span class="p">);</span> <span class="c1">// Thor</span>
</code></pre></div></div>

<ul>
  <li>Enum의 인덱스를 사용자 편의로 변경하여 사용할 수도 있다.</li>
  <li>주의헤야할 점은 특정 값의 인덱스를 편의로 변경하면 그 뒤에 오는 값들은 변경한 인덱스 값을 기준으로 순차적으로 갖게된다.</li>
  <li>가령 Capt는 인덱스를 2부터 시작하므로 IronMan는 3, Thor는 4를 갖게 된다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Avengers</span> <span class="p">{</span><span class="nx">Capt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="nx">IronMan</span><span class="p">,</span> <span class="nx">Thor</span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">hero</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">hero2</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">hero3</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Avengers</span><span class="p">)</span> <span class="c1">// {2: 'Capt', 3: 'IronMan', 4: 'Thor', Capt: 2, IronMan: 3, Thor: 4}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero2</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero3</span><span class="p">);</span> <span class="c1">// Capt</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="함수-타입">함수 타입</h2>

<p>함수를 타입스크립트로 크게 3가지로 정의할 수 있다.</p>

<ul>
  <li>함수의 파라미터(매개변수) 타입</li>
  <li>함수의 반환 타입</li>
  <li>함수의 구조 타입</li>
</ul>

<h3 id="함수의-기본-타입-정의">함수의 기본 타입 정의</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">profile</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">address</span><span class="p">,</span> <span class="nx">age</span><span class="p">){</span>
  <span class="k">return</span> <span class="s2">`이름 : </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">, 주소 : </span><span class="p">${</span><span class="nx">address</span><span class="p">}</span><span class="s2">, 나이 : </span><span class="p">${</span><span class="nx">age</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 자바스크립트 함수에 타입을 정의하면 아래와 같다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">profile</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">address</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">string</span><span class="p">{</span>
  <span class="k">return</span> <span class="s2">`이름 : </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">, 주소 : </span><span class="p">${</span><span class="nx">address</span><span class="p">}</span><span class="s2">, 나이 : </span><span class="p">${</span><span class="nx">age</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>기존의 자바스크립트 함수 선언 방식에서 <code class="language-plaintext highlighter-rouge">매개변수의 타입</code>과 <code class="language-plaintext highlighter-rouge">반환 값의 타입</code>을 정의하였다.</p>

<p><br /></p>

<h3 id="함수의-파리미터">함수의 파리미터</h3>
<p>타입스크립트에서는 함수의 파라미터를 필수 값으로 간주한다. 따라서, 함수를 선언할 때 매개변수를 설정하게 되면 <code class="language-plaintext highlighter-rouge">undefined</code>나 <code class="language-plaintext highlighter-rouge">null</code>이라도 인자로 넘겨줘야 한다. 그 다음 컴파일러에서는 정의된 매개변수 값들이 넘어왔는지 확인한다. 달리 말하면 정의한 매개변수 값만 받을 수 있으며 추가 인자는 받을 수 없다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">c</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="o">+</span><span class="nx">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// error, 3개의 인수가 필요한데 1개를 가져왔습니다.</span>
<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// error, 3개의 인수가 필요한데 2개를 가져왔습니다.</span>
<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span> 
</code></pre></div></div>

<p><br /></p>

<p>함수의 매개변수 초기화는 ES6 문법과 동일하다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 110</span>
<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// 30</span>
</code></pre></div></div>

<p>위의 타입스크립트를 자바스크립트로 변환하게되면 아래와 같다. 따라서 b 파라미터가 void면 초기화 값을 리턴하고 아니면, 그 값을 대체한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">b</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="함수의-rest-파라미터">함수의 REST 파라미터</h3>
<p>ES6 문법에서 지원하는 REST 파라미터는 타입스크리에서 다음과 같이 선언할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">total</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">val</span> <span class="k">of</span> <span class="nx">rest</span><span class="p">){</span>
    <span class="nx">total</span> <span class="o">+=</span> <span class="nx">val</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span> <span class="c1">// 100</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="함수의-옵션-속성">함수의 옵션 속성</h3>
<p>위의 함수의 파라미터에서 매개변수를 정의하면 모두 필수 값으로 간주한다고 했다. 하지만, 정의된 매개변수의 갯수 만큼 인자를 넘기지 않아도 되는 옵션을 부과하고 싶다면 아래와 같이 <code class="language-plaintext highlighter-rouge">?</code>물음표를 붙이면 된다.</p>

<p><code class="language-plaintext highlighter-rouge">c</code> 파라미터 앞에 물음표를 붙이면 넘기거나/안넘기거나 선택할 수 있는 옵션을 부과하게 된다.</p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">c</span><span class="p">?:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="o">+</span><span class="nx">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 2~3개의 인수가 필요한데 1개의 인수만 가져왔습니다.</span>
<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// 30</span>
<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span> <span class="c1">// 60</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="this">this</h3>
<p>타입스크립트에서 자바스크립트의 this가 잘못 사용되었을 때 감지할 수 있다. 타입스크립트에서 this가 가리키는 것을 명시하려면 아래와 같이 선언한다.</p>

<ul>
  <li>함수 호출에서 this는 전역객체를 참조하기 때문에 this의 타입으로 Window 타입을 선언했다.</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="k">this</span><span class="p">:</span> <span class="nx">Window</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>자바스크립트에서는 객체의 함수에서 호출된다면 그 함수의 this는 해당 객체를 참조하게 된다. 따라서 init() 함수에서의 this는 <code class="language-plaintext highlighter-rouge">Vue</code>가 되므로 참조가 되는 객체를 명시하면 된다.</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Vue</span> <span class="p">{</span>
  <span class="nl">el</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">count</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nx">init</span><span class="p">(</span><span class="k">this</span><span class="p">:</span> <span class="nx">Vue</span><span class="p">):</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{};</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">vm</span><span class="p">:</span> <span class="nx">Vue</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">el</span><span class="p">:</span> <span class="dl">'</span><span class="s1">#app</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">count</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
  <span class="na">init</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="na">this</span><span class="p">:</span> <span class="nx">Vue</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="kd">let</span> <span class="nx">getCount</span> <span class="o">=</span> <span class="nx">vm</span><span class="p">.</span><span class="nx">init</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="nx">getCount</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span> <span class="c1">// 10</span>
</code></pre></div></div>]]></content><author><name>GitHub User</name></author><category term="Typescirpt" /><category term="Typescirpt" /><category term="Javascript" /><category term="ES6" /><summary type="html"><![CDATA[자바스크립트에 타입 추가하는 방법]]></summary></entry><entry><title type="html">[Electron] 01. 일렉트론이란?</title><link href="http://localhost:4000/electron/2022/06/28/electron.html" rel="alternate" type="text/html" title="[Electron] 01. 일렉트론이란?" /><published>2022-06-28T00:00:00+09:00</published><updated>2022-06-28T00:00:00+09:00</updated><id>http://localhost:4000/electron/2022/06/28/electron</id><content type="html" xml:base="http://localhost:4000/electron/2022/06/28/electron.html"><![CDATA[<h2 id="일렉트론electron이란">일렉트론(Electron)이란?</h2>

<p>일렉트론은 Javascript, HTML, CSS 만으로도 데스크탑 앱을 만들 수 있는 프레임워크이다. 2013년 아톰 쉘(Atom Shell)이라 불리는 크로스 플랫폼 애플리케이션 쉘로 시작했으며 오픈소스화, 명칭 변경등을 거쳐 현재는 깃허브에서 개발하고 있다.</p>

<p>자바스크립트는 현재 전세계에서 가장 많은 개발자가 사용하는 프래그래밍 언어로 그 인기만큼 활용 범위가 커지고 있다. 그 중 하나가 일렉트론이다.
매년 발표되는 <a href="https://roadmap.sh/frontend">WEB Developer frontend roadmap</a>을 살펴보면 데스크탑 앱에 일렉트론이 있는 것을 확인할 수 있다.</p>

<p><br /></p>

<h2 id="일렉트론-특징">일렉트론 특징</h2>

<h3 id="웹기술">웹기술</h3>
<ul>
  <li>백엔드 : node.js 런타임</li>
  <li>프론트엔드 : Chromium(크로미엄, 오픈소스 웹브라우저 프로젝트) + (Javascript, HTML, CSS)를 이용 React, Vue, Angular도 사용가능하다.</li>
</ul>

<h3 id="오픈소스-기반">오픈소스 기반</h3>
<p>일렉트론은 Github가 관리하는 오픈소스 프로젝트이며 적극적인 참여자들과 함께하는 커뮤니티이다.</p>

<h3 id="장점">장점</h3>
<ul>
  <li>
    <p><strong>낮은 진입 장벽</strong>:<br />
일렉트론은 개발자의 진입 장벽이 낮다는 장점이 있다. Javascript, HTML, CSS 및 웹 기술을 다룰줄 아는 개발자라면 누구나 일렉트론 앱을 개발할 수 있다. 그 말은 따로 새로운 기술이나 언어를 배울 필요가 없기 때문에 기존의 웹 기술을 사용하던 개발자들은 어렵지 않게 시작할 수 있다.</p>
  </li>
  <li>
    <p><strong>개발 속도 향상</strong>: <br />
자바스크립트의 인터프리터 방식으로 개발자는 손쉽게 디버깅하고 최적화할 수 있어 일렉트론 앱을 빠르게 구현할 수 있다. 또한, 일렉트론으로 개발된 애플리케이션은 일반적으로 웹 애플리케이션의 비즈니스 로직, 디자인 및 구조를 재사용하기 때문에 개발에 소요되는 시간과 비용을 줄일 수 있다.</p>
  </li>
  <li>
    <p><strong>크로스 플랫폼</strong>:<br />
각기 다른 os 플랫폼을 지원한다는 장점이 있다. 데스크탑 앱을 개발할 때 각 os마다 최적화 작업을 진행해야하고 API선언 및 제공이 달라질 수 있으며 os별로 코드가 상이하기 때문에 유지보수에 어려움을 겪을 수 있다. 하지만 일렉트론은 이러한 이슈들을 해결할 수 있다. 맥, 윈도우, 리눅스별로 적합한 룩앤필을 맞추고 개발자들에게 친숙한 자바스크립트, HTML, CSS를 활용하여 개발하기 때문에 쉽게 애플리케이션을 구성할 수 있다.</p>
  </li>
</ul>

<p>또한, 한번에 세 가지 os에 대한 빌드를 지원하고 설치할 수 있도록 도와준다. 기존의 웹 기술을 그대로 사용하면서도 브라우저 버전별로 기능을 제약하거나 타겟 플랫폼에 따라 별도의 버전을 유지할 필요가 없게 된다. os 관련 어려운 부분은 일렉트론이 처리하기 때문에 개발자는 응용 프로그램에만 집중할 수 있다.</p>

<p>정리해서,</p>

<ul>
  <li>일렉트론은 웹 프론트엔드 기술을 사용할 수 있는 개발자라면 쉽게 사용할 수 있을 정도로 러닝커브가 낮다.</li>
  <li>일렉트론은 오픈소스 기반 프로젝트이므로 지속적인 업데이트와 큰 규모의 커뮤니티 생태계를 가지고 있다.</li>
  <li>크로스 플랫폼이라서 맥, 윈도우, 리눅스 환경 어디서든 구동할 수 있는 장점이 잇다.</li>
</ul>

<p><br /></p>

<h2 id="일렉트론-활용사례">일렉트론 활용사례</h2>

<p>그렇다면 일렉트론으로 개발한 애플리케이션은 무엇이 있을까?</p>

<p>대표적으로 <code class="language-plaintext highlighter-rouge">아톰 에디터</code>, <code class="language-plaintext highlighter-rouge">VSCode</code>, <code class="language-plaintext highlighter-rouge">슬랙</code>, <code class="language-plaintext highlighter-rouge">워드프레스</code> 등이 있으며 한국에서는 협업 툴로 유명한 <code class="language-plaintext highlighter-rouge">잔디</code>가 그 예시이다.
<a href="www.electronjs.org/apps">일렉트론 웹사이트</a>를 방문하면 카테고리별로 일렉트론으로 개발한 앱들을 확인할 수 있다.</p>]]></content><author><name>GitHub User</name></author><category term="Electron" /><category term="Node.js" /><category term="Javascript" /><summary type="html"><![CDATA[일렉트론(Electron)이란?]]></summary></entry><entry><title type="html">[Git] git flow 전략 파악하기</title><link href="http://localhost:4000/git/2022/06/26/git-10.html" rel="alternate" type="text/html" title="[Git] git flow 전략 파악하기" /><published>2022-06-26T00:00:00+09:00</published><updated>2022-06-26T00:00:00+09:00</updated><id>http://localhost:4000/git/2022/06/26/git-10</id><content type="html" xml:base="http://localhost:4000/git/2022/06/26/git-10.html"><![CDATA[<h2 id="git-flow-전략">git-flow 전략</h2>

<p>Git-flow는 총 5가지 브랜치를 사용하고 운영한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">master</code> 브랜치 : 기준이 되는 브랜치로 제품을 배포하는 브랜치이다.</li>
  <li><code class="language-plaintext highlighter-rouge">develop</code> 브랜치 : 개발 브랜치로 개발자들이 이 브랜치를 기준으로 각자 작업한 기능들을 합(Merge)한다.</li>
  <li><code class="language-plaintext highlighter-rouge">feature</code> 브랜치 : 단위 기능을 개발하는 브랜치로 기능 개발이 완료되면 develop 브랜치에 합(Merge)한다.</li>
  <li><code class="language-plaintext highlighter-rouge">release</code> 브랜치 : 배포를 위해 master 브랜치로 보내기 전에 먼저 QA(품질검사)를 하기위한 브랜치이다.</li>
  <li><code class="language-plaintext highlighter-rouge">hotfix</code> 브랜치 : master 브랜치로 배포를 했는데 버그가 생겼을 떄 긴급 수정하는 브랜치이다.</li>
</ul>

<blockquote>
  <p>! 여기서 핵심이 되는 브랜치는 master 브랜치와 develop 브랜치이다. 나머지 브랜치는 필요에 의해 운영되는 브랜치라고 생각하면 된다.</p>
</blockquote>

<p><br /></p>

<h2 id="메인-브랜치master-develop">메인 브랜치(master, develop)</h2>

<p>git-flow 전략에서 핵심이 되는 브랜치는 master, develop 브랜치이다.</p>

<h3 id="master-브랜치">master 브랜치</h3>
<p>배포 가능한 상태만을 관리하는 브랜치로 안정적인 버전의 소스들만 관리되는 브랜치이다. master 브랜치의 HEAD는 최신 배포판의 소스코드 버전이 들어있다. master 브랜치는 지난 배포판의 소스코드를 따라가기 위해 태그(tag)들이 추가되어 있다. 이 태그를 확인해서 각 릴리즈 버전의 소스코드를 빠르게 확인한다.</p>

<p>정리해서, master 브랜치는 운영서버에 배포해야 되는 소스코드가 관리되어야 한다(안정성이 충분히 검증된 소스코드).</p>

<h3 id="develop-브랜치">develop 브랜치</h3>
<p>develop 브랜치는 다음에 배포할 것을 개발하는 브랜치이다. develop 브랜치는 통합 브랜치의 역할을 한다. 평소 개발자들은 이 브랜치를 기반으로 개발을 진행해야한다.
개발자들은 develop 브랜치에서 feature 브랜치를 생성하고, 소스코드 수정 및 기능 개발이 완료되면 develop 브랜치로 <code class="language-plaintext highlighter-rouge">풀 리퀘스트</code> 요청을 하게 된다.</p>

<p><br /></p>

<h2 id="feature-브랜치">feature 브랜치</h2>
<ul>
  <li>생성되어지는 브랜치 : develop</li>
  <li>merge 해야되는 브랜치 : develop</li>
</ul>

<p>feature 브랜치 또는 topic 브랜치라 부른다.</p>

<p>단위 기능을 개발하는 브랜치로 develop 브랜치의 HEAD에서 생성된다. 새로운 기능 개발을 하거나 버그 수정을 위한 코드 수정이 이뤄지는 브랜치로 이해하면 된다. 이 브랜치에서는 개발자 혼자 작업을 할 수 있도 있고, 특정 기능 개발을 위한 여러명의 개발자들이 공동으로 작업할 수도 있다.</p>

<p>feature 브랜치에서 작업이 완료되면 <code class="language-plaintext highlighter-rouge">풀 리퀘스트</code>를 요청하여 develop 브랜치에 <code class="language-plaintext highlighter-rouge">병합(merge)</code>하게 된다.</p>

<blockquote>
  <p>여기서 주의해야할 점은 feature 브랜치를 생성한 목적이 완료될 때까지 유지해야하고 다 완성되면 develop 브랜치에 병합해야 한다. 그리고 feature 브랜치는 보통 개발자 저장소에만 있는 브랜치이고 리모트 저장소에는 push하지 않는다.</p>
</blockquote>

<p><br /></p>

<h2 id="release-브랜치">release 브랜치</h2>
<ul>
  <li>생성되어지는 브랜치 : develop</li>
  <li>merge 해야되는 브랜치 : develop, master</li>
</ul>

<p>git으로 관리되는 소프트웨어는 정기적으로 성능개선, 기능추가, 버그를 수정 및 반영하면서 릴리즈된다. release 브랜치는 릴리즈를 하기 위한 목적으로 생성되는 브랜치이다.
release 브랜치는 develop 브랜치에서 생성된다.</p>

<p>간단한 순서는 아래와 같다.</p>

<ul>
  <li>develop 브랜치에 이전 버전에 포함되는 기능이 merge 되어있다면 QA를 위해 develop 브랜치에서부터 release 브랜치를 생성한다.</li>
  <li>배포를 위한 최종적인 버그 수정 등의 개발을 수행한다.</li>
  <li>배포 가능한 상태가 되면 master 브랜치로 병합한다. 출시된 master 브랜치에는 버전 태크를 추가한다.</li>
  <li>release 브랜치에서 기능을 점검하며 발견한 버그 수정 사항은 develop 브랜치에도 적용해야 한다. 따라서 배포 완료 후 develop 브랜치에도 merge를 해야한다.</li>
</ul>

<p><br /></p>

<h2 id="hotfix-브랜치">hotfix 브랜치</h2>
<ul>
  <li>생성되어지는 브랜치 : master</li>
  <li>merge 해야되는 브랜치 : develop, master</li>
</ul>

<p>hotfix 브랜치는 배포한 버전에서 긴급하게 수정이 필요한 경우 master 브랜치에서 분기하는 브랜치이다.
다음 릴리즈를 기다릴 수 없을 정도로 긴급한 패치가 바로 반영되어야 하는 경우 이 hotfix 브랜치를 사용한다.</p>

<p>정리해서,</p>

<ul>
  <li>hotfix 브랜치는 master 브랜치에서 생성된다.</li>
  <li>hotfix 브랜치에는 긴급한 패치들이 반영된다.</li>
  <li>이후 hotfix 브랜치는 master 브랜치에 병합되고 태그를 추가한다.</li>
  <li>마찬가지로 develop 브랜치로도 병합되어 긴급 수정 사항이 이후 릴리즈에도 반영되도록 해야한다.</li>
</ul>

<p><br /></p>

<h2 id="git-flow-설명">git-flow 설명</h2>

<p><img src="/assets/images/banners/git-flow.png" alt="" /></p>

<ol>
  <li>가장 먼저 master 브랜치에서 시작한다.</li>
  <li>master 브랜치와 동일하게 develop 브랜치를 생성해준다. 그리고 개발자들은 develop 브랜치에서 개발을 진행한다.</li>
  <li>개발을 진행하다가 <code class="language-plaintext highlighter-rouge">1.회원가입</code>, <code class="language-plaintext highlighter-rouge">2.장바구니</code>, <code class="language-plaintext highlighter-rouge">3.오류수정</code> 등의 기능 구현 및 버그 수정이 필요한 경우
    <ul>
      <li>A 개발자는 develop 브랜치에서 feature 브랜치를 하나 생성해서 <code class="language-plaintext highlighter-rouge">1.회원가입 기능</code>을 구현한다.</li>
      <li>B 개발자는 develop 브랜치에서 feature 브랜치를 하나 생성해서 <code class="language-plaintext highlighter-rouge">2.장바구니 기능</code>을 구현한다.</li>
      <li>C 개발자는 develop 브랜치에서 feature 브랜치를 하나 생성해서 <code class="language-plaintext highlighter-rouge">3.오류수정</code>을 구현한다.</li>
    </ul>
  </li>
  <li>완료성된 feature 브랜치들은 develop 브랜치에 <code class="language-plaintext highlighter-rouge">풀 리퀘스트</code> 요청을 하고 검토가 완료되어 이상이 없으면 <code class="language-plaintext highlighter-rouge">merge</code>한다.</li>
  <li>모든 기능이 완료되면 develop 브랜치에서 release 브랜치를 생성한다.. 그리고 QA(품질검사)를 진행하다가 보완점을 보완하고 버그를 수정한다.</li>
  <li>모든 것이 완료되면 release 브랜치를 master 브랜치와 develop 브랜치로 <code class="language-plaintext highlighter-rouge">merge</code>한다. master 브랜치에서 버전추가를 위해 태그를 생성하고 배포한다.</li>
  <li>배포를 완료했는데 미처 발견하지 못한 버그가 있는 경우 hotfix 브랜치를 master 브랜치로부터 생성하여 긴급 수정 후 태그를 생성하고 바로 수정 배포를 진행한다.</li>
</ol>]]></content><author><name>GitHub User</name></author><category term="Git" /><category term="Git" /><category term="Github" /><summary type="html"><![CDATA[git-flow 전략]]></summary></entry></feed>