<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-07-27T14:54:12+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">IT 데이터베이스</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>GitHub User</name></author><entry><title type="html">[Javascript] 화살표 함수의 this 바인딩(미완)</title><link href="http://localhost:4000/javascript/2022/07/26/javascript-15.html" rel="alternate" type="text/html" title="[Javascript] 화살표 함수의 this 바인딩(미완)" /><published>2022-07-26T00:00:00+09:00</published><updated>2022-07-26T00:00:00+09:00</updated><id>http://localhost:4000/javascript/2022/07/26/javascript-15</id><content type="html" xml:base="http://localhost:4000/javascript/2022/07/26/javascript-15.html"><![CDATA[<h2 id="화살표-함수arrow-function">화살표 함수(Arrow Function)</h2>
<p>ES6가 도입되면서 새롭게 나타난 <code class="language-plaintext highlighter-rouge">화살표 함수(Arrow Function)</code>는 <code class="language-plaintext highlighter-rouge">function</code> 키워드 대신 화살표<code class="language-plaintext highlighter-rouge">(=&gt;)</code>를 사용하여 기존의 전통적인 함수표현<code class="language-plaintext highlighter-rouge">(function)</code>의 간편한 대안으로 새롭게 등장했다.<br />
화살표 함수의 기본 문법은 아래와 같이 작성한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 기존</span>
<span class="kd">function</span> <span class="nx">logText</span><span class="p">(</span><span class="nx">text</span><span class="p">){</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 화살표 함수</span>
<span class="kd">const</span> <span class="nx">logText</span> <span class="o">=</span> <span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 매개변수 지정</span>
   <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// 매배변수가 없을 때</span>
   <span class="nx">x</span>  <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// 매개변수가 한 개</span>
<span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="nx">y</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span> <span class="c1">// 매개변수가 여러 개, 소괄호를 생략할 수 없다.</span>

<span class="c1">// 함수 몸체 지정</span>
<span class="nx">x</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="mi">10</span> <span class="p">}</span> <span class="c1">// single line block</span>
<span class="nx">x</span> <span class="o">=&gt;</span> <span class="nx">x</span> <span class="o">*</span> <span class="mi">10</span> <span class="c1">// 함수 몸체가 한 줄의 구문이라면 중괄호를 생략할 수 있으며, 암묵적으로 return</span>

<span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span><span class="k">return</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">}};</span> 
<span class="p">()</span> <span class="o">=&gt;</span> <span class="p">({</span><span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">});</span> <span class="c1">// 객체를 반환 시 소괄호를 사용해야 한다.</span>

<span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>                 <span class="c1">// multi line blok.</span>
    <span class="kd">const</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이와 같이 기존의 전통적인 함수표현과 화살표 함수는 기능적으로는 동일하다. 하지만 왜 화살표 함수가 등장했으며 사용하는 것일까?
단순하게 함수 표현이 간단하기 때문에 사용하는 것일까?</p>

<p>심지어 화살표 함수는 아래와 같은 조건이 있다.</p>
<ul>
  <li>무조건 익명함수로만 사용해야 한다.</li>
  <li>메소드나 생성자 함수로 사용할 수 없다.</li>
  <li>yield를 화살표 함수 내부에서 사용할 수 없다.</li>
  <li>일반적으로 스코프를 지정할 때 사용하는 call, apply, bind 메서드를 사용할 수 없다.</li>
</ul>

<p>결론부터 말하면, 화살표 함수를 사용하는 이유는 <code class="language-plaintext highlighter-rouge">this 바인딩</code> 때문이다. 
기존의 <code class="language-plaintext highlighter-rouge">this</code> 바인딩과 화살표 함수의 <code class="language-plaintext highlighter-rouge">this</code> 바인딩에는 무슨 차이가 있는지 알아보자.</p>

<p><br /></p>

<h2 id="기존의-함수의-this-바인딩">기존의 함수의 this 바인딩</h2>
<p>화살표 함수가 등장하기 전까지는, 모든 새로운 함수는, 그 함수가 호출되는 방법에 따라서 참조하는 this가 정의되었다.</p>

<ul>
  <li>일반 함수로 호출되는 경우 =&gt; 전역객체를 <code class="language-plaintext highlighter-rouge">this</code></li>
  <li>메소드로서 호출되는 경우 =&gt; 메소드를 호출한 객체를 <code class="language-plaintext highlighter-rouge">this</code></li>
  <li>call, apply, bind 메서드 호출 =&gt; 첫 번째 인자로 넘겨주는 것이 <code class="language-plaintext highlighter-rouge">this</code></li>
</ul>

<p>이렇게 함수 호출 방식에 따라 참조하는 this 객체가 다르기 때문에 킹받는 일이 많다…</p>

<p>가령 아래와 같은 예시를 들 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 일반 함수로서 호출은 전역객체를 this로 참조함</span>
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">address</span> <span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">addr</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(){</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">addr</span><span class="p">()</span> 
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">address</span><span class="p">();</span> <span class="c1">// undefined </span>

<span class="c1">// 메서드로서 호출은 그 객체를 this로 참조함</span>
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">address</span> <span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span> 
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">address</span><span class="p">();</span> <span class="c1">// siksik</span>
</code></pre></div></div>
<p>첫 번째 함수는</p>

<ul>
  <li>person.address() 메서드가 실행됨.</li>
  <li>addr은 일반 함수로서의 호출이므로 전역객체를 <code class="language-plaintext highlighter-rouge">this</code>로 참조함</li>
  <li>전역객체에는 name이라는 멤버가 존재하지 않으므로 <code class="language-plaintext highlighter-rouge">undefined</code> 출력</li>
</ul>

<p>두 번째 함수는</p>
<ul>
  <li>person.address() 메서드가 실행됨.</li>
  <li>addr은 메서드로서 호출이므로 그 객체를 <code class="language-plaintext highlighter-rouge">this</code>로 참조함</li>
  <li>해당 객체에 name이라는 멤버가 존재하므로 <code class="language-plaintext highlighter-rouge">siksik</code> 출력</li>
</ul>

<p>이렇게 참조 객체를 하나하나 신경쓰는게 짜증나는 경우가 많다.
그래서 등장한 화살표 함수!!</p>

<p><br /></p>

<h2 id="화살표-함수의-this-바인딩">화살표 함수의 this 바인딩</h2>
<p>기존의 함수는 선얼할 때 this에 바인딩할 객체가 호출 방식에 따라 동적으로 결정되었다면, 화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정된다.<br />
쉽게 말해, <code class="language-plaintext highlighter-rouge">화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다.</code> 이를 Lexical this라 한다.  <br />
달리 말하면, <code class="language-plaintext highlighter-rouge">화살표 함수는 자신의 this가 존재하지 않는다!</code></p>

<blockquote>
  <p>자바스크립트는 어떤 식별자(변수)를 탐색할 때 현재 환경에서 그 변수가 없으면 바로 상위 환경을 검색한다. 또 없으면 그 상위, 이렇게 상위 환경으로 변수를 올라가면서 찾으며 가장 최상위 환경에 도달할 때 까지도 찾지 못하면 없다고 결론되는 것이다. 화살표 함수는 자신의 this가 존재하지 않으므로 그 상위 this를 동적으로 참조하게 되는 것이다.</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 일반 함수로서 호출은 전역객체를 this로 참조함</span>
<span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">address</span> <span class="p">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">const</span> <span class="nx">addr</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="nx">addr</span><span class="p">()</span> 
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">address</span><span class="p">();</span> <span class="c1">// siksik </span>
</code></pre></div></div>

<p><br /></p>

<h2 id="화살표-함수를-사용해서는-안되는-경우">화살표 함수를 사용해서는 안되는 경우</h2>
<p>화살표 함수는 렉시컬 this를 지원하므로 콜백 함수로 사용하기에는 매우~편리하다. 하지만 화살표 함수를 사용하면 오히려 혼란이 오는 경우가 있다.</p>

<h3 id="메소드">메소드</h3>
<p>화살표 함수를 메소드로 정의하는 것은 피해야 한다. 아래의 코드를 보자</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">person</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">callName</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">name</span><span class="p">),</span>
<span class="p">}</span>

<span class="nx">person</span><span class="p">.</span><span class="nx">callName</span><span class="p">()</span> <span class="c1">// undefined </span>
</code></pre></div></div>

<h3 id="prototype">prototype</h3>

<h3 id="생성자-함수">생성자 함수</h3>

<p>###</p>]]></content><author><name>GitHub User</name></author><category term="Javascript" /><category term="Javascript" /><category term="ES6" /><summary type="html"><![CDATA[화살표 함수(Arrow Function) ES6가 도입되면서 새롭게 나타난 화살표 함수(Arrow Function)는 function 키워드 대신 화살표(=&gt;)를 사용하여 기존의 전통적인 함수표현(function)의 간편한 대안으로 새롭게 등장했다. 화살표 함수의 기본 문법은 아래와 같이 작성한다.]]></summary></entry><entry><title type="html">[TypeScript] Union and Intersection Types</title><link href="http://localhost:4000/typescirpt/2022/07/19/typescript-05.html" rel="alternate" type="text/html" title="[TypeScript] Union and Intersection Types" /><published>2022-07-19T00:00:00+09:00</published><updated>2022-07-19T00:00:00+09:00</updated><id>http://localhost:4000/typescirpt/2022/07/19/typescript-05</id><content type="html" xml:base="http://localhost:4000/typescirpt/2022/07/19/typescript-05.html"><![CDATA[<h2 id="유니온-타입union-type">유니온 타입(Union Type)</h2>
<p>유니온 타입이란, 자바스크립트의 OR 연산자(<code class="language-plaintext highlighter-rouge">||</code>)와 같은 의미를 갖는다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">union</span> <span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="nb">Number</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">union</span><span class="p">(</span><span class="dl">'</span><span class="s1">10</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// string</span>
<span class="nx">union</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="c1">// number</span>
</code></pre></div></div>

<p>위 함수에 유니온 타입을 적용하면 파라미터 name에는 <code class="language-plaintext highlighter-rouge">문자열</code>과 <code class="language-plaintext highlighter-rouge">숫자 타입</code> 모두 올 수 있다. 이처럼 <code class="language-plaintext highlighter-rouge">|</code> 연산자를 이용하여 타입을 여러 개 연결하는 방식을 유니온 타입 정의 방식이라고 부른다.</p>

<h3 id="유니온-타입union-type을-사용하는-이유">유니온 타입(Union Type)을 사용하는 이유</h3>

<p>유니온 타입을 사용하는 이유를 코드를 보면 이해하기 쉽다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">padLeft</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">padding</span><span class="p">:</span> <span class="kr">any</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">padding</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">padding</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">`Expected string or number, got '</span><span class="p">${</span><span class="k">typeof</span> <span class="nx">padding</span><span class="p">}</span><span class="s2">'.`</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="nx">padLeft</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello world</span><span class="dl">"</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span> <span class="c1">// returns "    Hello world"</span>
<span class="nx">padLeft</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello world</span><span class="dl">"</span><span class="p">,</span> <span class="dl">'</span><span class="s1">4</span><span class="dl">'</span><span class="p">);</span> <span class="c1">// returns "    Hello world"</span>
<span class="nx">padLeft</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello world</span><span class="dl">"</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span> <span class="c1">// Expected string or number, got 'boolean'.</span>
</code></pre></div></div>

<p>위의 코드를 보면 파라미터 padding에는 <code class="language-plaintext highlighter-rouge">string</code>과 <code class="language-plaintext highlighter-rouge">number</code> 타입 둘다 들어올 수 있기 떄문에 <code class="language-plaintext highlighter-rouge">any</code> 타입으로 지정했다. 하지만, 문제는 <code class="language-plaintext highlighter-rouge">string</code>, <code class="language-plaintext highlighter-rouge">number</code> 타입 이외에 타입이 들어오면 에러를 발생시킨다.</p>

<p>이럴때! 아래와 같이 유니온 타입을 지정해서 사용하면 문제를 해결할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">padLeft</span><span class="p">(</span><span class="nx">value</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">padding</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Array</span><span class="p">(</span><span class="nx">padding</span> <span class="o">+</span> <span class="mi">1</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">)</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">padding</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">padding</span> <span class="o">+</span> <span class="nx">value</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">throw</span> <span class="k">new</span> <span class="nb">Error</span><span class="p">(</span><span class="s2">`Expected string or number, got '</span><span class="p">${</span><span class="k">typeof</span> <span class="nx">padding</span><span class="p">}</span><span class="s2">'.`</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="nx">padLeft</span><span class="p">(</span><span class="dl">"</span><span class="s2">Hello world</span><span class="dl">"</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span> <span class="c1">// 'boolean' 형식의 인수는 'string | number' 형식의 매개 변수에 할당될 수 없습니다.</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="공통-타입이-있는-유니온union-type">공통 타입이 있는 유니온(Union Type)</h2>
<p>유니온 타입을 사용할 때 주의해야할 점은 만약 공통적인 타입 유형이 있는 경우에는 모든 유형에 대해 유효한 경우에만 엑세스할 수 있다는 것이다.</p>

<p>아래의 코드를 보면 더 쉽게 이해할 수 있다.</p>

<h3 id="예제1">예제1</h3>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">person</span> <span class="p">{</span>
  <span class="nx">name</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">age</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kr">interface</span> <span class="nx">person2</span> <span class="p">{</span>
  <span class="nx">name</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
  <span class="nx">address</span><span class="p">():</span> <span class="k">void</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kr">declare</span> <span class="kd">function</span> <span class="nx">getSmallPet</span><span class="p">():</span> <span class="nx">person</span> <span class="o">|</span> <span class="nx">person2</span><span class="p">;</span>
 
<span class="kd">let</span> <span class="nx">human</span> <span class="o">=</span> <span class="nx">getSmallPet</span><span class="p">();</span>
<span class="nx">human</span><span class="p">.</span><span class="nx">name</span><span class="p">();</span>
 
<span class="c1">// Only available in one of the two possible types</span>
<span class="nx">human</span><span class="p">.</span><span class="nx">address</span><span class="p">();</span> <span class="c1">// type error</span>
</code></pre></div></div>

<p>OR 조건이라며? 근데 왜 공통적인 멤버만 엑세스할 수 있는거지?! 라고 생각할 수 있다.
나도 처음엔 전부 사용할 수 있는 줄 알았지만, 타입스크립트는 불확실한 타입에 대해서는 모두 에러로 처리한다.</p>

<p>반대로 생각해보면, age만 들어올 수도 있고 addres만 들어올 수 있는 가능성이 있으므로 타입스크립트는 이러한 애매한 타입에 대해서는 과감하게 배재시키는 것 같다.
따라서, 타입스크립트에서는 좀더 직관적인 관점으로 바라볼 필요가 있다.</p>

<h3 id="예제2">예제2</h3>

<p>아래 예제 코드도 마찬가지로 Union의 모든 타입이 유효한 경우에만 작업을 허용한다.
예를 들어, <code class="language-plaintext highlighter-rouge">string</code> 타입에서만 사용할 수 있는 메서드를 <code class="language-plaintext highlighter-rouge">number | string</code>에서는 사용할 수 없다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">printId</span><span class="p">(</span><span class="nx">id</span><span class="p">:</span> <span class="kr">number</span> <span class="o">|</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">id</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">// 'string | number' 형식에 'toUpperCase' 속성이 없습니다.</span>
<span class="c1">// 'number' 형식에 'toUpperCase' 속성이 없습니다.</span>
</code></pre></div></div>

<h3 id="해결책">해결책</h3>

<p>해결책은 코드와의 결합을 좁히는 것이다. 좁히는 방법은 타입스크립트의 코드 구조를 기반으로 값에 대해 보다 구체적인 유형을 추론할 수 있도록 해주는 것이다.</p>

<p>예를 들어 타입스크립트 값에는 오직 <code class="language-plaintext highlighter-rouge">string</code>이 있다는 것을 알고 싶다면 <code class="language-plaintext highlighter-rouge">typeof "string"</code> 조건을 사용하는 것이다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">printId</span><span class="p">(</span><span class="nx">id</span><span class="p">:</span> <span class="kr">number</span> <span class="o">|</span> <span class="kr">string</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">id</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">id</span><span class="p">.</span><span class="nx">toUpperCase</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 여기는, id는 number 타입이다.</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">id</span><span class="p">)</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="nx">printId</span><span class="p">(</span><span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// STRING</span>
<span class="nx">printId</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span> <span class="c1">// 100</span>
</code></pre></div></div>

<p>이처럼 해당 타입을 확실히 허용할 수 있는 조건을 걸어주면 해당 타입으로 작업을 진행할 수 있다.</p>

<p><br /></p>

<h2 id="discriminating-unions">Discriminating Unions</h2>
<p>공용체 작업을 위한 일반적인 기술은 타입스크립트가 현재 유형을 좁히는 데 사용할 수 있는 리터럴 타입을 사용하는 단일 필드를 갖는 것이다.</p>

<p>예를 들어, <code class="language-plaintext highlighter-rouge">state</code>라는 단일 공유 필드가 있는 세 가지 유형의 공용체를 만들 것이다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">LoadingState</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">state</span><span class="p">:</span> <span class="dl">'</span><span class="s1">loading</span><span class="dl">'</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">type</span> <span class="nx">FaildState</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">state</span><span class="p">:</span> <span class="dl">'</span><span class="s1">failed</span><span class="dl">'</span><span class="p">;</span>
  <span class="nl">code</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">};</span>

<span class="kd">type</span> <span class="nx">SuccessState</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">state</span><span class="p">:</span> <span class="dl">'</span><span class="s1">success</span><span class="dl">'</span><span class="p">;</span>
  <span class="nl">response</span><span class="p">:</span> <span class="p">{</span>
    <span class="na">title</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
    <span class="nl">duration</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
    <span class="nl">summary</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">workState</span> <span class="o">=</span> 
  <span class="o">|</span> <span class="nx">LoadingState</span>
  <span class="o">|</span> <span class="nx">FaildState</span>
  <span class="o">|</span> <span class="nx">SuccessState</span><span class="p">;</span>
</code></pre></div></div>

<p>위의 모든 유형에는 <code class="language-plaintext highlighter-rouge">state</code>라는 공통의 필드가 있으며 고유한 필드도 존재한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">LoadingState</th>
      <th style="text-align: left">FaildState</th>
      <th style="text-align: left">SuccessState</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">state</td>
      <td style="text-align: left">state</td>
      <td style="text-align: left">state</td>
    </tr>
    <tr>
      <td style="text-align: left"> </td>
      <td style="text-align: left">code</td>
      <td style="text-align: left">response</td>
    </tr>
  </tbody>
</table>

<p><code class="language-plaintext highlighter-rouge">state</code> 필드가 모든 유형에서 공통적으로 들어있다는 것을 감안했을 때, <code class="language-plaintext highlighter-rouge">workState</code> 코드에서는 존재 유무 확인없이 엑세스하는 것이 안전하다.</p>

<p><code class="language-plaintext highlighter-rouge">state</code>를 리터럴 타입으로 사용하면, 해당 문자열과 <code class="language-plaintext highlighter-rouge">state</code>값을 비교할 수 있다.
또한, state는 현재 타입스크립트에서 사용 중인 유형인 것을 알 수 있다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">LoadingState</th>
      <th style="text-align: left">FaildState</th>
      <th style="text-align: left">SuccessState</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">"loading"</td>
      <td style="text-align: left">"failed"</td>
      <td style="text-align: left">"success"</td>
    </tr>
  </tbody>
</table>

<p>이 경우, <code class="language-plaintext highlighter-rouge">switch</code>문을 사용하여 런타임에 표시되는 유형을 좁힐 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">workState</span> <span class="o">=</span> 
  <span class="o">|</span> <span class="nx">LoadingState</span>
  <span class="o">|</span> <span class="nx">FaildState</span>
  <span class="o">|</span> <span class="nx">SuccessState</span><span class="p">;</span>


<span class="kd">function</span> <span class="nx">logger</span><span class="p">(</span><span class="nx">state</span><span class="p">:</span> <span class="nx">workState</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  
  <span class="k">switch</span> <span class="p">(</span><span class="nx">state</span><span class="p">.</span><span class="nx">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">loading</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="dl">"</span><span class="s2">Downloading...</span><span class="dl">"</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">failed</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="s2">`Error </span><span class="p">${</span><span class="nx">state</span><span class="p">.</span><span class="nx">code</span><span class="p">}</span><span class="s2"> downloading`</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">success</span><span class="dl">"</span><span class="p">:</span>
      <span class="k">return</span> <span class="s2">`Downloaded </span><span class="p">${</span><span class="nx">state</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">title</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nx">state</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">duration</span><span class="p">}</span><span class="s2"> - </span><span class="p">${</span><span class="nx">state</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">summary</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kd">const</span> <span class="nx">loading</span><span class="p">:</span> <span class="nx">workState</span> <span class="o">=</span> <span class="p">{</span><span class="na">state</span><span class="p">:</span><span class="dl">'</span><span class="s1">loading</span><span class="dl">'</span><span class="p">};</span>
<span class="kd">const</span> <span class="nx">failed</span><span class="p">:</span> <span class="nx">workState</span> <span class="o">=</span> <span class="p">{</span><span class="na">state</span><span class="p">:</span><span class="dl">'</span><span class="s1">failed</span><span class="dl">'</span><span class="p">,</span> <span class="na">code</span><span class="p">:</span><span class="mi">200</span><span class="p">};</span>
<span class="kd">const</span> <span class="nx">success</span><span class="p">:</span> <span class="nx">workState</span> <span class="o">=</span> <span class="p">{</span><span class="na">state</span><span class="p">:</span><span class="dl">'</span><span class="s1">success</span><span class="dl">'</span><span class="p">,</span> <span class="na">response</span><span class="p">:{</span><span class="na">title</span><span class="p">:</span><span class="dl">'</span><span class="s1">test</span><span class="dl">'</span><span class="p">,</span> <span class="na">duration</span><span class="p">:</span><span class="mi">10</span><span class="p">,</span> <span class="na">summary</span><span class="p">:</span><span class="dl">'</span><span class="s1">success!!!</span><span class="dl">'</span><span class="p">}};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">logger</span><span class="p">(</span><span class="nx">loading</span><span class="p">))</span> <span class="c1">// Downloading...</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">logger</span><span class="p">(</span><span class="nx">failed</span><span class="p">))</span>  <span class="c1">// Error 200 downloading</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">logger</span><span class="p">(</span><span class="nx">success</span><span class="p">))</span> <span class="c1">// Downloaded test - 10 - success!!!</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="인터섹션-타입intersection-type">인터섹션 타입(Intersection Type)</h2>
<p>인터섹션 타입은 유니온 타입과 다르게 어려 타입을 모두 만족하는 하나의 타입을 의미한다.</p>

<p>아래의 코드를 보자.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">NetError</span> <span class="p">{</span>
  <span class="nl">success</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
  <span class="nl">error</span><span class="p">?:</span> <span class="p">{</span> <span class="na">message</span><span class="p">:</span> <span class="kr">string</span> <span class="p">};</span>
<span class="p">}</span>

<span class="kr">interface</span> <span class="nx">networking</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">networkingResponse</span> <span class="o">=</span> <span class="nx">networking</span> <span class="o">&amp;</span> <span class="nx">NetError</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">handleNetworking</span> <span class="o">=</span> <span class="p">(</span><span class="nx">response</span><span class="p">:</span> <span class="nx">networkingResponse</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">error</span><span class="p">.</span><span class="nx">message</span><span class="p">);</span>
    <span class="k">return</span> <span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">response</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">error</span><span class="p">:</span> <span class="nx">networkingResponse</span> <span class="o">=</span>  <span class="p">{</span> <span class="na">success</span><span class="p">:</span> <span class="kc">false</span><span class="p">,</span> <span class="na">error</span><span class="p">:</span> <span class="p">{</span><span class="na">message</span><span class="p">:</span> <span class="dl">'</span><span class="s1">500</span><span class="dl">'</span><span class="p">},</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">통신</span><span class="dl">'</span><span class="p">}</span>
<span class="kd">const</span> <span class="nx">success</span><span class="p">:</span> <span class="nx">networkingResponse</span> <span class="o">=</span>  <span class="p">{</span> <span class="na">success</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">통신</span><span class="dl">'</span><span class="p">}</span>

<span class="c1">// error</span>
<span class="nx">handleNetworking</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="c1">// 500</span>
<span class="c1">//success</span>
<span class="nx">handleNetworking</span><span class="p">(</span><span class="nx">success</span><span class="p">)</span> <span class="c1">// 통신</span>
</code></pre></div></div>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="nl">success</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>
  <span class="nl">error</span><span class="p">?:</span> <span class="p">{</span> <span class="na">message</span><span class="p">:</span> <span class="kr">string</span> <span class="p">};</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>
<p>이처럼 <code class="language-plaintext highlighter-rouge">&amp;</code> 연산자를 이용해 여러 개의 타입 정의를 하나로 합치는 방식을 인터섹션 타입 정의 방식이라고 한다.</p>]]></content><author><name>GitHub User</name></author><category term="Typescirpt" /><category term="Typescirpt" /><category term="Javascript" /><category term="ES6" /><summary type="html"><![CDATA[유니온 타입(Union Type) 유니온 타입이란, 자바스크립트의 OR 연산자(||)와 같은 의미를 갖는다.]]></summary></entry><entry><title type="html">[TypeScript] 타입스크립트의 추론, 호환, 별칭</title><link href="http://localhost:4000/typescirpt/2022/07/13/typescript-04.html" rel="alternate" type="text/html" title="[TypeScript] 타입스크립트의 추론, 호환, 별칭" /><published>2022-07-13T00:00:00+09:00</published><updated>2022-07-13T00:00:00+09:00</updated><id>http://localhost:4000/typescirpt/2022/07/13/typescript-04</id><content type="html" xml:base="http://localhost:4000/typescirpt/2022/07/13/typescript-04.html"><![CDATA[<h2 id="타입-추론tpye-inference">타입 추론(Tpye Inference)</h2>
<p>타입 추론이란, 타입스크립트가 코드를 해석해 나가는 동작을 의미한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">y</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">x</span><span class="p">);</span> <span class="c1">// number</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">y</span><span class="p">);</span> <span class="c1">// string</span>
</code></pre></div></div>

<p>위와 같이 <code class="language-plaintext highlighter-rouge">x</code>와 <code class="language-plaintext highlighter-rouge">y</code>에 타입을 따로 지정하지 않더라도 x는 number로 y는 string 타입으로 간주한다. 변수를 선언하거나 초기화 단계에서 타입이 추론된다.
이외에도 변수, 속성, 인자의 기본 값, 함수의 반환 값 등을 설정할 때 타입 추론이 일어난다.</p>

<h3 id="best-common-type">Best Common Type</h3>
<p>타입은 보통 몇 개의 표현식을 바탕으로 타입을 추론한다. 해당 표현식을 이용하여 가장 근접한 타입을 추론하는데 이 때 가장 근전합 타입을 <code class="language-plaintext highlighter-rouge">Best Common Type</code>이라고 한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">le</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">null</span><span class="p">];</span>
</code></pre></div></div>

<p>위 변수 <code class="language-plaintext highlighter-rouge">arr</code>의 타입을 추론하기 위해서는 배열의 값들을 살펴봐야 한다. 배열안에 있는 값들은 <code class="language-plaintext highlighter-rouge">number</code>과 <code class="language-plaintext highlighter-rouge">null</code> 타입으로 구분된다.
이 때 <code class="language-plaintext highlighter-rouge">Best Common Type</code> 알고리즘으로 다른 타입들과 가장 잘 호환되는 타입을 선정한다.</p>

<p><br /></p>

<h3 id="문맥에-맞는-타이핑contextual-typing">문맥에 맞는 타이핑(Contextual Typing)</h3>
<p>타입스크립트는 경우에 따라 또 다른 방식으로 타입을 결정한다. 이것을 <code class="language-plaintext highlighter-rouge">컨텍스트 타이핑</code>이라고 한다. 이 컨텍스트 타이핑은 코드 위치를 기준으로 결정한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onmousedown</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">mouseEvent</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">mouseEvent</span><span class="p">.</span><span class="nx">button</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">mouseEvent</span><span class="p">.</span><span class="nx">kangaroo</span><span class="p">);</span>
<span class="c1">// Property 'kangaroo' does not exist on type 'MouseEvent'.</span>
<span class="p">};</span>
</code></pre></div></div>
<p>위 코드를 타입스크립트 검사기 관점으로 본다면 <code class="language-plaintext highlighter-rouge">window.onmousedown</code>에 할당되는 함수의 타입을 추론하기 위해서 <code class="language-plaintext highlighter-rouge">window.onmousedown</code> 타입을 검사한다.
타입 검사가 끝나면 함수의 타입이 마우스 이벤트와 연관 있다고 추론하기 때문에 <code class="language-plaintext highlighter-rouge">mouseEvent</code> 인자에 button 속성은 존재하지만 kangaroo 속성은 없다고 결론을 내린다.</p>

<p><br /></p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onscroll</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">uiEvent</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uiEvent</span><span class="p">.</span><span class="nx">button</span><span class="p">);</span>
<span class="c1">// Property 'button' does not exist on type 'Event'.</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 다른 예제를 살펴보면 타입스크립트는 오른쪽 함수는 <code class="language-plaintext highlighter-rouge">window.onscroll</code>에 할당되었기 때문에 <code class="language-plaintext highlighter-rouge">uiEvent</code>는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/UIEvent">UIEvent</a>로 알고 있다. 따라서, 이전 예제와 같이 <a href="https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent">MouseEvent</a>와 다르게 <code class="language-plaintext highlighter-rouge">button</code> 속성이 없다고 추론하기 때문에 속성이 없다고 결론내리는 것이다.</p>

<p><br /></p>

<p>실제로 uiEvent에는 어떤 속성들이 있는지 확인해보자.
크롬 콘솔창에 window를 입력하면 아래와같이 전역객체의 속성들이 쭈~욱 나온다. 거기서 onscroll을 보면 <code class="language-plaintext highlighter-rouge">null</code>로 되어있을 것이다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span> <span class="c1">// 크롬 콘솔에 입력</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/52439201/178660218-b88b4bcd-3909-47d8-a46a-762958e5666e.png" alt="image" /></p>

<p><br /></p>

<p>그리고 아래와 같이 입력 후 마우스 스크롤을 움직여 보면 아래와 같이 속성값들을 확인할 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">window</span><span class="p">.</span><span class="nx">onscroll</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">uiEvent</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uiEvent</span><span class="p">);</span>
<span class="c1">// Property 'button' does not exist on type 'Event'.</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://user-images.githubusercontent.com/52439201/178660569-85c50ba8-6cfe-4171-892d-8483668f5f16.png" alt="image" /></p>

<p><br /></p>

<p><code class="language-plaintext highlighter-rouge">컨텍스트 타이핑</code>을 더 이해하기 위해서는 아래와 같이 코드를 바꿔서 확인해보자.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">handler</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">uiEvent</span><span class="p">){</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">uiEvent</span><span class="p">.</span><span class="nx">button</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 예제코드와 동일하지만, 함수에 할당되는 변수만으로는 타입을 추론하기 어렵다. 그렇기 때문에 타입스크립트는 에러로 발생시키지 않는다.</p>

<blockquote>
  <p><strong>참고!</strong><br />
현재 uiEvent 인자에 타입을 지정하지 않아도 에러가 발생하지 않는다. 단, 타입스크립트 config에 –noImplicitAny 옵션을 true로 지정하면 에러가 발생한다.</p>
</blockquote>

<p><br /></p>

<h3 id="타입스크립트의-타입-체킹">타입스크립트의 타입 체킹</h3>

<p>타입 체킹에 있어 타입스크립트의 지향점은 타입 체크는 값의 형태에 기반하여 이루어져야 한다는 점이다.<br />
이것을 <code class="language-plaintext highlighter-rouge">Duck Typing</code> 또는 <code class="language-plaintext highlighter-rouge">Structural Subtyping</code>이라고 한다.</p>

<ul>
  <li>Duck Typing: 객체의 변수 및 메서드의 집합이 객체의 타입을 결정하는 것을 의미한다. 동적 타이핑의 한 종류</li>
  <li>Structural Subtyping: 객체의 실제 구조나 정의에 따라 타입을 결정하는 것을 의미한다.</li>
</ul>

<p><br /></p>

<h2 id="타입-호환type-compatibility">타입 호환(Type Compatibility)</h2>
<p>타입 호환이란 타입스크립트에서 특정 타입이 다른 타입에 잘 맞는지를 의미한다.</p>

<p>예를 들어 아래와 같은 코드를 의미한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Ironman</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Avengers</span> <span class="p">{</span>
    <span class="nx">name</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">i</span><span class="p">:</span> <span class="nx">Ironman</span><span class="p">;</span>
<span class="nx">i</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Avengers</span><span class="p">();</span> <span class="c1">// OK, because of structural typing</span>


<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">i</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span>
</code></pre></div></div>

<p>C#, java와 같은 코드였다면 에러가 발생했을 것이다. 그 이유는 Avengers 클래스가 명시적으로 Ironman 인터페이스를 상속받은게 아니기 때문이다.</p>

<p>하지만, 자바스크립트는 정상적으로 동작한다.</p>

<p>그이유는, 자바스크립트의 작동 방식과 관련이 있다. 기본적으로 자바스크립트는 객체 리터럴이나 익명 함수 등을 사용하기 때문에 명시적으로 타입을 지정는 것보다는 코드의 구조 관점에서 타입울 지정하는 것이 잘 어울린다.</p>

<h3 id="구조적-타이핑">구조적 타이핑</h3>
<p>구조적 타이핑이란(structural typing)이란 코드 구조 관점에서 타입이 서로 호환되는지 여부를 판단하는 것이다.</p>

<p>아래 코드를 보자.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Avengers</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">hero</span><span class="p">:</span> <span class="nx">Avengers</span><span class="p">;</span>
<span class="c1">// 타입스크립트가 추론한 y의 타입은 { name: string; location: string; } 입니다.</span>
<span class="kd">let</span> <span class="nx">capt</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Captain</span><span class="dl">"</span><span class="p">,</span> <span class="na">location</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Pangyo</span><span class="dl">"</span> <span class="p">};</span>
<span class="nx">hero</span> <span class="o">=</span> <span class="nx">capt</span><span class="p">;</span>
</code></pre></div></div>

<p>위 코드에서 capt가 hero 타입에 호환될 수 있는 이유는 <code class="language-plaintext highlighter-rouge">capt</code> 속성 중에 <code class="language-plaintext highlighter-rouge">name</code>이 있기 때문이다. 만약에 name이 없다면 타입에러를 발생시킨다.
즉, <code class="language-plaintext highlighter-rouge">Avengers</code> 인터페이스에서 name 속성 값을 가지고 있기 때문에 capt는 Avengers에 호환될 수 있던 것이다.</p>

<p>함수를 호출할 때도 마찬가지로 작동한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Avengers</span> <span class="p">{</span>
  <span class="nl">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// capt 변수 타입은 { name: string; location: string; }</span>
<span class="kd">let</span> <span class="nx">capt</span> <span class="o">=</span> <span class="p">{</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Captain</span><span class="dl">"</span><span class="p">,</span> <span class="na">location</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Pangyo</span><span class="dl">"</span> <span class="p">};</span>

<span class="kd">function</span> <span class="nx">assemble</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="nx">Avengers</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">어벤져스 모여라</span><span class="dl">"</span><span class="p">,</span> <span class="nx">a</span><span class="p">.</span><span class="nx">name</span><span class="p">);</span>
<span class="p">}</span>
<span class="nx">assemble</span><span class="p">(</span><span class="nx">capt</span><span class="p">);</span> <span class="c1">// 어벤져스 모여라 Captain</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="soundness">Soundness</h3>
<p>타입스크립트는 컴파일 시점에서 타입을 추론할 수 없는 특정 타입에 경우는 일단 안전하다고 보는 특성이 있다. 
이걸 <code class="language-plaintext highlighter-rouge">"들리지 않는다(it is said to not be sound)"</code>라고 표현한다.</p>

<p><br /></p>

<h3 id="enum-타입-호환시-주의">Enum 타입 호환시 주의</h3>
<p>이넘 타입은 <code class="language-plaintext highlighter-rouge">number</code> 타입과 호환되지만 이넘 타입끼리는 호환되지 않는다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Status</span> <span class="p">{</span> <span class="nx">Ready</span><span class="p">,</span> <span class="nx">Waiting</span> <span class="p">};</span>
<span class="kr">enum</span> <span class="nx">Color</span> <span class="p">{</span> <span class="nx">Red</span><span class="p">,</span> <span class="nx">Blue</span><span class="p">,</span> <span class="nx">Green</span> <span class="p">};</span>

<span class="kd">let</span> <span class="nx">ready</span> <span class="o">=</span> <span class="nx">Status</span><span class="p">.</span><span class="nx">Ready</span>
<span class="nx">ready</span> <span class="o">=</span> <span class="nx">Color</span><span class="p">.</span><span class="nx">Red</span> <span class="c1">// Error</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="class-타입-호환시-주의">Class 타입 호환시 주의</h3>
<p>클래스 타입은 클래스 타입끼리 비교할 때 스태틱 멤버(static member)와 생성자(constructor)를 제외하고 속성만 비교한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">Hulk</span> <span class="p">{</span>
  <span class="nl">handSize</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">numHand</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Captain</span> <span class="p">{</span>
  <span class="nl">handSize</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">numHand</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nx">Iron</span> <span class="p">{</span>
  <span class="nl">footSize</span> <span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="kd">constructor</span><span class="p">(</span><span class="nx">numHand</span><span class="p">:</span> <span class="kr">number</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">hulk</span><span class="p">:</span> <span class="nx">Hulk</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">capt</span><span class="p">:</span> <span class="nx">Captain</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">iron</span> <span class="p">:</span> <span class="nx">Iron</span><span class="p">;</span>

<span class="nx">hulk</span> <span class="o">=</span> <span class="nx">capt</span><span class="p">;</span> <span class="c1">// ok</span>
<span class="nx">capt</span> <span class="o">=</span> <span class="nx">hulk</span><span class="p">;</span> <span class="c1">// ok</span>
<span class="nx">iron</span> <span class="o">=</span> <span class="nx">hulk</span><span class="p">;</span> <span class="c1">// 'footSize' 속성이 'Hulk' 형식에 없지만 'Iron' 형식에서 필수입니다.</span>
</code></pre></div></div>

<p>Hulk와 Captain은 생성자는 다르지만 속성은 똑같기 때문에 호환에 문제가 없다. 하지만, Iron과 Captaindms 생성자는 동일하지만 속성은 다르기 때문에 오류가 발생한다.</p>

<p><br /></p>

<h3 id="generics">Generics</h3>

<p>제네릭은 제네릭 타입 간의 호환 여부를 판단할 때 타입 인자 <code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>가 속성에 할당 되었는지를 기준으로 판단한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Empty</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">x</span><span class="p">:</span> <span class="nx">Empty</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">y</span><span class="p">:</span> <span class="nx">Empty</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">;</span>

<span class="nx">x</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>  <span class="c1">// OK, because y matches structure of x</span>
</code></pre></div></div>

<p>위의 인터페이스는 속성(member 변수)가 없기 때문에 x와 y를 같은 타입으로 간주한다.<br />
하지만 아래와 같이 인터페이스에 속성이 있다면 제네릭의 타입 인자가 속성에 할당되기 때문에 x와 y는 서로 다른 타입으로 간주된다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Empty</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="na">data</span> <span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">let</span> <span class="nx">x</span><span class="p">:</span> <span class="nx">Empty</span><span class="o">&lt;</span><span class="kr">number</span><span class="o">&gt;</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">y</span><span class="p">:</span> <span class="nx">Empty</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">;</span>

<span class="nx">x</span> <span class="o">=</span> <span class="nx">y</span><span class="p">;</span>  <span class="c1">// 'Empty&lt;string&gt;' 형식은 'Empty&lt;number&gt;' 형식에 할당할 수 없습니다.</span>
        <span class="c1">// 'string' 형식은 'number' 형식에 할당할 수 없습니다</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="타입-별칭type-aliases">타입 별칭(Type Aliases)</h2>
<p>타입 별칭은 특정 타입이나 인터페이스를 참조할 수 있는 타입 변수를 의미한다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// string 타입을 사용할 때</span>
<span class="kd">const</span> <span class="nx">name</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">;</span>

<span class="c1">// 타입 별칭을 사용할 때</span>
<span class="kd">type</span> <span class="nx">MyName</span> <span class="o">=</span> <span class="kr">string</span><span class="p">;</span>
<span class="kd">const</span> <span class="nx">name</span><span class="p">:</span> <span class="nx">MyName</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">;</span>
</code></pre></div></div>

<p>간단한 타입 뿐만 아니라 <code class="language-plaintext highlighter-rouge">interface</code> 레벨의 복잡한 타입에서도 별칭을 부여할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">intro</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">address</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">age</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">who</span><span class="p">:</span> <span class="nx">intro</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">siksik</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">address</span><span class="p">:</span> <span class="dl">'</span><span class="s1">seoul</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="타입-별칭의-특징">타입 별칭의 특징</h3>
<p>타입 별칭을 사용하는 이유는, 타입 값을 새로 생성하는 의미보다는 별칭을 부여하여 나중에 쉽게 참고할 수 있도록 이름을 사용하는 것이다.<br />
이러한 특징이 VSCode 상의 프리뷰 상태로 다른 타입과 어떤 차이점이 있는지 확인해볼 수 있다.</p>

<p><img src="https://user-images.githubusercontent.com/52439201/179450019-71bf6ec8-d1a8-4229-a541-cda1be7ad1b3.png" alt="image" /></p>

<p><img src="https://user-images.githubusercontent.com/52439201/179450095-62e4898f-7cae-4040-8463-a6a50d0b9c7a.png" alt="image" /></p>

<h3 id="type-vs-interface">type vs interface</h3>
<p>타입 별칭과 인터페이스의 가장 큰 차이는 타입의 <code class="language-plaintext highlighter-rouge">확장 여부(가능/불가능)</code>이다.<br />
인터페이스는 확장이 가능한 반면 타입 별칭은 확장이 불가능하다. 따라서, 가능하면 <code class="language-plaintext highlighter-rouge">type</code> 보다는 <code class="language-plaintext highlighter-rouge">interface</code>를 사용하는 것을 추천한다.</p>]]></content><author><name>GitHub User</name></author><category term="Typescirpt" /><category term="Typescirpt" /><category term="Javascript" /><category term="ES6" /><summary type="html"><![CDATA[타입 추론(Tpye Inference) 타입 추론이란, 타입스크립트가 코드를 해석해 나가는 동작을 의미한다.]]></summary></entry><entry><title type="html">[TypeScript] 변수와 함수 타입 정의</title><link href="http://localhost:4000/typescirpt/2022/07/05/typescript-03.html" rel="alternate" type="text/html" title="[TypeScript] 변수와 함수 타입 정의" /><published>2022-07-05T00:00:00+09:00</published><updated>2022-07-05T00:00:00+09:00</updated><id>http://localhost:4000/typescirpt/2022/07/05/typescript-03</id><content type="html" xml:base="http://localhost:4000/typescirpt/2022/07/05/typescript-03.html"><![CDATA[<h2 id="자바스크립트에-타입-추가하는-방법">자바스크립트에 타입 추가하는 방법</h2>

<p>밑의 자바스크립트에서 sum이라는 함수에 들어가는 파라미터 a,b에 타입을 지정해줄 수 있는 방법이 있다.</p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="dl">'</span><span class="s1">10</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">/** */</code> 주석처리 안에다 <code class="language-plaintext highlighter-rouge">@param {type} 파라미터명</code>을 적어주고 리턴되는 값도 <code class="language-plaintext highlighter-rouge">@returns {type}</code>으로 지정해 줄 수 있다.</li>
  <li>타입스크립트처럼 에러를 에디터에서 확인하려면 <code class="language-plaintext highlighter-rouge">@ts-check</code>를 주석에 넣어주면 에러를 발생시켜준다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// @ts-check</span>

<span class="cm">/**
 * 
 * @param {number} a 
 * @param {number} b 
 * @returns {number}
 */</span>
<span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span><span class="nx">b</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="o">+</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">;</span> 
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="dl">'</span><span class="s1">10</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>리턴값은 number 타입을 줬기 때문에 string 형식을 지정할 수 없다는 에러가 발생되고, sum() 함수에도 number 타입의 파라미터만 입력받을 수 있으므로 에러를 발생시키게 된다.</p>

<p><img src="https://user-images.githubusercontent.com/52439201/177474279-b39c40ba-6b84-4827-9840-708091d06101.png" alt="스크린샷 2022-07-06 오후 2 18 26" /></p>

<p><br /></p>

<h2 id="기본-타입-정의">기본 타입 정의</h2>

<h3 id="string">String</h3>

<p>자바스크립트에서 변수 타입이 문자열이면 아래와 같이 <code class="language-plaintext highlighter-rouge">string</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">str</span><span class="p">:</span> <span class="nx">string</span><span class="p">;</span>
<span class="nx">str</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
<span class="nx">str</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> <span class="c1">// error</span>
</code></pre></div></div>

<h3 id="number">number</h3>
<p>자바스크립트에서 변수 타입이 숫자면 아래와 같이 <code class="language-plaintext highlighter-rouge">number</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">number</span><span class="p">:</span> <span class="nx">number</span><span class="p">;</span>
<span class="nx">number</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// error</span>
<span class="nx">number</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="boolean">boolean</h3>
<p>자바스크립트에서 변수 타입이 불린이면 아래와 같이 <code class="language-plaintext highlighter-rouge">boolean</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">boolean</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">;</span>

<span class="nx">boolean</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="nx">boolean</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
<span class="nx">boolean</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span> <span class="c1">// error</span>
</code></pre></div></div>
<h3 id="object">Object</h3>
<p>자바스크립트에서 변수 타입이 객체이면 아래와 같이 <code class="language-plaintext highlighter-rouge">{var1: type1, var2: type2}</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">person</span><span class="p">:</span> <span class="p">{</span><span class="nl">name</span><span class="p">:</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="nx">number</span><span class="p">}</span>

<span class="nx">person</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span> <span class="dl">'</span><span class="s1">seongsik</span><span class="dl">'</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span>
<span class="nx">person</span> <span class="o">=</span> <span class="p">{</span><span class="na">name</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="na">age</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span> <span class="c1">// name은 string 타입이므로 number 타입은 사용 x =&gt; error </span>
</code></pre></div></div>

<h3 id="array">Array</h3>
<p>자바스크립트에서 변수 타입이 배열이면 아래와 같이 <code class="language-plaintext highlighter-rouge">Array&lt;type&gt; or type[]</code> 타입을 선언해서 사용한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">number_arr</span><span class="p">:</span> <span class="nx">number</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">string_arr</span><span class="p">:</span> <span class="nx">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">boolean_arr</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>
</code></pre></div></div>
<p>또는 아래와 같이 제네릭으로 사용할 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">number_arr</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">number</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">string_arr</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">string</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">1</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">2</span><span class="dl">'</span><span class="p">,</span><span class="dl">'</span><span class="s1">3</span><span class="dl">'</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">boolean_arr</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">boolean</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[</span><span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="tuple">Tuple</h3>
<ul>
  <li>튜플은 배열의 길이가 고정되고 각 요소의 타입이 지정되어 있는 배열 형식을 의미한다.</li>
  <li>자바스크립트에서 변수 타입이 튜플이면 아래와 같이 <code class="language-plaintext highlighter-rouge">[type1, type2]</code> 타입을 선언해서 사용한다.</li>
  <li>길이가 고정되어 있고 각 자리마다 타입을 선언하기 때문에, 정의되지 않는 인덱스에 접근하거나 정의하지 않는 타입이면 에러가 발생한다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">tuple_arr</span><span class="p">:</span> <span class="p">[</span><span class="nx">string</span><span class="p">,</span> <span class="nx">number</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">hi</span><span class="dl">'</span><span class="p">,</span> <span class="mi">10</span><span class="p">];</span>

<span class="nx">tuple_arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="c1">// 길이가 '2'인 튜플 형식 '[string, number]'의 인덱스 '2'에 요소가 없습니다.</span>
<span class="nx">tuple_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="nx">concat</span><span class="p">(</span><span class="dl">'</span><span class="s1">!</span><span class="dl">'</span><span class="p">)</span> <span class="c1">// 'number' 형식에 'concat' 속성이 없습니다.</span>
</code></pre></div></div>

<h3 id="any">Any</h3>
<p>기존에 자바스크립트로 구현되어 있는 웹 서비스 코드에 타입스크립트를 점진적으로 적용할 때 활용하면 좋은 타입이다. 단어 의미 그대로 모든 타입에 대해서 허용한다는 의미를 갖고 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">string</span><span class="p">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">hello</span><span class="dl">'</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">number</span><span class="p">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">boolean</span><span class="p">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">arr</span><span class="p">:</span> <span class="nx">any</span> <span class="o">=</span> <span class="p">[</span><span class="dl">'</span><span class="s1">hi</span><span class="dl">'</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="kc">true</span><span class="p">];</span>
</code></pre></div></div>

<h3 id="void">Void</h3>
<ul>
  <li>변수에는 undefined와 null만 할당하고, 함수에는 반환 값을 설정할 수 없는 타입이다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">void_type</span><span class="p">:</span> <span class="k">void</span><span class="p">;</span>
<span class="nx">void_type</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>  <span class="c1">// 'number' 형식은 'void' 형식에 할당할 수 없습니다.</span>
<span class="nx">void_type</span> <span class="o">=</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">;</span> <span class="c1">// 'string' 형식은 'void' 형식에 할당할 수 없습니다.</span>

<span class="kd">function</span> <span class="nx">void_fn</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">void</span><span class="dl">'</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">void_fn</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">'</span><span class="s1">void</span><span class="dl">'</span><span class="p">);</span>
  <span class="k">return</span> <span class="mi">100</span><span class="p">;</span> <span class="c1">//'number' 형식은 'void' 형식에 할당할 수 없습니다.</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="enum">Enum</h3>
<ul>
  <li>Enum 타입은 C, Java와 같은 다른 언어에서 흔하게 쓰이는 타입으로 특정 값(상수)들의 집합을 의미한다.</li>
  <li>Enum 타입은 객체의 키값으로도 접근가능하며, 배열의 인덱스로도 접근이 가능하다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Avengers</span> <span class="p">{</span><span class="nx">Capt</span><span class="p">,</span> <span class="nx">IronMan</span><span class="p">,</span> <span class="nx">Thor</span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">hero</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">.</span><span class="nx">Capt</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">hero2</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">.</span><span class="nx">IronMan</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">hero3</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">.</span><span class="nx">Thor</span><span class="p">;</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Avengers</span><span class="p">)</span> <span class="c1">// {0: 'Capt', 1: 'IronMan', 2: 'Thor', Capt: 0, IronMan: 1, Thor: 2}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero</span><span class="p">);</span> <span class="c1">// 0</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero2</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero3</span><span class="p">);</span> <span class="c1">// 2</span>
</code></pre></div></div>

<p>Enum은 인덱스 번호로도 접근할 수 있다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Avengers</span> <span class="p">{</span><span class="nx">Capt</span><span class="p">,</span> <span class="nx">IronMan</span><span class="p">,</span> <span class="nx">Thor</span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">hero</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">hero2</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">hero3</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>


<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero</span><span class="p">);</span> <span class="c1">// Capt</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero2</span><span class="p">);</span> <span class="c1">// IronMan</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero3</span><span class="p">);</span> <span class="c1">// Thor</span>
</code></pre></div></div>

<ul>
  <li>Enum의 인덱스를 사용자 편의로 변경하여 사용할 수도 있다.</li>
  <li>주의헤야할 점은 특정 값의 인덱스를 편의로 변경하면 그 뒤에 오는 값들은 변경한 인덱스 값을 기준으로 순차적으로 갖게된다.</li>
  <li>가령 Capt는 인덱스를 2부터 시작하므로 IronMan는 3, Thor는 4를 갖게 된다.</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">enum</span> <span class="nx">Avengers</span> <span class="p">{</span><span class="nx">Capt</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="nx">IronMan</span><span class="p">,</span> <span class="nx">Thor</span><span class="p">}</span>
<span class="kd">let</span> <span class="nx">hero</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">hero2</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">hero3</span> <span class="o">=</span> <span class="nx">Avengers</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">Avengers</span><span class="p">)</span> <span class="c1">// {2: 'Capt', 3: 'IronMan', 4: 'Thor', Capt: 2, IronMan: 3, Thor: 4}</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero2</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">hero3</span><span class="p">);</span> <span class="c1">// Capt</span>
</code></pre></div></div>

<p><br /></p>

<h2 id="함수-타입">함수 타입</h2>

<p>함수를 타입스크립트로 크게 3가지로 정의할 수 있다.</p>

<ul>
  <li>함수의 파라미터(매개변수) 타입</li>
  <li>함수의 반환 타입</li>
  <li>함수의 구조 타입</li>
</ul>

<h3 id="함수의-기본-타입-정의">함수의 기본 타입 정의</h3>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">profile</span><span class="p">(</span><span class="nx">name</span><span class="p">,</span> <span class="nx">address</span><span class="p">,</span> <span class="nx">age</span><span class="p">){</span>
  <span class="k">return</span> <span class="s2">`이름 : </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">, 주소 : </span><span class="p">${</span><span class="nx">address</span><span class="p">}</span><span class="s2">, 나이 : </span><span class="p">${</span><span class="nx">age</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위의 자바스크립트 함수에 타입을 정의하면 아래와 같다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">profile</span><span class="p">(</span><span class="nx">name</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">address</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">age</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">string</span><span class="p">{</span>
  <span class="k">return</span> <span class="s2">`이름 : </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">, 주소 : </span><span class="p">${</span><span class="nx">address</span><span class="p">}</span><span class="s2">, 나이 : </span><span class="p">${</span><span class="nx">age</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>기존의 자바스크립트 함수 선언 방식에서 <code class="language-plaintext highlighter-rouge">매개변수의 타입</code>과 <code class="language-plaintext highlighter-rouge">반환 값의 타입</code>을 정의하였다.</p>

<p><br /></p>

<h3 id="함수의-파리미터">함수의 파리미터</h3>
<p>타입스크립트에서는 함수의 파라미터를 필수 값으로 간주한다. 따라서, 함수를 선언할 때 매개변수를 설정하게 되면 <code class="language-plaintext highlighter-rouge">undefined</code>나 <code class="language-plaintext highlighter-rouge">null</code>이라도 인자로 넘겨줘야 한다. 그 다음 컴파일러에서는 정의된 매개변수 값들이 넘어왔는지 확인한다. 달리 말하면 정의한 매개변수 값만 받을 수 있으며 추가 인자는 받을 수 없다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">c</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="o">+</span><span class="nx">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// error, 3개의 인수가 필요한데 1개를 가져왔습니다.</span>
<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// error, 3개의 인수가 필요한데 2개를 가져왔습니다.</span>
<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span> 
</code></pre></div></div>

<p><br /></p>

<p>함수의 매개변수 초기화는 ES6 문법과 동일하다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 110</span>
<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// 30</span>
</code></pre></div></div>

<p>위의 타입스크립트를 자바스크립트로 변환하게되면 아래와 같다. 따라서 b 파라미터가 void면 초기화 값을 리턴하고 아니면, 그 값을 대체한다.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">b</span> <span class="o">===</span> <span class="k">void</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="nx">b</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="함수의-rest-파라미터">함수의 REST 파라미터</h3>
<p>ES6 문법에서 지원하는 REST 파라미터는 타입스크리에서 다음과 같이 선언할 수 있다.</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="p">...</span><span class="nx">rest</span><span class="p">:</span> <span class="kr">number</span><span class="p">[]):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="kd">let</span> <span class="nx">total</span> <span class="o">=</span> <span class="mi">0</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">val</span> <span class="k">of</span> <span class="nx">rest</span><span class="p">){</span>
    <span class="nx">total</span> <span class="o">+=</span> <span class="nx">val</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">total</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span> <span class="c1">// 100</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="함수의-옵션-속성">함수의 옵션 속성</h3>
<p>위의 함수의 파라미터에서 매개변수를 정의하면 모두 필수 값으로 간주한다고 했다. 하지만, 정의된 매개변수의 갯수 만큼 인자를 넘기지 않아도 되는 옵션을 부과하고 싶다면 아래와 같이 <code class="language-plaintext highlighter-rouge">?</code>물음표를 붙이면 된다.</p>

<p><code class="language-plaintext highlighter-rouge">c</code> 파라미터 앞에 물음표를 붙이면 넘기거나/안넘기거나 선택할 수 있는 옵션을 부과하게 된다.</p>
<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="nx">a</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">b</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">c</span><span class="p">?:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">a</span><span class="o">+</span><span class="nx">b</span><span class="o">+</span><span class="nx">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span> <span class="c1">// 2~3개의 인수가 필요한데 1개의 인수만 가져왔습니다.</span>
<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">);</span> <span class="c1">// 30</span>
<span class="nx">sum</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">);</span> <span class="c1">// 60</span>
</code></pre></div></div>

<p><br /></p>

<h3 id="this">this</h3>
<p>타입스크립트에서 자바스크립트의 this가 잘못 사용되었을 때 감지할 수 있다. 타입스크립트에서 this가 가리키는 것을 명시하려면 아래와 같이 선언한다.</p>

<ul>
  <li>함수 호출에서 this는 전역객체를 참조하기 때문에 this의 타입으로 Window 타입을 선언했다.</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">sum</span><span class="p">(</span><span class="k">this</span><span class="p">:</span> <span class="nx">Window</span><span class="p">){</span>
  <span class="k">return</span> <span class="nx">x</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>자바스크립트에서는 객체의 함수에서 호출된다면 그 함수의 this는 해당 객체를 참조하게 된다. 따라서 init() 함수에서의 this는 <code class="language-plaintext highlighter-rouge">Vue</code>가 되므로 참조가 되는 객체를 명시하면 된다.</li>
</ul>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">interface</span> <span class="nx">Vue</span> <span class="p">{</span>
  <span class="nl">el</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="nl">count</span><span class="p">:</span> <span class="kr">number</span><span class="p">;</span>
  <span class="nx">init</span><span class="p">(</span><span class="k">this</span><span class="p">:</span> <span class="nx">Vue</span><span class="p">):</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{};</span>
<span class="p">}</span>

<span class="kd">let</span> <span class="nx">vm</span><span class="p">:</span> <span class="nx">Vue</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">el</span><span class="p">:</span> <span class="dl">'</span><span class="s1">#app</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">count</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
  <span class="na">init</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="na">this</span><span class="p">:</span> <span class="nx">Vue</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">count</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>


<span class="kd">let</span> <span class="nx">getCount</span> <span class="o">=</span> <span class="nx">vm</span><span class="p">.</span><span class="nx">init</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="nx">getCount</span><span class="p">();</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">count</span><span class="p">);</span> <span class="c1">// 10</span>
</code></pre></div></div>]]></content><author><name>GitHub User</name></author><category term="Typescirpt" /><category term="Typescirpt" /><category term="Javascript" /><category term="ES6" /><summary type="html"><![CDATA[자바스크립트에 타입 추가하는 방법]]></summary></entry><entry><title type="html">[Electron] 01. 일렉트론이란?</title><link href="http://localhost:4000/electron/2022/06/28/electron.html" rel="alternate" type="text/html" title="[Electron] 01. 일렉트론이란?" /><published>2022-06-28T00:00:00+09:00</published><updated>2022-06-28T00:00:00+09:00</updated><id>http://localhost:4000/electron/2022/06/28/electron</id><content type="html" xml:base="http://localhost:4000/electron/2022/06/28/electron.html"><![CDATA[<h2 id="일렉트론electron이란">일렉트론(Electron)이란?</h2>

<p>일렉트론은 Javascript, HTML, CSS 만으로도 데스크탑 앱을 만들 수 있는 프레임워크이다. 2013년 아톰 쉘(Atom Shell)이라 불리는 크로스 플랫폼 애플리케이션 쉘로 시작했으며 오픈소스화, 명칭 변경등을 거쳐 현재는 깃허브에서 개발하고 있다.</p>

<p>자바스크립트는 현재 전세계에서 가장 많은 개발자가 사용하는 프래그래밍 언어로 그 인기만큼 활용 범위가 커지고 있다. 그 중 하나가 일렉트론이다.
매년 발표되는 <a href="https://roadmap.sh/frontend">WEB Developer frontend roadmap</a>을 살펴보면 데스크탑 앱에 일렉트론이 있는 것을 확인할 수 있다.</p>

<p><br /></p>

<h2 id="일렉트론-특징">일렉트론 특징</h2>

<h3 id="웹기술">웹기술</h3>
<ul>
  <li>백엔드 : node.js 런타임</li>
  <li>프론트엔드 : Chromium(크로미엄, 오픈소스 웹브라우저 프로젝트) + (Javascript, HTML, CSS)를 이용 React, Vue, Angular도 사용가능하다.</li>
</ul>

<h3 id="오픈소스-기반">오픈소스 기반</h3>
<p>일렉트론은 Github가 관리하는 오픈소스 프로젝트이며 적극적인 참여자들과 함께하는 커뮤니티이다.</p>

<h3 id="장점">장점</h3>
<ul>
  <li>
    <p><strong>낮은 진입 장벽</strong>:<br />
일렉트론은 개발자의 진입 장벽이 낮다는 장점이 있다. Javascript, HTML, CSS 및 웹 기술을 다룰줄 아는 개발자라면 누구나 일렉트론 앱을 개발할 수 있다. 그 말은 따로 새로운 기술이나 언어를 배울 필요가 없기 때문에 기존의 웹 기술을 사용하던 개발자들은 어렵지 않게 시작할 수 있다.</p>
  </li>
  <li>
    <p><strong>개발 속도 향상</strong>: <br />
자바스크립트의 인터프리터 방식으로 개발자는 손쉽게 디버깅하고 최적화할 수 있어 일렉트론 앱을 빠르게 구현할 수 있다. 또한, 일렉트론으로 개발된 애플리케이션은 일반적으로 웹 애플리케이션의 비즈니스 로직, 디자인 및 구조를 재사용하기 때문에 개발에 소요되는 시간과 비용을 줄일 수 있다.</p>
  </li>
  <li>
    <p><strong>크로스 플랫폼</strong>:<br />
각기 다른 os 플랫폼을 지원한다는 장점이 있다. 데스크탑 앱을 개발할 때 각 os마다 최적화 작업을 진행해야하고 API선언 및 제공이 달라질 수 있으며 os별로 코드가 상이하기 때문에 유지보수에 어려움을 겪을 수 있다. 하지만 일렉트론은 이러한 이슈들을 해결할 수 있다. 맥, 윈도우, 리눅스별로 적합한 룩앤필을 맞추고 개발자들에게 친숙한 자바스크립트, HTML, CSS를 활용하여 개발하기 때문에 쉽게 애플리케이션을 구성할 수 있다.</p>
  </li>
</ul>

<p>또한, 한번에 세 가지 os에 대한 빌드를 지원하고 설치할 수 있도록 도와준다. 기존의 웹 기술을 그대로 사용하면서도 브라우저 버전별로 기능을 제약하거나 타겟 플랫폼에 따라 별도의 버전을 유지할 필요가 없게 된다. os 관련 어려운 부분은 일렉트론이 처리하기 때문에 개발자는 응용 프로그램에만 집중할 수 있다.</p>

<p>정리해서,</p>

<ul>
  <li>일렉트론은 웹 프론트엔드 기술을 사용할 수 있는 개발자라면 쉽게 사용할 수 있을 정도로 러닝커브가 낮다.</li>
  <li>일렉트론은 오픈소스 기반 프로젝트이므로 지속적인 업데이트와 큰 규모의 커뮤니티 생태계를 가지고 있다.</li>
  <li>크로스 플랫폼이라서 맥, 윈도우, 리눅스 환경 어디서든 구동할 수 있는 장점이 잇다.</li>
</ul>

<p><br /></p>

<h2 id="일렉트론-활용사례">일렉트론 활용사례</h2>

<p>그렇다면 일렉트론으로 개발한 애플리케이션은 무엇이 있을까?</p>

<p>대표적으로 <code class="language-plaintext highlighter-rouge">아톰 에디터</code>, <code class="language-plaintext highlighter-rouge">VSCode</code>, <code class="language-plaintext highlighter-rouge">슬랙</code>, <code class="language-plaintext highlighter-rouge">워드프레스</code> 등이 있으며 한국에서는 협업 툴로 유명한 <code class="language-plaintext highlighter-rouge">잔디</code>가 그 예시이다.
<a href="www.electronjs.org/apps">일렉트론 웹사이트</a>를 방문하면 카테고리별로 일렉트론으로 개발한 앱들을 확인할 수 있다.</p>]]></content><author><name>GitHub User</name></author><category term="Electron" /><category term="Node.js" /><category term="Javascript" /><summary type="html"><![CDATA[일렉트론(Electron)이란?]]></summary></entry><entry><title type="html">[Git] git flow 전략 파악하기</title><link href="http://localhost:4000/git/2022/06/26/git-10.html" rel="alternate" type="text/html" title="[Git] git flow 전략 파악하기" /><published>2022-06-26T00:00:00+09:00</published><updated>2022-06-26T00:00:00+09:00</updated><id>http://localhost:4000/git/2022/06/26/git-10</id><content type="html" xml:base="http://localhost:4000/git/2022/06/26/git-10.html"><![CDATA[<h2 id="git-flow-전략">git-flow 전략</h2>

<p>Git-flow는 총 5가지 브랜치를 사용하고 운영한다.</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">master</code> 브랜치 : 기준이 되는 브랜치로 제품을 배포하는 브랜치이다.</li>
  <li><code class="language-plaintext highlighter-rouge">develop</code> 브랜치 : 개발 브랜치로 개발자들이 이 브랜치를 기준으로 각자 작업한 기능들을 합(Merge)한다.</li>
  <li><code class="language-plaintext highlighter-rouge">feature</code> 브랜치 : 단위 기능을 개발하는 브랜치로 기능 개발이 완료되면 develop 브랜치에 합(Merge)한다.</li>
  <li><code class="language-plaintext highlighter-rouge">release</code> 브랜치 : 배포를 위해 master 브랜치로 보내기 전에 먼저 QA(품질검사)를 하기위한 브랜치이다.</li>
  <li><code class="language-plaintext highlighter-rouge">hotfix</code> 브랜치 : master 브랜치로 배포를 했는데 버그가 생겼을 떄 긴급 수정하는 브랜치이다.</li>
</ul>

<blockquote>
  <p>! 여기서 핵심이 되는 브랜치는 master 브랜치와 develop 브랜치이다. 나머지 브랜치는 필요에 의해 운영되는 브랜치라고 생각하면 된다.</p>
</blockquote>

<p><br /></p>

<h2 id="메인-브랜치master-develop">메인 브랜치(master, develop)</h2>

<p>git-flow 전략에서 핵심이 되는 브랜치는 master, develop 브랜치이다.</p>

<h3 id="master-브랜치">master 브랜치</h3>
<p>배포 가능한 상태만을 관리하는 브랜치로 안정적인 버전의 소스들만 관리되는 브랜치이다. master 브랜치의 HEAD는 최신 배포판의 소스코드 버전이 들어있다. master 브랜치는 지난 배포판의 소스코드를 따라가기 위해 태그(tag)들이 추가되어 있다. 이 태그를 확인해서 각 릴리즈 버전의 소스코드를 빠르게 확인한다.</p>

<p>정리해서, master 브랜치는 운영서버에 배포해야 되는 소스코드가 관리되어야 한다(안정성이 충분히 검증된 소스코드).</p>

<h3 id="develop-브랜치">develop 브랜치</h3>
<p>develop 브랜치는 다음에 배포할 것을 개발하는 브랜치이다. develop 브랜치는 통합 브랜치의 역할을 한다. 평소 개발자들은 이 브랜치를 기반으로 개발을 진행해야한다.
개발자들은 develop 브랜치에서 feature 브랜치를 생성하고, 소스코드 수정 및 기능 개발이 완료되면 develop 브랜치로 <code class="language-plaintext highlighter-rouge">풀 리퀘스트</code> 요청을 하게 된다.</p>

<p><br /></p>

<h2 id="feature-브랜치">feature 브랜치</h2>
<ul>
  <li>생성되어지는 브랜치 : develop</li>
  <li>merge 해야되는 브랜치 : develop</li>
</ul>

<p>feature 브랜치 또는 topic 브랜치라 부른다.</p>

<p>단위 기능을 개발하는 브랜치로 develop 브랜치의 HEAD에서 생성된다. 새로운 기능 개발을 하거나 버그 수정을 위한 코드 수정이 이뤄지는 브랜치로 이해하면 된다. 이 브랜치에서는 개발자 혼자 작업을 할 수 있도 있고, 특정 기능 개발을 위한 여러명의 개발자들이 공동으로 작업할 수도 있다.</p>

<p>feature 브랜치에서 작업이 완료되면 <code class="language-plaintext highlighter-rouge">풀 리퀘스트</code>를 요청하여 develop 브랜치에 <code class="language-plaintext highlighter-rouge">병합(merge)</code>하게 된다.</p>

<blockquote>
  <p>여기서 주의해야할 점은 feature 브랜치를 생성한 목적이 완료될 때까지 유지해야하고 다 완성되면 develop 브랜치에 병합해야 한다. 그리고 feature 브랜치는 보통 개발자 저장소에만 있는 브랜치이고 리모트 저장소에는 push하지 않는다.</p>
</blockquote>

<p><br /></p>

<h2 id="release-브랜치">release 브랜치</h2>
<ul>
  <li>생성되어지는 브랜치 : develop</li>
  <li>merge 해야되는 브랜치 : develop, master</li>
</ul>

<p>git으로 관리되는 소프트웨어는 정기적으로 성능개선, 기능추가, 버그를 수정 및 반영하면서 릴리즈된다. release 브랜치는 릴리즈를 하기 위한 목적으로 생성되는 브랜치이다.
release 브랜치는 develop 브랜치에서 생성된다.</p>

<p>간단한 순서는 아래와 같다.</p>

<ul>
  <li>develop 브랜치에 이전 버전에 포함되는 기능이 merge 되어있다면 QA를 위해 develop 브랜치에서부터 release 브랜치를 생성한다.</li>
  <li>배포를 위한 최종적인 버그 수정 등의 개발을 수행한다.</li>
  <li>배포 가능한 상태가 되면 master 브랜치로 병합한다. 출시된 master 브랜치에는 버전 태크를 추가한다.</li>
  <li>release 브랜치에서 기능을 점검하며 발견한 버그 수정 사항은 develop 브랜치에도 적용해야 한다. 따라서 배포 완료 후 develop 브랜치에도 merge를 해야한다.</li>
</ul>

<p><br /></p>

<h2 id="hotfix-브랜치">hotfix 브랜치</h2>
<ul>
  <li>생성되어지는 브랜치 : master</li>
  <li>merge 해야되는 브랜치 : develop, master</li>
</ul>

<p>hotfix 브랜치는 배포한 버전에서 긴급하게 수정이 필요한 경우 master 브랜치에서 분기하는 브랜치이다.
다음 릴리즈를 기다릴 수 없을 정도로 긴급한 패치가 바로 반영되어야 하는 경우 이 hotfix 브랜치를 사용한다.</p>

<p>정리해서,</p>

<ul>
  <li>hotfix 브랜치는 master 브랜치에서 생성된다.</li>
  <li>hotfix 브랜치에는 긴급한 패치들이 반영된다.</li>
  <li>이후 hotfix 브랜치는 master 브랜치에 병합되고 태그를 추가한다.</li>
  <li>마찬가지로 develop 브랜치로도 병합되어 긴급 수정 사항이 이후 릴리즈에도 반영되도록 해야한다.</li>
</ul>

<p><br /></p>

<h2 id="git-flow-설명">git-flow 설명</h2>

<p><img src="/assets/images/banners/git-flow.png" alt="" /></p>

<ol>
  <li>가장 먼저 master 브랜치에서 시작한다.</li>
  <li>master 브랜치와 동일하게 develop 브랜치를 생성해준다. 그리고 개발자들은 develop 브랜치에서 개발을 진행한다.</li>
  <li>개발을 진행하다가 <code class="language-plaintext highlighter-rouge">1.회원가입</code>, <code class="language-plaintext highlighter-rouge">2.장바구니</code>, <code class="language-plaintext highlighter-rouge">3.오류수정</code> 등의 기능 구현 및 버그 수정이 필요한 경우
    <ul>
      <li>A 개발자는 develop 브랜치에서 feature 브랜치를 하나 생성해서 <code class="language-plaintext highlighter-rouge">1.회원가입 기능</code>을 구현한다.</li>
      <li>B 개발자는 develop 브랜치에서 feature 브랜치를 하나 생성해서 <code class="language-plaintext highlighter-rouge">2.장바구니 기능</code>을 구현한다.</li>
      <li>C 개발자는 develop 브랜치에서 feature 브랜치를 하나 생성해서 <code class="language-plaintext highlighter-rouge">3.오류수정</code>을 구현한다.</li>
    </ul>
  </li>
  <li>완료성된 feature 브랜치들은 develop 브랜치에 <code class="language-plaintext highlighter-rouge">풀 리퀘스트</code> 요청을 하고 검토가 완료되어 이상이 없으면 <code class="language-plaintext highlighter-rouge">merge</code>한다.</li>
  <li>모든 기능이 완료되면 develop 브랜치에서 release 브랜치를 생성한다.. 그리고 QA(품질검사)를 진행하다가 보완점을 보완하고 버그를 수정한다.</li>
  <li>모든 것이 완료되면 release 브랜치를 master 브랜치와 develop 브랜치로 <code class="language-plaintext highlighter-rouge">merge</code>한다. master 브랜치에서 버전추가를 위해 태그를 생성하고 배포한다.</li>
  <li>배포를 완료했는데 미처 발견하지 못한 버그가 있는 경우 hotfix 브랜치를 master 브랜치로부터 생성하여 긴급 수정 후 태그를 생성하고 바로 수정 배포를 진행한다.</li>
</ol>]]></content><author><name>GitHub User</name></author><category term="Git" /><category term="Node.js" /><category term="Javascript" /><summary type="html"><![CDATA[git-flow 전략]]></summary></entry><entry><title type="html">[블록체인] dApp - Xumm 시작하기</title><link href="http://localhost:4000/blockchain/2022/06/19/blockchain-04.html" rel="alternate" type="text/html" title="[블록체인] dApp - Xumm 시작하기" /><published>2022-06-19T00:00:00+09:00</published><updated>2022-06-19T00:00:00+09:00</updated><id>http://localhost:4000/blockchain/2022/06/19/blockchain-04</id><content type="html" xml:base="http://localhost:4000/blockchain/2022/06/19/blockchain-04.html"><![CDATA[<h2 id="xumm-컨셉">Xumm 컨셉</h2>

<p>리플이 제공하는 <code class="language-plaintext highlighter-rouge">XRPL Labs</code>는 사용자가 2019 년 7 월 지갑 계정에 암호 화폐 및 화폐 통화 [예 : 유로 및 미국 달러]로 저장할 수있는 <code class="language-plaintext highlighter-rouge">Xumm</code>을 출시했다. XRPL Labs의 수석 개발자 Wietse Wind에 따르면이 배포의 주요 목표는 기존 금융 기관의 개입없이 은행 애플리케이션과 유사한 애플리케이션을 구축하는 것이다.</p>

<p>간단하게 말하면, 리플의 <code class="language-plaintext highlighter-rouge">XRP 원장</code> 계정을 생성하고 기존 계정을 가져올 수 있도록 도와주는 지갑이다.</p>

<blockquote>
  <p>Xumm 용어</p>
  <ul>
    <li>xumm:
xumm은 iOS 또는 Android 기기 전용 xumm 앱 을 의미한다.</li>
    <li>xumm platform: 
xumm 플랫폼을 언급할 때 개발자가 xumm 앱을 통해 최종 사용자에게 서명 요청을 전달하기 위한 API를 의미한다다.</li>
    <li>xumm API: 
xumm API는 xumm 플랫폼 과 관련된 xumm API를 의미합니다 .</li>
    <li>application: 
애플리케이션을 언급할 때 xumm앱 이 아니라 개발자 소유의 애플리케이션을 의미합니다.</li>
  </ul>
</blockquote>

<p><br /></p>

<p>XRP 거래는 일반적으로 사용자가 시작한다. 지갑을 열고 대상이나 금액 등을 입력한 다음 거래를 제출한다. 소매/전자 상거래(및 기타 많은) 시나리오에서 이 프로세스를 “reversing”하면 결제 흐름이 실수를 덜 범하고 훨씬 더 사용자 친화적이 된다.
여기서 Xumm 플랫폼이 등장한다. XRPL 트랜잭션 템플릿은 <code class="language-plaintext highlighter-rouge">Xumm API</code>에 게시될 수 있다. 서명 오청(=<code class="language-plaintext highlighter-rouge">payload</code>)은 저장되므로 xumm 앱 사용자는 서명 요청을 열고(QR, 딥링크 또는 푸시알람을 스캔하여) 자신의 장치에서 해결할 수 있다(거부/서명).</p>

<p>사용자가 서명 요청에 서명하면 애플리케이션을 신뢰할 수 있다. 이 경우 애플리케이션에 대한 애플리케이션별 사용자 토큰이 생성되고 향후 <code class="language-plaintext highlighter-rouge">payload</code>는 푸시알람과 함께 최종 사용자에게 직접 전달된다.</p>

<p>xumm 플랫폼은 XRP 원장에서 서명된 트랜잭션을 확인하는 데 필요한 모든 정보와 함께 다양한 상태 업데이트 옵션을 제공하므로 xumm 앱의 트랜잭션 콜백 정보 또는 트랜잭션 제출에 의존할 필요가 없다.</p>

<p><br /></p>

<h2 id="앱-등록">앱 등록</h2>

<p>개발자가 Xumm Api를 호출하기 위해서는 Api key를 얻어 등록해야만 한다. <a href="https://apps.xumm.dev/">xumm 개발자 대시보드</a>에 방문하여 등록하여 로그인한다.</p>

<p><img src="/assets/images/banners/xumm_app_register.png" alt="" /></p>

<p>xumm API 에 대한 모든 호출 에는 최소한 다음 세 개의 HTTP 헤더가 포함되어야 한다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Header(key)</th>
      <th style="text-align: left">value</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">Content-Type</td>
      <td style="text-align: left">application/json</td>
    </tr>
    <tr>
      <td style="text-align: left">X-API-Key</td>
      <td style="text-align: left">[xumm 개발자 대시보드](https://xumm.readme.io/docs/register-your-app)에서 가져옴</td>
    </tr>
    <tr>
      <td style="text-align: left">X-API-Secret</td>
      <td style="text-align: left">[xumm 개발자 대시보드](https://xumm.readme.io/docs/register-your-app)에서 가져옴</td>
    </tr>
  </tbody>
</table>

<p>자, 앱등록이 완료되면 모든 준비는 완료되었다. xumm api를 직접 호출하여 사용할 수 있다.</p>

<p><br /></p>

<h2 id="서명요청payload">서명요청(Payload)</h2>

<p>일반적으로 페이로드 워크플로는 애플리케이션에서 시작된다<code class="language-plaintext highlighter-rouge">(사용자가 무언가를 서명하기를 원한다)</code>. 사용자가 애플리케이션에 지불하는 행위, 에스크로 설정, 다중 서명 설정, 신뢰 라인 생성 등과 같은 다른 유형의 XRPL 트랜잭션일 수도 있다.</p>

<h3 id="페이로드payload-vs-서명요청sign-request-vs-트랙잭션-템플릿transaction-template">페이로드(payload) vs. 서명요청(sign request) vs. 트랙잭션 템플릿(transaction template)</h3>
<p>최종 사용자가 트랜잭션(서명 요청)에 서명하도록 하려면 트랙잭션 템플릿(XRPL 트랜잭션 사양에 따라 형식이 지정된 JSON 형식)을 작성하고 트랜잭션 템플릿을 xumm 플랫폼(api)에 게시하여 페이로드를 생성해야한다. 그리고 xumm 앱 사용자가 거부 또는 서명하게 된다.</p>

<p>개발자의 애플리케이션은 XRPL 트랜잭션 템플릿을 만든다. 일반적인 <code class="language-plaintext highlighter-rouge">XRPL JSON 트랜잭션</code>과 <code class="language-plaintext highlighter-rouge">xumm 트랜잭션 템플릿</code>의 차이점은 최종 사용자 기기의 xumm 앱이 자동으로 채우기 때문에 일부 필드를 생략하거나 공백으로 둘 수 있다는 점이다.
그리고, 개발자의 애플리케이션 백엔드는 트랜잭션 템플릿을 Xumm API로 보낸다. 그럼 개발자의 애플리케이션은 유니크한 페이로드 아이디<code class="language-plaintext highlighter-rouge">(payload ID)</code>를 전달받는다.</p>

<p><br /></p>

<h3 id="testnetdevnetmainnet에-대한-참고-사항">Testnet/Devnet/Mainnet에 대한 참고 사항</h3>

<p><code class="language-plaintext highlighter-rouge">Testnet/Devnet</code>과 상호 작용하려면 <code class="language-plaintext highlighter-rouge">Testnet/Devnet</code>에 연결된 <code class="language-plaintext highlighter-rouge">xumm</code> 앱으로 요청에 서명하기만 하면 된다. <code class="language-plaintext highlighter-rouge">XUMM 플랫폼</code>은 단순히 최종 사용자와 외부 응용 프로그램 간의 <code class="language-plaintext highlighter-rouge">"상호작용 채널"</code>이기 때문에 사용된 네트워크는 API와 관련이 없다. 서명이 선행될 때 사용자가 연결되는 네트워크이다.</p>

<h3 id="데스크탑-클라이언트">데스크탑 클라이언트</h3>
<p>애플리케이션에서 QR 코드를 생성하거나 사전 생성된 QR 코드 중 하나를 사용할 수 있다. xumm 앱 최종 사용자는 QR 코드를 스캔하고 거래 템플릿을 검토하고 거래에 서명할 수 있다. 또한 최종 사용자를 페이로드 URL로 리디렉션할 수 있다.</p>

<h3 id="디바이스-클라이언트">디바이스 클라이언트</h3>
<p>디바이스에서 이 프로세스가 발생 하면 사용자를 페이로드 URL로 리디렉션할 때 xumm 앱이 자동으로 열린다.</p>

<p>페이로드를 생성할 떄 애플리케이션이 게시한 페이로드 옵션에 따라서 xumm 앱은 서명된 트랜잭션을 XRPL에 직접 제출하거나 서명된 트랜잭션 HEX를 애플리케이션에 다시 게시한다.(그래서 애플리케이션은 서명된 트랜잭션을 제출하거나 유지할 수 있다.)</p>

<p>최종 사용자가 페이로드를 거부 및 서명하여 해겷하면 애플리케이션 백엔드는 HTTP POST 웹훅을 수신한다. 또한, 페이로드별 웹 소켓을 구독하여 실시간 상태 업데이트를 받거나 xumm API를 호출하여 페이로드 상태를 얻을 수 있다.</p>

<h3 id="xumm-서명요청-flowinitially-non-push">xumm 서명요청 flow(initially, non-push)</h3>

<p><img src="/assets/images/banners/xumm-non-push.png" alt="" /></p>

<h3 id="xumm-서명요청-flowwith-user-token-push">xumm 서명요청 flow(with User Token, push)</h3>

<p><img src="/assets/images/banners/xumm-push.png" alt="" /></p>

<h2 id="참조">참조</h2>

<ul>
  <li>https://xumm.readme.io/docs/payload-workflow</li>
</ul>]]></content><author><name>GitHub User</name></author><category term="BlockChain" /><category term="BlockChain" /><summary type="html"><![CDATA[Xumm 컨셉]]></summary></entry><entry><title type="html">[블록체인] 기본 개념 - 유동성 풀이란?</title><link href="http://localhost:4000/blockchain/2022/06/13/blockchain-03.html" rel="alternate" type="text/html" title="[블록체인] 기본 개념 - 유동성 풀이란?" /><published>2022-06-13T00:00:00+09:00</published><updated>2022-06-13T00:00:00+09:00</updated><id>http://localhost:4000/blockchain/2022/06/13/blockchain-03</id><content type="html" xml:base="http://localhost:4000/blockchain/2022/06/13/blockchain-03.html"><![CDATA[<h2 id="유동성-풀이란">유동성 풀이란?</h2>

<p>유동성 풀이란 스마트 콘트랙트 내에 통결되어 있는 자금(디지털 자산)들을 말한다. 유동성 풀은 탈중앙화된 트레이딩, 대출 등 앞으로 다양한 기능을 지원하기 위해 사용된다.</p>

<p>유동성 풀 <code class="language-plaintext highlighter-rouge">유니스왑</code>과 같은 많은 탈중화 거래소(DEX)의 핵심이다. 유동성 제공자(LP)라 하는 이들은 풀에 동일한 가치를 갖는 두 가지 토큰을 추가하고 시장을 생성한다. 자신의 자금을 제공하는 대가로, 사용자는 자신의 풀에서 발생하는 거래 수수료를 전체 유동성 내 자신의 지분에 따라 분배받는다.</p>

<p>LP는 유동성 공급에 필요한 토큰을 보유한 자라면 누구나 될 수 있으며 AMM(자동화된 마켓 메이킹)을 통해 유동성 풀의 변화에 따라 토큰의 교환비율이 결정된다. 이더리움 상에서 유동성 풀을 사용하는 대표적인 거래소는 스시스왑, 커브 등이 있으며 이 거래소 내 유동성 풀은 ERC-20 토큰을 지원한다.</p>

<p><br /></p>

<h2 id="유동성-풀은-어디에-사용되는가">유동성 풀은 어디에 사용되는가?</h2>

<p>유동성 풀에 유동성을 공급하는 것은 간단하며 누구나 참여할 수 있기 때문에 다양한 방법으로 활용할 수 있다. 우선 유동성 풀은 토큰이 알고리즘에 따라 유동성 풀에 제공하는 사용자에게 분배할 수 있다는 원리를 이용해 사용자가 풀에 자금을 추가하고 이자를 받을 수 있는 이자 창출 플랫폼으로 사용할 수 있다. 이를 <code class="language-plaintext highlighter-rouge">유동성 마이닝(liquidity Mining)</code> 또는 <code class="language-plaintext highlighter-rouge">이자 농사(yield Farming)</code>라고 말하기도 한다.</p>

<p>그리고 유동성 공급자에게 제한된 <code class="language-plaintext highlighter-rouge">리스크</code>와 <code class="language-plaintext highlighter-rouge">수익</code>을 선택할 수 있게 함으로써 스마트 컨트랙트의 리스크를 보완할 수 있는 기반을 제공한다. 또한, 블록체인 상에서 합성 자산을 만드는 것도 가능하게 할 수 있는 기반으로 활용할 수 있다.</p>

<p>암호화폐 프로젝트에서 적합한 사람들에게 새 토큰을 배포하는 것은 무척 어려운 문제이다. <code class="language-plaintext highlighter-rouge">유동성 마이닝</code>은 보다 성공적인 접근 방법 중 하나 였다. 토큰은 기본적으로 알고리즘을 따라 자신의 토큰을 유동성 풀에 제공하는 사용자에게 분배된다. 이후 새롭게 생성된 토큰이 각 사용자의 풀 지분에 따라 분배된다.</p>

<p>이는 <code class="language-plaintext highlighter-rouge">풀 토큰</code>이라 하는 다른 유동성 풀의 토큰일 수도 있다는 점을 유의해야 한다. 예를 들어, 유니스왑에 유동성을 제공하거나, 컴파운드에 자검을 대출해주는 경우, 풀 내 지분을 나타내는 토큰을 받게 된다. 이를 다른 풀에 예치하고, 수익을 얻을 수도 있다. 여러 프로토콜이 다른 프로토콜의 풀 토큰을 자신의 상품 등에 통합하기 때문에 이러한 연결은 꽤나 복잡해질 수 있다.</p>

<p><br /></p>

<h2 id="유동성-풀은-어떻게-작동하는가">유동성 풀은 어떻게 작동하는가?</h2>
<p>먼저, 가장 유명한 <code class="language-plaintext highlighter-rouge">유니스왑</code>을 예로 들어보자.</p>

<h3 id="유니스왑이란">유니스왑이란?</h3>
<p>유니스왑은 이더리움과 <code class="language-plaintext highlighter-rouge">ERC-20</code> 토큰 간의 자동 교환 거래를 용이하게 하도록 설계된 탈중앙화 거래소(DEX)이다. 온-체인에서 탈중심화 지갑만 설치하면 유니스왑을 이용할 수 있다. 유니스왑에 대해 알아보기 전 먼저 탈중앙화 거래소에 대해 알아야 할 필요가 있다.</p>

<p>우리가 흔히 알고 있는 <code class="language-plaintext highlighter-rouge">업비트</code>, <code class="language-plaintext highlighter-rouge">빗썸</code>, <code class="language-plaintext highlighter-rouge">코인원</code>, <code class="language-plaintext highlighter-rouge">코인빗</code> 등은 중앙화된 주체가 거래를 중개하는 거래소이다. 이런 중앙집권 거래소는 사용자의 디지털자산을 거래소가 수탁하고 사용자는 거래소가 제공하는 장부 위에서 거래를 하는 구조로 이루어져 있다. 하지만 중앙화된 주체가 거래의 신뢰를 보장하는 구조는 <code class="language-plaintext highlighter-rouge">거래과정에서 제3자가 개입할 필요 없다</code>는 무허가성(permissionless)이라는 블록체인의 특성에 반하는 것이기에 블록체인 커뮤니티에서는 중앙화되어 있지 않는 형태, 일명 탈중앙화 거래소를 만들기 위해 노력했다. 그 결과 2017년경 이더델타 등 탈중앙화 거래소(DEX, Decentralized Exchanage) 프로젝트가 탄생했다. 탈중앙화 거래소는 <code class="language-plaintext highlighter-rouge">비영리 목적</code>이기 때문에 수수료가 거의 없고 별도의 인증 절차 없이 토큰 간 거래를 할 수 있다.</p>

<p>초기 탈중앙화 거래소는 과도한 가스비를 초래하고, 확장의 한계성, 부족한 유동성 등의 문제가 있어 큰 관심을 받지 못했다. <code class="language-plaintext highlighter-rouge">유니스왑</code>은 이러한 한계성을 보완하여 출시하였는데 특히 AMM(유동화된 마켓 메이커) 알고리즘 기반으로 <code class="language-plaintext highlighter-rouge">유동성 풀</code>(pool, 스마트 컨트랙트 내에 동결되어 있는 자금)을 제공하여 낮은 유동성이라는 한계점을 보완하였다.</p>

<p>유니스왑은 유동성을 공급하는 자들에게 별도의 보상을 지급하는 방식으로 유동성 공급 문제를 해결했다. 유니스왑은 유동성 마이닝이라는 시스템으로 성립되어 있어 토큰을 특정 풀에 맡기면 전용 거버넌스 토큰인 UNI를 보상으로 받을 수 있다. UNI는 일종의 거버넌스 토큰(Governance Token)으로서 가격이 결정되어 있으며 디지털자산 거래소에서 간편하게 교환할 수 있다. 또한, 유니스왑은 중앙관리자가 없어 디지털자산의 상장 이라는 개념이 존재하지 않는다. 이에 누구나 유니스왑에 ERC-20 토큰의 유동성을 공급하여 해당 토큰의 교환을 용이하게 만들 수 있다.</p>

<h3 id="유니스왑에-투자하는-방법">유니스왑에 투자하는 방법</h3>
<p>1) 디지털자산 지갑을 먼저 생성합니다. 이후 메타마스크 등의 지갑에 유니스왑을 연결한다.
2) 유니스왑은 이더리움 기반 디지털자산에만 적용되기 때문에 이더(ETH)를 구매한다.
3) 지갑이 설정되면 https://uniswap.org 으로 이동하여 ‘Launch App’을 클릭한다. 인터페이스를 통해 유니스왑을 지갑에 연결할 수 있습니다.
4) 지갑에 있는 이더(ETH)를 원하는 ERC-20 토큰과 교환합니다. ERC-20을 교환하면 유동성 풀로 이더를 보내는 것과 동시에 교환한 ERC-20 토큰을 풀에서 인출하게 됩니다.
5) 토큰 교환 전에 슬리피지 수치를 주의해야 합니다. 슬리피지는 유동성 풀에서 사용 가능한 양 대비 토큰의 비율입니다. 풀 크기에 비해 대량 주문이 있는 거래는 높은 %의 슬리피지로 거래를 중단됩니다. 
6) 모든 세부 정보를 확인한 후 스왑을 확인하면 지갑에 팝업이 표시되며 트랜잭션은 https://etherscan.io/ 에서 확인할 수 있습니다. 트랜잭션이 검증되어 블록체인에 기록되는 과정에서 일부 시간이 소요될 수 있습니다.</p>

<h3 id="유니스왑-투자-리스크">유니스왑 투자 리스크</h3>
<p>유니스왑은 제3자의 개입 없이 지갑에서 직접 거래할 수 있고 새 토큰을 쉽고 빠르게 접근할 수 있다. 또한, 거래수수료가 0.3%으로 중앙집권 거래소(업비트, 빗썸, 코인원 등) 대비 저렴하다. 하지만 유니스왑에도 다양한 리스크가 존재한다.</p>

<p>첫 번째는, 유니스왑에서 해킹이 발생할 확률이 <code class="language-plaintext highlighter-rouge">제로(0)</code>가 아니라는 것이다. 해킹 리스크가 빈번하게 일어나는 것은 아니지만, 스마트 컨트랙트가 문제를 일으키면 해킹당할 위험이 높아진다. 실제로 2022년 4월 유니스왑 대출 플랫폼 Lendf.ME에서 해킹으로 2500만 달러 이상의 디지털자산이 도난당한 사건이 발생했다. 스마트 컨트랙트는 완전하지 않으므로 설계의 취약점이 발견될 경우 의도치 않는 공격을 받을 수 있다. 이로 인해 디지털자산이 탈취당하는 경우에는 별도의 보호를 받을 수 없게 된다.</p>

<p>또한, 거버넌스 토큰 UNI의의 가격 변동성 리스크도 존재한다. 유동성이 큰 UNI는 일반 통화보다 토큰 페어 가격 변동 위험이 높다. 따라서 토큰 페어(pair)의 가격 변동이 높을 경우 소위 비영구적인 손실이 발생할 수도 있따. 또한 표시된 APY(연간 이자율)는 매번 변경되므로 일정 이자율을 유지한다는 보장 또한 없다.</p>

<h3 id="유니스왑-작동원리">유니스왑 작동원리</h3>
<p><code class="language-plaintext highlighter-rouge">이더리움</code>과 <code class="language-plaintext highlighter-rouge">ERC-20</code> 토큰 간의 자동 교환 거래를 용이하게 하도록 설계된 탈중화 <code class="language-plaintext highlighter-rouge">거래소(DEX)</code>인 유니스왑에서는 디지털자산 간의 <code class="language-plaintext highlighter-rouge">교환(swap)</code> 기능을 구현하기 위하여 중앙화권 거래소가 사용하는 오더북 방식이 아닌 <code class="language-plaintext highlighter-rouge">AMM</code> 방식을 선택했다.</p>

<p><code class="language-plaintext highlighter-rouge">AMM(Automated Market Making)</code>이란 자동화된 마켓 메이킹으로, 개인들이 토큰을 교환할 때 수학공식에 의해 자산의 가격이 자동으로 결정되도록 하는 알고리즘입니다. 중앙화된 거래소에서는 매수희망자와 매도희망자가 존재하여 각자 제출한 호가가 일치하였을 때 거래가 성립되고, 거래소는 해당 거래를 중개하는 역할을 수행합니다. 반면, AMM 방식의 DEX에서는 이용자들이 <code class="language-plaintext highlighter-rouge">유동성 풀(Liquidity Pool)</code>이라는 것을 공급하고, 디지털자산의 교환을 원하는 자는 해당 풀에서 가상자산을 교환하는 방식으로 교환이 이루어집니다. 거래의 상대방이 명확히 존재하지 않으며 이때 교환비율이나 디지털자산의 가치는 수학적인 알고리즘에 의하여 형성됩니다.</p>

<p>유니스왑은 AMM의 한 종류인 CPMM(Constant Product Market Maker)을 사용한다.</p>

<blockquote>
  <p>K = X*Y</p>
  <blockquote>
    <p>K= 상수</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>X= 거래계약 안에 있는 토큰 X의 수량</p>
  </blockquote>
</blockquote>

<blockquote>
  <blockquote>
    <p>Y= 거래계약 안에 있는 토큰 Y의 수량</p>
  </blockquote>
</blockquote>

<p>이 함수는 변수 X와 Y의 곱에 있어서 상수 K 값이 <code class="language-plaintext highlighter-rouge">유지</code>되어야 한다. 이는 전체 유동성이 일정하다는 의미로 해석할 수 있따. X와 Y 값은 각각 유동성 풀에 존재하는 토큰 가치의 비중을 나타내며 두 비중의 곱에 의해 풀의 유동성이 결정되고 이를 K 값으로 나타낸다.</p>

<p>예시로 유니스왑의 거래를 설명해보자면,</p>

<p>유동성 풀에 다음과 같이 토큰이 존재한다고 가정하자.</p>
<ol>
  <li>이더리움(X) 10개</li>
  <li>ERC-20(Y) 토큰 200개</li>
  <li>이 둘의 곱은 2000(K)</li>
  <li>1 ETH = 18.18 ERC-20</li>
</ol>

<p>이에 모든 교환에 있어 두 디지털자산의 곱은 2000을 유지해야 한다. 이러한 상황에서 ERC-20 토큰을 구매하기 위해 1 ETH를 보내면 컨트랙트의 이더리움 수량이 10개에서 1개가 더 추가되어 11개로 변한다. K는 2000으로 일정해야 하므로 <code class="language-plaintext highlighter-rouge">181.82(2000/11)</code>로 변한다. 다시 말해 1 ETH를 주고받는 ERC-20 토큰의 양은 <code class="language-plaintext highlighter-rouge">18.18(200-181.82)</code>인 것이다.</p>

<ol>
  <li>이더리움(X) 10개 + 1개 = 11개</li>
  <li>ERC-20(Y) 토큰 2000/11 = 181.82개</li>
  <li>이 둘의 곱은 2000(K)</li>
  <li>1 ETH = 33.33 ERC-20</li>
</ol>

<p>이다음 상황에서 누군가 1 ETH를 넣는다면 컨트랙트 상의 이더리움은 12개가 된다. ERC-20 토큰의 양은 <code class="language-plaintext highlighter-rouge">166.67(2000/12)</code>개가 된다. 즉 하나의 ETH를 더 넣으면 1 ETH를 주고받는 ERC-20 토큰의 양은 <code class="language-plaintext highlighter-rouge">33.33(200-166.67)</code>이다. 이는 ERC-20 토큰의 구매 가격(가치)이 높아진 것으로 볼 수 있다.</p>

<p>이때 ERC-20을 비싸게 팔고 이더리움을 저렴하게 매수하려는 차익거래자가 발생됩니다. 이러한 차익거래자 때문에 이더리움/ERC-20 비율이 효율적인 선까지 맞춰집니다. 즉, 유니스왑은 <code class="language-plaintext highlighter-rouge">CPMM(X*Y=K)</code>을 통해 ETH와 ERC-20 토큰의 비율을 중앙집권 거래소 가격과 수렴할 수 있게 한 것입니다.</p>

<p><br /></p>

<p>유동성 풀을 작동원리를 정리하자면</p>

<p><img src="/assets/images/banners/pool.jpg" alt="" /></p>

<p>풀 안에 A, B 두 코인이 있고 공급자는 반드시 A코인 50%와 B코인 50%를 예치해야 한다. 이 예치금은 거래소가 사용한다.
본질적으로 유동성 공급자는 거래 수수료를 얻고자 암호화폐 토큰을 탈중화 거래소(DEX)에 예치하는 트레이더다. 이것은 유동성 채굴 혹은 시장 조성이라고 불리기도 한다.</p>

<p>거래 수수료는 보통 이자율로 표시된다. 이자율은 얼마나 유동성이 공급되는지 그리고 얼마나 많은 거래가 유동성 풀 안에서 발생하는지에 따라 천차만별이다.</p>

<p><br /></p>

<h2 id="참조">참조</h2>
<ul>
  <li><a href="https://m.upbitcare.com/academy/education/blockchain/49">업비트</a></li>
  <li><a href="https://academy.binance.com/ko/articles/what-are-liquidity-pools-in-defi">바이낸스</a></li>
</ul>]]></content><author><name>GitHub User</name></author><category term="BlockChain" /><category term="BlockChain" /><summary type="html"><![CDATA[유동성 풀이란?]]></summary></entry><entry><title type="html">[블록체인] 기본 개념 - 스마트 컨트랙트</title><link href="http://localhost:4000/blockchain/2022/06/07/blockchain-02.html" rel="alternate" type="text/html" title="[블록체인] 기본 개념 - 스마트 컨트랙트" /><published>2022-06-07T00:00:00+09:00</published><updated>2022-06-07T00:00:00+09:00</updated><id>http://localhost:4000/blockchain/2022/06/07/blockchain-02</id><content type="html" xml:base="http://localhost:4000/blockchain/2022/06/07/blockchain-02.html"><![CDATA[<h2 id="스마트-컨트랙트란">스마트 컨트랙트란?</h2>

<p><code class="language-plaintext highlighter-rouge">스마트 컨트랙트(smart contract)</code>란 블록체인 기술을 활용해 제3의 인증기관 없이 개인 간 계약이 이루어질 수 있도록 하는 기술을 말한다. 서면으로 이루어지던 계약을 코드로 구현하고 해당 계약을 이행하는 과정에서 조건 충족 여부에 대한 판단을 인간이 아닌 컴퓨터 등의 기계가 대신 실행함으로써 제3의 인증기관이 필요 없도록 하는 개념을 의미한다.</p>

<p>스마트 컨트랙트를 활용하면 두 당사자가 서로를 모르거나 신뢰하지 않더라도 계약을 체결할 수 있다. 그 이유는 특정 조건이 충족되지 않으면 해당 계약은 실행되지 않기 때문이다.
그렇기 때문에, 제3의 인증기관 없이도 계약을 이행할 수 있는 것이 스마트 컨트랙트의 특징이다.</p>

<p><img src="https://user-images.githubusercontent.com/52439201/172295968-14dfcaac-ebf8-45a2-812b-b962fb5d413a.png" alt="image" /></p>

<p><br /></p>

<h2 id="스마트-컨트랙트-특징">스마트 컨트랙트 특징</h2>

<p><code class="language-plaintext highlighter-rouge">스마트 컨트랙트(smart contract)</code>의 개념을 최초로 제시한 닉 재보는 스마트 컨트랙트를 계약 코드를 통해 스스로 실행되는 전산화 계약이라고 정의했다.<br />
스마트 컨트랙트의 기본적인 특징은 아래와 같다.</p>

<h3 id="관측가능성">관측가능성</h3>
<p>스마트 계약은 서로의 계약 이행 가능성을 관찰하거나 성과를 입증할 수 있어야 한다.</p>

<h3 id="검증-가능성">검증 가능성</h3>
<p>계약을 이행 또는 위반할 경우 계약 당사자들이 이를 알 수 있어야 한다.</p>

<h3 id="프라이버시">프라이버시</h3>
<p>계약 내용은 계약에 필요한 당사자들만이 알 수 있어야 한다.</p>

<h3 id="강제-가능성">강제 가능성</h3>
<p>계약이 이뤄질 수 있도록 구속력이 있어야 한다.</p>

<p><br /></p>

<p>정리하면, 스마트 컨트랙트는 투명한 거래 내역이 공개되어야 한다. 실제로 Etherscan이나 Decentralized Metadata and Source Code Repository를 통해 이더리움 메인넷과 테스트넷에 배포된 모든 컨트랙트를 누구든지 조회할 수 있다.
또한, 스마트 컨트랙트는 블록체인 상에 trustless한 네트워크를 구축하는데 효과적이다. 영철이가 미영이에게 매달 일정한 금액을 전송한다고 했을 때 은행이나 신뢰할 수 있는 기관에 의존하지 않고서 해당 계약을 이행할 수 있게 된다.</p>

<p><br /></p>

<h2 id="스마트-컨트랙트-작동-원리">스마트 컨트랙트 작동 원리</h2>

<p><code class="language-plaintext highlighter-rouge">스마트 컨트랙트</code>는 블록체인 상에서 전자 계약서로 이루어지며, 계약 당사자들끼리 합의한 내용 및 조건이 충족되면 자동으로 실행되도록 설계되어 있다.<br />
계약 내용을 스마트 컨트랙트 소스 코드로 작성하여 블록체인 네트워크에 전송하면 네트워크 참여자(노드)들이 유효성 검증이 이뤄지며 검증이 완료되면 해당 스마트 컨트랙트가 포함된 블록이 생성되며 배포된다.</p>

<p>이후 블록체인은 스마트 컨트랙트가 담긴 블록의 변경 상태를 지속적으로 확인한다. 조건에 따른 변경시 명령 실행 비용을 계산하고 상태변경 트랜잭션을 생성한다.</p>

<h3 id="예시">예시</h3>

<ol>
  <li>부동산을 매도하고자 하는 사람이 부동산 매매 계약의 내용이 담긴 스마트 컨트랙트를 만들어 블록체인에 전송하면 블록이 생성되어 배포된다.</li>
  <li>블록체인 내 노드들은 이 스마트 컨트랙트를 검토하여 블록을 만드는데 합의하고 스마트 컨트랙트가 담긴 블록을 자신의 블록체인 맨 끝에 추가한다.</li>
  <li>이후 변경 사항들을 끊임없이 다른 블록들과 교류하면서 오류가 없는지 혹은 조건에 충족되어 추가 계약 사항이 진행되는지 체크한다.</li>
  <li>부동산 매수인은 블록체인 상에서 공개되어 있는 스마트 컨트랙트의 내용을 직접 확인한 후, 스마트 컨트랙트를 실행하기 위해 서명을 하게 된다.</li>
  <li>이후 부동산 매수자가 스마트 컨트랙트에 담긴 내용에 따라 부동산 매매 대가에 해당하는 디지털자산을 매도인에게 이전하게 되면 등록된 부동산의 소유권이 매수자에게 자동으로 이전된다.</li>
  <li>이때 블록체인 상에서의 스마트 컨트랙트는 대부분 오픈 소스(open source), 즉 누구나 확인할 수 있기 때문에 그 내용을 임의로 변경하거나 조작할 수 없습니다. 또한 스마트 컨트랙트의 체결사실도 모두에게 공유됩니다.</li>
</ol>

<p><img src="/assets/images/banners/smartcontract.png" alt="" /></p>

<p><br /></p>

<h2 id="스마트-컨트랙트의-장점">스마트 컨트랙트의 장점</h2>

<p>스마트 컨트랙트의 장점은 크게 자율성, 신뢰, 비용절감, 안정성, 효율성 등으로 분류된다.</p>

<h3 id="자율성">자율성</h3>
<p>블록체인 내에서 진행되기 때문에 공신력을 가진 제 3자, 혹은 기관이 필요하지 않습니다. 이에 따라 거래 당사자들이 계약에 대한 온전한 권한, 통제성을 갖게 된다.</p>

<h3 id="비용-절감">비용 절감</h3>
<p>블록체인에서 관련 계약, 거래 내역 등을 보증할 수 있는 제3자나 공신력 있는 기관이 필요하지 않기 때문에 비용 절감의 효과를 가질 수 있다.</p>

<h3 id="신뢰성">신뢰성</h3>
<p>블록체인 내 스마트 컨트랙트에 의해 계약이 공정하게 진행되며 문서의 위변조가 극히 어려워 뛰어난 신뢰성을 가진다.</p>

<h3 id="보안성">보안성</h3>
<p>신뢰성과 연결된 것으로 문서가 암호화되어 블록체인 내 분산 원장 기술에 의해 안전하게 보관된다.</p>

<p><br /></p>

<h2 id="참조">참조</h2>
<ul>
  <li><a href="https://m.upbitcare.com/academy/education/blockchain/71">업비트</a></li>
</ul>]]></content><author><name>GitHub User</name></author><category term="BlockChain" /><category term="BlockChain" /><summary type="html"><![CDATA[스마트 컨트랙트란?]]></summary></entry><entry><title type="html">[블록체인] 기본 개념 - DApp이란?</title><link href="http://localhost:4000/blockchain/2022/06/06/blockchain-01.html" rel="alternate" type="text/html" title="[블록체인] 기본 개념 - DApp이란?" /><published>2022-06-06T00:00:00+09:00</published><updated>2022-06-06T00:00:00+09:00</updated><id>http://localhost:4000/blockchain/2022/06/06/blockchain-01</id><content type="html" xml:base="http://localhost:4000/blockchain/2022/06/06/blockchain-01.html"><![CDATA[<h2 id="dapp-정의">DApp 정의</h2>

<p><code class="language-plaintext highlighter-rouge">디앱(DApp)</code> 또는 <code class="language-plaintext highlighter-rouge">댑</code>이란 Decentralized Application의 약자로서, 이더리움, 큐텀, 이오스 같은 플랫폼 코인 위에서 작동하는 탈중앙화 분산 애플리케이션을 말한다. 간략히 분산앱이라고도 한다. 플랫폼 위에서 작동하는 디앱의 암호화폐는 코인(coin)이라고 하지 않고 토큰(token)이라고 구별하여 부르기도 한다. ‘Daap’가 아니라 ‘DApp’가 올바른 표기법이다. ‘Dapp’ 또는 ‘dApp’이라고도 쓴다. 단수형이 아니라 복수형으로 표현하여, 디앱스(DApps) 또는 댑스(dApps)라고도 한다.</p>

<h2 id="개요">개요</h2>

<p>디앱이란 블록체인을 기반으로 돌아가는 애플리케이션을 말한다. 쉽게 말해 이더리움 기반 디엡이라면 디앱에서 상호작용하는 데이터들이 이더리움 블록체인에 기록되고 불러내어지는 애플리케이션이라고 이해하면 된다.
현재, 이더리움, 이오스, 스팀 등에서 돌아가는 모든 디앱들을 합치면 약 3,000여 개가 존재한다.</p>

<p>애플 앱스토어에만 220만여 개가 넘는 앱이 존재하는데, 이와 비교하면 아주 초라한 숫자이기도 하다. 전체 디앱 중에서 게임, 거래소, 도박 등을 뺀 실생활과 밀접한 영역의 디앱들의 유저 수 비중은 40%도 안 된다.</p>

<p>디앱은 스마트폰 <code class="language-plaintext highlighter-rouge">블록체인</code>을 기반으로 한 운영체제에서 구동된다는 것이 차이점이다. 아이폰은 ISO 운영체제를 갤럭시에는 안드로이드 OS를 사용한다. <code class="language-plaintext highlighter-rouge">블록체인</code>은 이러한 OS라고 생각하면 된다. 어떤 블록체인을 기반으로 구동되는지에 따라 이더리움 디앱, 이오스 디앱 등으로 구분할 수 있는 것이다.</p>

<h2 id="등장배경">등장배경</h2>

<p>블록체인에서 디앱은 <code class="language-plaintext highlighter-rouge">스마트 계약</code>이 도입되면서 생겨났다. 스마트 계약이 없는 비트코인에는 디앱이 존재하지 않는다. 
이더리움 창시자인 비탈릭 부테린은 이더리움에 스마트 계약을 처음 도입했다. 이 후 이더리움은 최초의 메인넷으로 무수한 디앱들을 탄생시켰다.</p>

<h2 id="특징">특징</h2>

<p>디앱 개념은 아직 초기 단계에 있다. 디앱으로는 응용 프로그램이 다음 네 가지 특징을 나타내야 한다.</p>

<ul>
  <li>탈중앙화 구조 : 디앱은 OS 개발에 필요한 소스 코드가 누구에게나 공개돼 있다.</li>
  <li>뛰어난 개인정보 보호 : 데이터를 블록체인에 기록하기 때문에 저장에 있어 안전하다.</li>
  <li>오픈 소스 : 가장 중요한 속성은 이러한 앱이 모든 사람에게 핵심 소스 코드를 제공해야 한다는 것이다. 디앱의 핵심 특징은 자율성과 만장일치로 이루어져 있음으로 기본적으로 변경 사항은 모든 사용자 또는 대부분 사용자가 결정해야 한다. 또한, 코드는 모든 사용자가 체크 아웃 할 수 있어야 한다.</li>
  <li>분산형 자연 : 이름에서 알 수 있듯이 분산형 응용 프로그램은 분산된 블록체인 또는 모든 암호화 기술에 모든 것을 저장하여 중앙 권한의 위험으로부터 응용 프로그램을 저장하고 자치 특성을 강조한다.</li>
  <li>인센티브(Incentivization) : 앱이 분산형 블록체인을 기반으로 하므로 네트워크의 레코드 유효성 검사기에 암호화 토큰이나 가치가 있는 디지털 자산 형태로 보상/ 인센티브를 부여해야 한다.</li>
  <li>알고리즘 : 분산 앱은 암호화 시스템에서 가치 증명을 나타내는 컨센서스 메커니즘이 필요하다. 본질적으로 이는 암호 토큰의 가치를 부여하고 사용자가 중요한 암호 토큰을 생성하기 위해 합의한 합의 프로토콜을 만든다.</li>
</ul>

<h2 id="앱과-디앱의-차이">앱과 디앱의 차이</h2>

<ul>
  <li>디앱은 사용자가 계정을 생성하는 절차부터 앱과 다르다. 일반 앱은 회원가입을 할 때는 개인정보를 입력해 계정을 만들고 로그인 후 즉시 서비스를 이용한다. 하지만, 디앱의 경우 계정을 만들 때, <code class="language-plaintext highlighter-rouge">이더리움</code>, <code class="language-plaintext highlighter-rouge">이오스</code> 등 해당 블록체인 지갑을 보유하고 있어야 한다. 해당 블록체인 서비스에 참여함으로써, 보상으로 받는 암호화폐를 저장하고 거래하기 위한 지갑을 준비하는 것이다.</li>
  <li>이더리움 기반 디앱은 이더리움 지갑을, 이오스 기반 디앱은 이오스 지갑을 갖춰야 한다. 예를 들어 이더리움 게임으로 잘 알려진 크립토키티를 이용하려면 메타마스크라는 이더리움 지갑을 만들고, 서비스를 이용할 때마다 메타마스크 인증을 해야 한다.</li>
  <li>디앱과 기존 앱 개발의 가장 큰 차이점이라면 얼마나 엄격하게, 정밀하게 점검하느냐이다. 쉽게 말해, 디앱은 소프트웨어 개발보다는 하드웨어 개발과 더 비슷하다. 어떤 회사가 하드웨어를 완성했다면 제품을 공개하기전에 반드시 엄격하게 정밀하게 테스트를 한 후 공개해야 한다. 하드웨어 개발이 끝난 뒤 공개되었을 때, 미처 발견하지 못한 문제점들이 생긴다면 기존 소프트웨어 수정보다 훨씬 더 많은 돈과 시간을 요구한다. 왜냐하면 <code class="language-plaintext highlighter-rouge">디앱 개발에서 스마트 계약이 메인넷에서 한번 실행되면 절대 변경이 안 되기 때문이다.</code></li>
  <li>만약 오류가 생긴다면 스마트 계약에서 발견된 버그 때문에 사용자들의 암호화폐를 잃어버릴 가능성도 배제할 수 없다. 그래서 쉽게, 그리고 빠르게 개발하여 공개할 수 없는 이유도 된다.</li>
  <li>이와 반대로 기존 앱 개발은 빠르게 변하는 트렌드에 맞춰 새로운 서비스를 계속해서 만들어내는 것에 집중하는 편이다. 개발자로서 최소한의 실행 가능한 제품 즉, MVPs를 만들고 사람들이 직접 테스트하게 한 후 가능한 한 빨리 업데이트된 버전을 출시하는 것이 요새 앱 개발의 추세이지만 현재 디앱 개발자들에게는 적합하지 않은 추세다.</li>
</ul>

<p><br /></p>

<p style="text-align: center;"><img src="https://user-images.githubusercontent.com/52439201/172168332-f81afcc3-7170-4033-998b-51db7175ce1a.png" alt="image" /><br />
출처자료: 현암 코딩</p>

<p>정리해서, 기존 앱은 구글 플레이 스토어나 앱 스토어에 등록하여 구글과 애플의 <code class="language-plaintext highlighter-rouge">중앙화</code>된 서버에서 관리를 받는 반면에,<br />
디앱은 분산된 P2P 간의 자율적인 연결에 의해 <code class="language-plaintext highlighter-rouge">탈중앙화</code>된 이더리움, 이오스, 트론 등과 같은 스마트계약 기능이 있는 블록체인 플랫폼 위에서 작동되는 방식이다.</p>

<h2 id="출처">출처</h2>
<ul>
  <li><a href="http://wiki.hash.kr/index.php/%EB%94%94%EC%95%B1">해시넷</a></li>
</ul>]]></content><author><name>GitHub User</name></author><category term="BlockChain" /><category term="BlockChain" /><summary type="html"><![CDATA[DApp 정의]]></summary></entry></feed>