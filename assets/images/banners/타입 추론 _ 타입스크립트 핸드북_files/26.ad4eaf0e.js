(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{236:function(t,s,a){"use strict";a.r(s);var n=a(3),e=Object(n.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"타입-추론-type-inference"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#타입-추론-type-inference"}},[t._v("#")]),t._v(" 타입 추론(Type Inference)")]),t._v(" "),a("p",[t._v("타입 추론이란 타입스크립트가 코드를 해석해 나가는 동작을 의미합니다.")]),t._v(" "),a("h2",{attrs:{id:"타입-추론의-기본"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#타입-추론의-기본"}},[t._v("#")]),t._v(" 타입 추론의 기본")]),t._v(" "),a("p",[t._v("타입스크립트가 타입 추론을 해나가는 과정은 다음과 같습니다.")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" x "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("위와 같이 "),a("code",[t._v("x")]),t._v("에 대한 타입을 따로 지정하지 않더라도 일단 "),a("code",[t._v("x")]),t._v("는 "),a("code",[t._v("number")]),t._v("로 간주됩니다. 이렇게 변수를 선언하거나 초기화 할 때 타입이 추론됩니다. 이외에도 변수, 속성, 인자의 기본 값, 함수의 반환 값 등을 설정할 때 타입 추론이 일어납니다.")]),t._v(" "),a("h2",{attrs:{id:"가장-적절한-타입-best-common-type"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#가장-적절한-타입-best-common-type"}},[t._v("#")]),t._v(" 가장 적절한 타입(Best Common Type)")]),t._v(" "),a("p",[t._v("타입은 보통 몇 개의 표현식(코드)을 바탕으로 타입을 추론합니다. 그리고 그 표현식을 이용하여 가장 근접한 타입을 추론하게 되는데 이 가장 근접한 타입을 "),a("a",{attrs:{href:"https://www.typescriptlang.org/docs/handbook/type-inference.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("Best Common Type"),a("OutboundLink")],1),t._v("이라고 합니다.")]),t._v(" "),a("p",[t._v("잠깐 예제를 보겠습니다.")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" arr "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("위 변수 "),a("code",[t._v("arr")]),t._v("의 타입을 추론하기 위해서는 배열의 각 아이템을 살펴봐야 합니다. 배열의 각 아이템의 타입은 크게 "),a("code",[t._v("number")]),t._v("와 "),a("code",[t._v("null")]),t._v("로 구분됩니다. 이 때 Best Common Type 알고리즘으로 다른 타입들과 가장 잘 호환되는 타입을 선정합니다.")]),t._v(" "),a("h2",{attrs:{id:"문맥상의-타이핑-contextual-typing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#문맥상의-타이핑-contextual-typing"}},[t._v("#")]),t._v(" 문맥상의 타이핑(Contextual Typing)")]),t._v(" "),a("p",[t._v("타입스크립트에서 타입을 추론하는 또 하나의 방식은 바로 문맥상으로 타입을 결정하는 것입니다. 이 문맥상의 타이핑(타입 결정)은 코드의 위치(문맥)를 기준으로 일어납니다.")]),t._v(" "),a("h3",{attrs:{id:"예시-코드-1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#예시-코드-1"}},[t._v("#")]),t._v(" 예시 코드 1")]),t._v(" "),a("p",[t._v("예시 코드를 보겠습니다.")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("window"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("onmousedown")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("mouseEvent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("mouseEvent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("button"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("   "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//<- OK")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("mouseEvent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("kangaroo"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//<- Error!")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),a("p",[t._v("위 코드를 타입스크립트 검사기 관점에서 보면 "),a("code",[t._v("window.onmousedown")]),t._v("에 할당되는 함수의 타입을 추론하기 위해 "),a("code",[t._v("window.onmousedown")]),t._v(" 타입을 검사합니다. 타입 검사가 끝나고 나면 함수의 타입이 마우스 이벤트와 연관이 있다고 추론하기 때문에 "),a("code",[t._v("mouseEvent")]),t._v(" 인자에 "),a("code",[t._v("button")]),t._v(" 속성은 있지만 "),a("code",[t._v("kangaroo")]),t._v(" 속성은 없다고 결론을 내립니다.")]),t._v(" "),a("h3",{attrs:{id:"예시-코드-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#예시-코드-2"}},[t._v("#")]),t._v(" 예시 코드 2")]),t._v(" "),a("p",[t._v("다른 예제를 보겠습니다.")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[t._v("window"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("onscroll")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("uiEvent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("uiEvent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("button"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//<- Error!")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("앞의 예제와 마찬가지로 오른쪽의 함수는 "),a("code",[t._v("window.onscroll")]),t._v("에 할당되었기 때문에 함수의 인자 "),a("code",[t._v("uiEvent")]),t._v("는 "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/UIEvent",target:"_blank",rel:"noopener noreferrer"}},[t._v("UIEvent"),a("OutboundLink")],1),t._v("으로 간주됩니다. 그래서 앞에서 봤던 "),a("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent",target:"_blank",rel:"noopener noreferrer"}},[t._v("MouseEvent"),a("OutboundLink")],1),t._v("와는 다르게 "),a("code",[t._v("button")]),t._v(" 속성이 없다고 추론합니다. 그러므로 "),a("code",[t._v("uiEvent.button")]),t._v("에서 에러가 나죠.")]),t._v(" "),a("p",[t._v("여기서 만약 문맥상 타이핑을 좀 더 이해하고자 한다면 아래와 같이 코드를 바꿔볼 수도 있습니다.")]),t._v(" "),a("div",{staticClass:"language-ts extra-class"},[a("pre",{pre:!0,attrs:{class:"language-ts"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("const")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function-variable function"}},[t._v("handler")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("uiEvent")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n  "),a("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("console")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("uiEvent"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("button"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//<- OK")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),a("p",[t._v("오른쪽 함수 표현식이 앞의 예제와 동일하지만 함수가 할당되는 변수만으로는 타입을 추정하기 어렵기 때문에 아무 에러가 나지 않습니다.")]),t._v(" "),a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("WARNING")]),t._v(" "),a("p",[t._v("위 코드에서 "),a("code",[t._v("--noImplicitAny")]),t._v(" 옵션을 사용하면 에러납니다 😄")])]),t._v(" "),a("h2",{attrs:{id:"타입스크립트의-타입-체킹"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#타입스크립트의-타입-체킹"}},[t._v("#")]),t._v(" 타입스크립트의 타입 체킹")]),t._v(" "),a("p",[t._v("타입 체킹에 있어서 타입스크립트의 지향점은 타입 체크는 값의 형태에 기반하여 이루어져야 한다는 점입니다.\n이걸 Duck Typing 또는 Structural Subtyping 이라고 합니다.")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[t._v("Duck Typing : 객체의 변수 및 메서드의 집합이 객체의 타입을 결정하는 것을 의미. 동적 타이핑의 한 종류\nStructural Subtyping : 객체의 실제 구조나 정의에 따라 타입을 결정하는 것을 의미")])])])}),[],!1,null,null,null);s.default=e.exports}}]);